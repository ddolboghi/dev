# ref
---
- 컴포넌트 안에서 조회 및 수정할 수 있는 변수가  있지만 해당 정보로 인해 새로운 렌더링을 발생시키고 싶지는 않을때(`setTimeout`, `setInterval`을 통해서 만들어진 id, 외부 라이브러리를 사용하여 생성된 인스턴스)
- 특정 DOM을 선택해야 할때(scroll의 위치 등)
- JSX를 계산하는데 필요하지 않은 다른 객체를 저장할때
- 함수형 컴포넌트에서 `useRef()`를 사용하여 ref 설정
- `ref.current`: ref 속성의 현재 값
- ref는 모든 유형의 값을 **참조**할 수 있는 자바스크립트 **객체**임
- 데이터가 이벤트 처리부분에서만 필요하며 변경되어도 재렌더링이 필요하지 않은 경우에는 ref를 사용하는게 효율적일 수 있음
- ref는 객체지향프로그래밍에서 인스턴스 필드와 비슷하게 생각하면 됨
  `this.something`대신 `somethingRef.current`로 작성함
- 리액트는 커밋 중에 `ref.current`를 설정함
- 보통 ref는 이벤트 핸들러 로직 내부에서 접근해 DOM 요소를 제어함
([맨 밑의 문제 풀기](https://react.dev/learn/referencing-values-with-refs))
```jsx
import { useRef } from 'react'; //useRef 훅 임포트

export default function myComponent() {
	const ref = useRef(0); // useRef(초기값)
}
```

| ref                                                            | state                                                                            |
| -------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| `useRef(초기값)`는 `{current: 초기값}`반환                     | `useState(초기값)`은 상태 변수의 현재값과 상태 설정함수(`[value, setValue]`)반환 |
| 변경시 재렌더링을 트리거하지 않음                                | 변경시 재렌더링을 트리거함                                                         |
| **가변** --> 렌더링 프로세스 외부에서 `current`의 값 수정 가능 | **불변** --> 상태변수를 수정하려면 setter를 사용해야하고, 재렌더링을 예약해야함  |
| 렌더링 중에는 `current`값을 읽거나 쓰지 말아야함               | 언제든지 상태 값을 읽을 수 있지만 각 렌더링에는 상태의 스냅샷이 있고, 변경되지 않음                                                                                 |

## ref 사용 시 주의사항
---
- ref를 탈출구로 취급하기: 애플리케이션 로직과 데이터 흐름의 대부분이 ref에 의존하지 않도록하기
- 렌더링 중에 `ref.current`를 읽거나 쓰기 말기: 리액트는 `ref.current`가 언제 변경되는지 모르기 때문에 렌더링 중에 읽는 것만으로도 컴포넌트의 동작을 예측하기 어렵게 만듬
  렌더링 중에 필요한 정보가 있으면 state 사용하기
  단, `ref.current = new Thing()`처럼 첫 번째 렌더링 중에 ref를 한번만 설정하는 경우는 예외
- 리액트가 관리하는(state으로 렌더링되는 등) DOM 노드를 변경하지 말기(ref로 DOM을 직접 수정하거나 자식 요소를 추가 또는 제거하면 충돌할 수 있음)
- 리액트가 관리하는 DOM 노드에서 업데이트하지 않는 부분만 ref로 수정하면 안전함
## ref를 사용한 DOM 조작
---
- DOM 요소에 초점을 맞추거나, 스크롤하거나, 크기와 위치를 측정해야 할때
- JSX 요소의 `ref`속성에 `useRef`로 설정한 ref 객체를 전달하면 리액트가 해당하는 DOM 요소를 `myRef.current`에 넣어 내장 브라우저 API를 사용할 수 있음([ref를 사용한 DOM 조작 문제 풀기](https://react.dev/learn/manipulating-the-dom-with-refs))
```jsx
import { useRef } from 'react';

export default function Form() {
	const inputRef = useRef(null);

	const handleClick = () => {
		inputRef.current.focus(); //내장 브라우저 API인 focus() 사용
	};

	return (
		<>
			<input ref={inputRef} />
			<button onClick={handleClick}>Focus the input</button>
		</>
	);
}
```
### ref 콜백
---
- `ref`콜백은 JSX 요소의 `ref` 속성에서 콜백 함수를 사용하는 것
- `ref`콜백으로 ref 목록을 관리할 수 있음
- 리액트는 ref 콜백 호출시 ref를 설정할 DOM 노드도 함께 호출
- 콜백 함수에서 노드 삭제시 null 전달함
```jsx
import { useRef } from 'react';
  
export default function CatFriends() {
  const itemsRef = useRef(null); // ref는 리스트의 아이템들을 가진 맵 객체

  function scrollToId(itemId) {
    const map = getMap();
    const node = map.get(itemId);
    node.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }
  
  function getMap() {
    if (!itemsRef.current) {
      // Initialize the Map on first usage.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }
  
  return (
    <>
      <nav>
        <button onClick={() => scrollToId(0)}>
          Tom
        </button>
        <button onClick={() => scrollToId(5)}>
          Maru
        </button>
        <button onClick={() => scrollToId(9)}>
          Jellylorum
        </button>
      </nav>
      <div>
        <ul>
          {catList.map(cat => ( //map메서드로 리스트의 모든 아이템 순회
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap(); //현재 ref 값인 맵을 가져옴
                if (node) { //노드가 있다면 맵에 해당 아이템 추가
                  map.set(cat.id, node);
                } else { //노드가 없다면 맵에서 해당 아이템 삭제
                  map.delete(cat.id); 
                }
              }}
            >
              <img
                src={cat.imageUrl}
                alt={'Cat #' + cat.id}
              />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}
  
const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: 'https://placekitten.com/250/200?image=' + i
  });
}
```

### 컴포넌트에서 다른 컴포넌트의 DOM에 접근하기
---
#### `forwardRef()`
- 내장 JSX가 아닌 직접 만든 JSX에 `ref={myRef}`를 넣으면 동작하지 않고 null 전달함 --> 컴포넌트가 다른 컴포넌트의 DOM 노드에 접근할 수 없게 막기 위해 발생하는 것
- ref를 받는 컴포넌트에서 `forwardRef()`를 사용해 ref를 받아 자신의 특정한 JSX 요소에 넣을 수 있음
- 버튼, 입력란을 가진 하위 컴포넌트가 DOM 노드로 ref를 전달하고 폼, 목록, 페이지 섹션 같은 상위 컴포넌트는 DOM 노드를 노출하지(직접 사용하지) 않고 DOM 구조에 의존성을 갖지 않도록 해야함
```jsx
import { forwardRef, useRef } from 'react';

const MyInput = forwardRef((props, ref) => {
	return <input {...props} ref={ref} />;
});

export default function Form() {
	const inputRef = useRef(null);
	const handleClick = () => {
		inputRef.current.focus();
	};
	return (
		<>
			<MyInput ref={inputRef} />
			<button onClick={handleClick}>Focus the input</button>
		</>
	);
}
```
#### `useImperativeHandle()`
- 하위 컴포넌트가 상위 컴포넌트에 노출되는 기능을 제한시킴
- 상위 컴포넌트는 하위 컴포넌트의 DOM 노드가 아닌 `useImperativeHandle`호출 내에서 생성한 사용자 지정 객체로 접근하게 됨
```jsx
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef((props, ref) => {
	const realInputRef = useRef(null);
	useImperativeHandle(ref, () => ({
		focus () {
			realInputRef.current.focus();
		},
	}));
	return <input {...props} ref={realInputRef} />;
});

export default function Form() {
	const inputRef = useRef(null);

	function handleClick() {
		inputRef.current.focus();
	}
	return (
		<>
			<MyInput ref={inputRef} />
			<button onClick={handleClick}>Focus the input</button>
		</>
	);
}
```
### `flushSync`로 동기적으로 DOM 업데이트하기
---
- 상태 setter가 DOM을 즉시 업데이트하지 않아 문제될 경우 사용
```jsx
export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );
  
  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText('');
    setTodos([ ...todos, newTodo]); //아래의 ref를 수행한 후에 newTodo가 추가
    listRef.current.lastChild.scrollIntoView({ //업데이트되기 전의 todos를 사용하게 됨
      behavior: 'smooth',
      block: 'nearest'
    });
  }
...
}
```

1. react-dom에서 flushSync 임포트
```jsx
import { flushSync } from 'react-dom';
```
2. 상태 업데이트 부분을 flushSync로 둘러싸기
```jsx
flushSync(() => {
	setTodos([ ...todos, newTodo]);
});
```

# `useEffect`
---
- Effect는 리액트 코드에서 탈출하여 외부 시스템과 동기화하는데 사용됨
- Effect는 특정 이벤트가 아닌 렌더링 자체에 의해 발생하는 사이드이펙트 지정할 수 있음 --> 사이드이펙트를 렌더링 계산에서 분리하기위해 `useEffect`로 사이드이펙트를 래핑함
- Effect는 화면이 업데이트된 후에 커밋이 끝나는 시점에 실행되고, 이 시점에서 컴포넌트를 외부 시스템과 동기화하는 게 좋음
- 사이드이펙트가 다른 상태에 기반하여 어떤 상태를 조정하는 경우에는 Effect가 필요하지 않을 수도 있음
- 컴포넌트가 렌더링될때마다 실행되는 Effect는 모두 독립적임
- **렌더링 중 DOM을 수정하는 행위도 사이드이펙트임**
- 개발 중에만 발생하는 동작: Strict Mode가 활성화되있으면 리액트는 각 컴포넌트를 마운트한 후 한 번 더 리마운트함(상태와 DOM은 보존됨) --> clean-up이 필요한 Effect를 찾는데 도움되며, 초기에 버그 발견 가능

## 1. Effect 선언하기
---
```jsx
import { useEffect } from 'react';

function MyComponent() {
	useEffect(() => {
	 // 사이드이펙트를 수행하는 코드
	 // 이곳의 코드는 모든 렌더링 이후에 실행됨
	}, [/* 의존성 배열 */]);
}
```
- 컴포넌트가 렌더링될때마다 리액트는 화면을 업데이트한 후 `useEffect`내의 코드를 실행함
```jsx
const [count, setCount] = useState(0);
useEffect(() => {
	setCount(count + 1);
});
```
- `useEffect`내에서 상태를 즉시 설정하면 다시 렌더링이 발생하고, 이로인해 효과가 다시 실행되고 다시 상태를 설정해 또 다른 렌더링이 발생하며 무한 루프에 빠짐

## 2. Effect의 종속성 지정하기
---
- 리액트에게 Effect를 불필요하게 다시 실행하지 말라고 지시하려면 `useEffect`의 두번째 인자로 종속성 배열을 지정하면 됨
- `useEffect`내부의 코드가 의존하는 값을 종속성 배열에 추가해야함
	- Effect에서 읽은 모든 반응형 값(props, state, 그외 컴포넌트 내에서 사용되는 값)이면서 컴포넌트를 재렌더링하거나 useEffect를 재실행하는데 영향을 주는 값만 추가해야함
- **지정한 모든 종속성이 이전 렌더링과 정확히 동일한 값을 갖는 경우에만 Effect를 다시 실행하지 않음**
```jsx
 useEffect(() => {
	if (isPlaying) { // 여기서 사용됩니다...
	  // ...
	} else {
	  // ...
	}
}, [isPlaying]); // ...따라서 여기서 선언되어야 합니다!
```

- 종속성 배열이 아예 없으면 `useEffect`는 모든 렌더링 이후에 실행되며, 렌더링될때마다 실행됨
```jsx
useEffect(() => {
	...
});
```
- 빈 종속성 배열이 있으면 컴포넌트가 처음 나타날때(마운트될때)만 실행되지만, 컴포넌트가 새로 렌더링되면 다시 실행됨
```jsx
useEffect(() => {
  ...
}, []);
```
- 종속성 배열에 값이 있으면 마운트될때도 실행되고, 마지막 렌더링 이후에 값이 변경된 경우에도 실행됨
```jsx
useEffect(() => {
  // 이것은 마운트될 때 실행되며, a 또는 b가 마지막 렌더링 이후에 변경된 경우에도 실행됩니다.
}, [a, b]);
```

### 종속성 배열에서 생략될 수 있는 것들
---
- 안정적인 식별성을 갖는 값, 항상 동일한 값은 `useEffect`를 다시 실행시키지 않기 때문에 생략 가능
- 단, 린터가 해당 값이 안정적인지 보고 있을때만 생략가능
  부모 컴포넌트에서 전달되는 값은 달라질 수 있으므로 종속성 배열에 추가해야함

### 종속성으로 인해 원하지 않는 Effect가 동작할때
---
- Effect가 독립적인 동기화 프로세스를 나타내는지 확인하기
	- Effect가 아무것도 동기화하지 않는다면 불필요한 동기화일 수 있음
	- 여러 개의 독립적인 것을 동기화하는 경우 이를 분할하기
- props나 state에 반응하지 않으며 Effect를 다시 동기화하지 않고 최신 값을 읽으려면 Effect를 반응하는 부분와 반응하지 않는 부분(Effect Event)으로 분할하기([참고: 이벤트 분할하기](https://react.dev/learn/separating-events-from-effects))
- 객체와 함수를 종속성으로 의존하지 말기([참고: 불필요한 의존성 제거](https://react.dev/learn/removing-effect-dependencies))
	- 렌더링 중에 객체와 함수를 생성하고 `useEffect`에서 읽으면 렌더링할때마다 객체와 함수가 달라져 Effect가 매번 다시 동기화됨

## 3. (필요한 경우) clean-up함수 추가하기
---
- Effect는 내부에서 사용하는 종속적인 값이 변하거나 컴포넌트가 재렌더링되면 `useEffect`가 다시 실행되기 때문에 불필요한 동작이 유지될 수 있음
- clean-up함수는 `useEffect`가 수행한 작업을 중단하거나 되돌림
- clean-up함수를 추가하면 Effect가 다시 실행되기 전에 매번 clean-up함수를 호출하며, 컴포넌트가 제거(언마운트)될때도 호출함
- 리액트는 이전 렌더의 Effect를 항상 다음 렌더의 Effect보다 먼저 정리함
- 사용자가 `useEffect` 한번 실행하는 것(프로덕션 환경)과 '설정 --> 정리 --> 설정'(개발 환경)을 구분할 수 없어야함

### 비 리액트 위젯 제어하기
---
- 리액트로 작성되지 않은 UI 위젯이 마운트되며 불필요한 동작을 유지하면 clean-up함수 작성하기
- 연속으로 두 번 호출하면 예외가 발생하는 일부 API들을 사용할때 clean-up함수 작성하기(e.g. `<dialog>`의 `showModal()`메서드)
```jsx
useEffect(() => {
	const dialog = dialogRef.current;
	dialog.showModal();
	return () => dialog.close();
}, []);
```

### 이벤트 구독 해지하기
---
- Effect가 `addEventListener()` 같은 이벤트 리스너를 호출하고 있다면 clean-up함수에 `removeEventListener()`등을 사용해 이벤트 리스너를 제거해야함
```jsx
React.useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth > 833) {
        setActive('nav-menu');
        setToggler('nav-toggler');
      }
    };
    window.addEventListener('resize', handleResize);
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
```

### 애니메이션 트리거시 초기값으로 재설정하기
---
- Effect가 애니메이션을 트리거한다면 clean-up함수로 애니메이션을 초기값으로 재설정해야함
```jsx
useEffect(() => {
	const node = ref.current;
	node.style.opacity = 1; // 애니메이션 트리거
	return () => {
		node.style.opacity = 0; // 초기 값으로 재설정
	};
}, []);
```

### 서버에서 데이터를 가져온 후 fetch를 중단하거나 결과를 무시해야함
---
```jsx
useEffect(() => {
	let ignore = false;
	async function startFetching() {
	const json = await fetchTodos(userId);
		if (!ignore) {
			setTodos(json);
		}
	}
	startFetching();
	return () => {
	ignore = true;
	};
}, [userId]);
```
- Effect가 데이터를 가져올때 clean-up함수는 더 이상 관련 없는 fetch가 애플리케이션에 영향을 미치지 않도록 해야함
- Effect는 서버에서 실행되지 않으므로 클라이언트 사이드 렌더링시 자바스크립트를 다운로드하고 앱을 렌더링한 후에야 데이터가 로드됨
- Effect 내에서 직접 데이터를 가져오면 '네트워크 폭포'가 발생해 느려질 수 있음
- Effect 내에서 직접 데이터를 가져오는 것은 데이터를 사전 로드하지 않거나 캐시하지 않는다는 의미임
- 프레임워크를 사용하는 경우 내장된 데이터 가져오기 메커니즘 사용하기
- 프레임워크를 사용하지 않는다면 클라이언트 측 캐시를 사용하거나 구축하기
	- 오픈 소스 솔루션: React Query, useSWR, React Router 6.4+

### Effect로 실행하면 안되는 경우
---
- 애플리케이션 초기화: 일부 로직은 애플리케이션이 시작될때 한 번만 실행되야함
```jsx
if (typeof window !== 'undefined') { // 브라우저에서 실행 중인지 확인합니다.
	checkAuthToken();
	loadDataFromLocalStorage();
}

function App() {
	// ...
}
```
- 제품 구매: Effect에서 제품 구매 POST요청을 보내면, 다른 페이지로 이동한 후에 뒤로가기 버튼을 누르면 Effect가 다시 실행되어 두 번 구매하게 됨
```jsx
useEffect(() => {
	// 🔴 잘못된 예: 이 효과는 개발 환경에서 두 번 실행되어 코드에 문제가 노출됩니다.
	fetch('/api/buy', { method: 'POST' });
}, []);

function handleClick() {
	// ✅ 구매는 특정 상호 작용에 의해 발생하기 때문에 이벤트입니다.
	fetch('/api/buy', { method: 'POST' });
}
```

## Effect 동작 이해하기
---
```jsx
export default function ChatRoom({ roomId }) {
	useEffect(() => {
		const connection = createConnection(roomId);
		connection.connect();
		return () => connection.disconnect();
	}, [roomId]);
	return <h1>Welcome to {roomId}!</h1>;
}
```

1. 초기 렌더링될때
- 사용자가 `<ChatRoom roomId="general" />`에 방문하면 첫번째 렌더링의 JSX는 다음과 같음
```jsx
return <h1>Welcome to general!</h1>;
```
- 렌더링후 `useEffect`실행
```jsx
// 첫 번째 렌더링의 효과(Effect) (roomId = "general")
() => {
  const connection = createConnection('general');
  connection.connect();
  return () => connection.disconnect();
},
// 첫 번째 렌더링의 종속성(dependencies) (roomId = "general")
['general']
```

2. 같은 종속성(roomId)으로 재렌더링될때
- `<ChatRoom roomId="general" />`이 재렌더링되면 JSX 출력은 동일함
- 재렌더링시 리액트는 `useEffect`의 이전 종속성과 현재 종속성을 비교하고 모든 종속성이 동일하면 `useEffect`를 호출하지 않음(Effect를 무시함)
```jsx
// 두 번째 렌더링의 JSX (roomId = "general")
return <h1>Welcome to general!</h1>;

// 두 번째 렌더링의 효과(Effect) (roomId = "general")
() => {
  const connection = createConnection('general');
  connection.connect();
  return () => connection.disconnect();
},
// 두 번째 렌더링의 종속성(dependencies) (roomId = "general")
['general']
```

3. 다른 종속성으로 재렌더링될때
- 사용자가 `<ChatRoom roomId="travel" />`를 방문하면 컴포넌트가 다른 JSX를 반환함
- 리액트는 재렌더링된 Effect를 적용하기 전에 실행되었던 마지막 Effect(첫번째 렌더링의 Effect)를 정리하기위해 첫번째 렌더링으로 올라가서 `createConnection('general')`로 생성된 connection에 대해 `disconnect()`를 호출함
```jsx
// 세 번째 렌더링의 JSX (roomId = "travel")
return <h1>Welcome to travel!</h1>;

// 세 번째 렌더링의 효과(Effect) (roomId = "travel")
() => {
  const connection = createConnection('travel');
  connection.connect();
  return () => connection.disconnect();
},
// 세 번째 렌더링의 종속성(dependencies) (roomId = "travel")
['travel']
```

4. 사용자가 다른 곳으로 이동할때
- 컴포넌트가 언마운트(제거)되며 마지막 Effect(세번째 렌더링의 Effect)의 clean-up함수 실행

# 불필요한 Effect 제거하기
---
https://reactnext-central.xyz/docs/react/escape-hatches/you-might-not-need-an-effect