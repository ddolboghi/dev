> [!warning] 여기서 말하는 서버는 프론트엔드의 서버입니다.

- 컴포넌트의 목적에 따라 컴포넌트를 클라이언트나 서버 중 어디에서 렌더링할지 선택할 수 있음
- 네트워크 경계는 서버 컴포넌트와 클라이언트 컴포넌트 사이에 있음
# 서버 컴포넌트
- 데이터를 가져오는 작업을 서버로 이동
- 클라이언트 측 자바스크립트 번들 크기에 영향을 미치는 큰 의존성을 서버에 유지해 클라이언트 측 번들 크기가 줄어들어 성능 향상
- 초기 페이지 로드가 빨라짐
- Next.js에서 초기 HTML은 서버에서 렌더링됨
- Next.js에서, 클라이언트 측에서 상호작용을 추가할 수 있는 이유는 비동기적으로 Next.js와 리액트 클라이언트 측 런타임을 로드하기 때문
- App Router 내의 모든 컴포넌트는 기본적으로 서버 컴포넌트임
# 클라이언트 컴포넌트
- 애플리케이션에 클라이언트 측 상호작용 추가
- Next.js에서는 클라이언트 컴포넌트가 서버에서 사전 렌더링되고 클라이언트에서 가공됨
- `'use client'`
	- 서버 컴포넌트와 클라이언트 컴포넌트의 경계
	- 파일의 최상단(import문보다 위)에 위치
	- 정의된 파일에 import되는 모든 모듈, 자식 컴포넌트들을 클라이언트 컴포넌트로 간주함 --> 클라이언트 측 루트 컴포넌트에 정의하기
# 서버 & 클라이언트 컴포넌트 사용 사례
|  | 서버 컴포넌트 | 클라이언트 컴포넌트 |
| ---- | ---- | ---- |
| 데이터 가져오기 | O |  |
| 백엔드 자원에 직접 접근 | O |  |
| 서버에 민감한 정보(접근 토큰, API 키 등)를 유지 | O |  |
| 서버에 큰 의존성 유지 / 클라이언트 사이드 JS 축소 | O |  |
| 상호작용, 이벤트 리스너 추가 |  | O |
| useState, useReducer, useEffect등 사용 |  | O |
| 브라우저 전용 API 사용 |  | O |
| 상태, 이펙트, 브라우저 전용 API에 의존하는 사용자 정의 훅 사용 |  | O |
| 리액트 클래스 컴포넌트 사용 |  | O |
# 서버 & 클라이언트 컴포넌트 작성 패턴
- 클라이언트 컴포넌트는 리프 노드로 이동시키기
- 상호작용하는 로직만 클라이언트 컴포넌트로 이동시키고 레이아웃은 서버 컴포넌트에 두기
- 서버 컴포넌트를 props로서 클라이언트 컴포넌트에 전달하기
	- 클라이언트 컴포넌트에서 서버 컴포넌트를 import할 수 없으므로 props으로 전달(보통 `{ children }` 사용)
	- 원래 서버 컴포넌트를 클라이언트 컴포넌트의 자식이나 prop으로 전달할 수 있던 점 활용한 것
	- 각 컴포넌트들은 독립적으로 렌더링됨
- 서버에서 클라이언트 컴포넌트로 props 전달하려면 직렬화해야함
- next.js에서 서드파티 라이브러리가 클라이언트 코드에 'use client'를 추가하면, 래퍼 클라이언트 컴포넌트를 제거할 수 있음
- 서버 컴포넌트 간의 데이터 공유는 전역 싱글톤 패턴을 이용함
```js
//utils/database.js
export const db = new DatabaseConnection()
```

```jsx
//app/users/layout.js
import { db } from '@utils/database'
 
export async function UsersLayout() {
  let users = await db.query()
  // ...
}
```

- 서버 컴포넌트 간의 fetch 결과를 공유하려 하지 말고 데이터를 소비하는 컴포넌트와 함께 데이터를 가져오기를 권장