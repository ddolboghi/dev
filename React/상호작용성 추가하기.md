# 이벤트 핸들러
---
- 이벤트 핸들러: 클릭, 호버, 폼 입력에 포커스 등과 같은 사용자 상호 작용에 응답하기 위해 작성되는 사용자 정의 함수
- 이벤트 핸들러는 컴포넌트 내에서 정의되지만 렌더링 중에 실행되지 않고 특정 이벤트 발생시 실행됨
- 이벤트 핸들러는 순수 함수가 될 필요 없으므로 side effect 가능 --> state 사용
- 적절한 이벤트 핸들러를 찾을 수 없다면 최후의 수단으로 `useEffect`사용 가능 
  --> 되도록 논리를 렌더링 자체로 표현하기
- 이벤트 핸들러명 관례: `handle + 이벤트 이름`
- 이벤트 핸들러 속성명 관례: `on`으로 시작
- JSX에서 이벤트 핸들러 함수를 호출하지 않고 **함수를 전달해야함 --> 함수 끝에 `()`안 붙임**(호출하면 컴포넌트가 렌더링될때마다 실행됨)
- JSX 내에서 인라인으로 이벤트 핸들러를 정의할 수 있음 
```jsx
export default function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

```jsx
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>
```

```jsx
<button onClick={() => {
  alert('You clicked me!');
}}>
```
- 이벤트 핸들러 함수내에서 props를 사용할 수 있음
- 이벤트 핸들러 함수를 props로 전달할 수 있음
```jsx
function Button({onClick, children}) {
	return (
		<button onClick={onClick}>
			{children}
		</button>
	);
}

function PlayButton({movieName}) {
	function handlePlayClick() {
		alert(`playing ${movieName}`);
	}

	return (
		<Button onClick={handlePlayClick}> //이벤트 핸들러 함수를 props로 전달
			Play "{movieName}"
		</Button>
	);
}

export default function Toolbar() {
	return (
		<div>
			<PlayButton movieName="Kiki's Delivery Service"/>
		</div>
	);
}
```
- 디자인 시스템을 사용하는 경우 순수 html 태그는 스타일링만 포함하고 이벤트 동작은 다른 컴포넌트에서 이벤트 핸들러를 전달함
- `<button>`등의 내장 컴포넌트는 `onClick`과 같은 브라우저 이벤트 이름만 지원함
- 사용자 정의 컴포넌트는 이벤트 핸들러 속성명을 원하는 대로 지정 가능
- **단, 이벤트 핸들러에 적합한 html태그를 사용해야함**
  e.g. 클릭을 처리하려면 브라우저 `<button>`을 사용해야 키보드 탐색과 같은 내장된 브라우저 동작이 가능해짐
## 이벤트 전파
---
- 이벤트는 "버블링" 또는 "전파"되어 상위 태그로 이동
- 하위 태그 이벤트가 동작한 뒤에 상위 태그의 이벤트가 동작함
- 모든 이벤트는 리액트에서 전파되며, onScroll은 연결된 JSX 태그에서만 작동함
```jsx
export default function Toolbar() {
	return (
		<div onClick={() => alert('clicked toolbar')}>
			<button onClick={() => alert('playing')}>
			play
			</button>
		</div>
	);
}
```
play 버튼을 클릭하면 `<button>`의 이벤트가 실행되고 그 후에 `<div>`의 이벤트가 실행됨
`<div>`만 클릭하면 `<div>`의 이벤트만 실행됨
### 이벤트 전파 중지
---
- 이벤트 핸들러는 이벤트 객체를 유일한 인수로 받음
- 관례적으로 이벤트 객체의 변수명은 `e`로 사용
- `e.stopPropagation()`: 상위 태그로 이벤트 전파 중지시킴 -> 전파에 의존하며 어떤 핸들러가 실행되는지 추적하기 어려운 경우 이 접근 방식 사용해보기
- `e.preventDefault()`: 기본 동작 방지
```jsx
function Button({onClick, children}) {
	return (
		<button onClick={e => {
			e.stopPropagation(); //상위 태그인 div의 이벤트 핸들러 실행 안됨
			onClick();
		}}>
			{children}
		</button>
	);
}

export default function Toolbar() {
	return (
		<div onClick={() => alert('clicked toolbar')}>
			<Button onClick={() => alert('play')}>
				play
			</Button>
		</div>
	);
}
```

- 캡처 단계 이벤트: 전파가 중지된 이벤트에 대해서도 모든 자식 요소의 이벤트 캐치, 이벤트 이름 끝에 Capture를 추가해 실행
- 캡처 이벤트는 라우터나 분석에 사용
```jsx
<div onClickCapture={() => {/* 가장 먼저 실행됨 */}}>
	<button onClick={e => e.stopPropagation()}/>
	<button onClick={e => e.stopPropagation()}/>
</div>
```
1. 모든 onClickCapture 핸들러를 호출하면서 아래로 이동
2. 클릭한 요소의 onClick 핸들러를 실행
3. 위로 이동하면서 모든 onClick 핸들러를 호출

# state
---
- state(상태)는 시간에 따라 변하는 데이터
- 시간이 지나도 값이 변경되지 않거나, 부모로부터 props를 통해 전달받거나, 컴포넌트 내에서 기존 상태나 props를 기반으로 계산할 수 있다면 상태가 아님
- 부모 컴포넌트는 상태를 하위 컴포넌트에 props로 전달할 수 있음
- 상태를 구조화하는 가장 중요한 원칙은 DRY(Don't Repeat Yourself)를 유지하는 것
- 애플리케이션이 필요로하는 상태의 절대 최소한의 표현을 찾고 나머지는 필요할 때 계산하기
- **상태는 스냅샷과 유사하게 작동함**
	- 상태를 설정하면 이미 있는 상태 변수가 변경되지 않고 다시 렌더링이 트리거됨
	- 이 동작은 버그를 피할 수 있도록 도와줌
	  e.g. 채팅앱에서 메시지를 보낸 후에 수신자를 변경해도 이미 보낸 메시지는 수신자가 바뀌지 않음
- 상태 설정시 업데이트 함수(화살표 함수)를 전달해 여러 상태 업데이트를 큐에 저장할 수 있음
  e.g. `setScore(score+1)` --> `setScore(s => s+1)`: score값이 업데이트됨
- 상태 변수가 여러 개라면 객체를 하나의 상태 변수로 가지는게 더 편리함
- 상태에서 직접 객체와 배열을 변경하면 안됨
	- 객체와 배열을 업데이트하려면 새로운 객체를 생성하거나, 기존 객체의 사본을 만들거나, 상태가 새로운 객체를 사용하도록 업데이트해야함
	- 일반적으로 `...`spread구문으로 변경하려는 객체와 배열 복사함
	- 상태에 저장할 배열은 읽기 전용으로 처리해야함

## `useState`hook으로 컴포넌트에 상태변수 추가
---
- 새로운 데이터로 컴포넌트를 업데이트하려면 컴포넌트 렌더링 간에 데이터를 유지하고 새 데이터로 컴포넌트를 다시 렌더링해야함
- `useState`는 상태 변수를 유지하고 상태 설정 함수로 상태 변수를 업데이트해 리액트가 컴포넌트를 다시 렌더링하도록 함

1. 내장 hook인 `userState` import 하기
```jsx
import {useState} from 'react';
```

2. 컴포넌트 내부에 상태 변수 선언하기
```jsx
function Mybutton() {
	const [count, setCount] = useState(0);
}
```
- 컴포넌트의 최상단에 `useState()` 호출해야함
- 구조 분해시 `[something, setSomething]`형식으로 작성하는게 관례
- `useState(초기값)`으로 `something`의 초기값 설정
- 상태를 변경하려면 `setSomething()`을 호출하고 인자로 새 값을 전달하면 됨

3. 상태값 변경하기
```jsx
function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);// count값 변경
  }

  return (
    <button onClick={handleClick}> // 상태값을 변경하는 함수를 이벤트 핸들러로 전달
      Clicked {count} times // 상태값 사용
    </button>
  );
}
```
- 동일한 컴포넌트를 여러 개 렌더링하면 각각 자기들만의 상태를 가지고 서로 영향을 미치지 않음
- 상위 컴포넌트는 하위 컴포넌트의 상태를 모르고, 변경할 수 없음

## 상태 구조 원칙
---
- 상태 그룹화
	- 항상 동시에 업데이트되는 2개 이상의 상태 변수들은 하나로 합치는 걸 고려하기
	- 얼마나 많은 상태가 필요한지 모를때도 그룹화하면 좋음
	- 상태 변수를 객체로 묶고 하나의 상태 변수만 변경하려면
	  `setPosition({...position, x:100)}`처럼 spread 구문 사용
- 여러 개의 상태가 서로 모순되거나 불일치할 수 있는 방식은 피하기
	- 하나의 상태로 서로 다른 로컬 변수를 나타내도록 바꾸기
```jsx
import { useState } from 'react';

export default function FeedbackForm() {
	const [text, setText] = useState('');
	const [status, setStatus] = useState('typing');
	//const [isSending, setIsSending] = useState(false);
	//const [isSent, setIsSent] = useState(false);
	
	async function handleSubmit(e) {
		e.preventDefault();
		setStatus('sending');
		await sendMessage(text);
		setStatus('sent');
	}

	//하나의 상태로 2개의 기존 상태들을 대체함
	const isSending = status === 'sending';
	const isSent = status === 'sent';
	...
}
```
- 과다 상태 피하기: 렌더링 중에 어떤 props나 상태 변수에서 한 상태 정보를 계산할 수 있으면 중복되는 것이므로 중복되는 해당 상태를 제거하기
	- 상태 변수 초기화값에 props 사용하지 말기(미러링하지 말기): 부모 컴포넌트가 나중에 다른 props값을  전달해도 자식 컴포넌트의 상태 변수 값은 업데이트 되지 않고 최초 렌더링시 지정한 초기값을 유지함
	- 특정 props에 대한 모든 업데이트를 무시하고 싶을때만 미러링하기, 이때는 props이름 앞에 `initial`또는 `default`을 붙여 업데이트되지 않는다는걸 명확히하기
- 중복 상태 피하기: 여러 상태 변수 간에 또는 중첩된 개체 내에서 동일한 데이터가 중복되면 동기화 상태를 유지하기 어려움
	- 중복된 상태:
	  `items = [{ id: 0, title: 'pretzels'}, ...]`
	   `selectedItem = {id: 0, title: 'pretzels'}`
	- 중복을 제거한 상태:
	  `items = [{ id: 0, title: 'pretzels'}, ...]`
	  `selectedId = 0` --> `selectedId`로 `selectedItem`을 찾음
- 깊게 중첩된 상태 피하기
	- 정규화: 깊게 계층화된 상태 변수(리터럴 객체)는 업데이트하기 불편하므로 평평한 방식으로 변환하기
	- 컴포넌트 분리: 중접된 상태의 일부를 하위 컴포넌트로 이동시키기 --> 마우스 hover 여부 처럼 저장할 필요 없는 임시 UI 상태에 효과적임
[맨 밑에 문제 풀어보기](https://react.dev/learn/choosing-the-state-structure)

## Hooks
---
- Hook: `use`로 시작하는 함수
- hook은 리액트가 렌더링하는 동안에만 사용할 수 있는 함수임
- 기존 hook을 조합해 직접 hook 작성 가능
- **hook은 컴포넌트의 최상단 또는 자체적인 hook에서만 호출 가능**
- 조건문이나 반복문에서 hook 사용하려면 해당 hook을 사용하는 새로운 컴포넌트를 추출해서 원래 위치에 컴포넌트를 넣으면 됨

|                       |                                                                                                                                                                                                                            |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `useState`            | 함수 컴포넌트에 리액트 상태를 추가할수 있게 함                                                                                                                                                                             |
| `useEffect`           | - 함수 컴포넌트에서 사이드 이펙트를 수행할 수 있게 해줌<br> - `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`와 같은 목적으로 사용됨                                                                     |
| `useContext`          | 중첩을 추가하지 않고도 리액트 컨텍스트에 구독할 수 있게 해줌                                                                                                                                                               |
| `useReducer`          | 복잡한 상태로직에서 자주 사용<br> 여러 하위 값이 관련되거나 다음 상태가 이전 상태에 의존하는 복잡한 상태로직에 사용                                                                                                        |
| `useCallback`         | 의존성 중 하나가 변경될때만 변경되는 메모이즈된 콜백 버전 반환<br> 불필요한 렌더링을 방지하기 위해 참조 동등성을 기반으로 최적화된 자식 컴포넌트에 콜백 전달할때 유용                                                      |
| `useMemo`             | 메모이즈된 값 반환<br> 생성 함수와 의존성 배열 전달<br> 의존성 중 하나가 변경될때만 메모이즈된 값을 다시 계산                                                                                                              |
| `useRef`              | 전달된 인수(initialValue)로 초기화된 `.current`속성을 갖는 가변적인 ref객체 생성<br> 반환된 객체는 컴포넌트의 전체 수명동안 유지됨                                                                                         |
| `useImperativeHandle` | ref를 사용할때 부모 컴포넌트에 노출되는 인스턴스 값을 사용자 정의 설정하는데 사용                                                                                                                                          |
| `useLayoutEffect`     | `useEffect`와 동일한 형태로 동작하지만 DOM 변경 후 동기적으로 발생<br> DOM에서 레이아웃을 읽고 동기적으로 다시 렌더링할 수 있음<br> `useLayoutEffect`내에서 예약된 업데이트는 브라우저가 그려지기 전에 동기적으로 플러시됨 |
|`useDebugValue`|react DevTools에서 사용자 정의 훅의 레이블을 표시하는데 사용됨|

## 컴포넌트 간 데이터 공유(상태 끌어올리기)
---
- 컴포넌트 간 데이터를 공유하려면 개별 컴포넌트에 상태를 두지 말고 모두를 포함하는 상위의 가장 가까운 컴포넌트에 상태를 두어 하위 컴포넌트에 전달하면 됨
- props: JSX 중괄호를 사용해 하위 컴포넌트로 전달하는 정보들
```jsx
export default function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>함께 업데이트되는 카운터</h1>
      // onClick prop가 handleClick함수로 설정됨
      // count값이 prop로 전달됨
      <MyButton count={count} onClick={handleClick} /> 
      <MyButton count={count} onClick={handleClick} />
    </div>
  );
}

function MyButton({ count, onClick }) {
  return (
    <button onClick={onClick}>
      {count}번 클릭됨
    </button>
  );
}
```

# 리액트의 렌더링과 DOM 커밋
---
- 렌더링: 리액트가 컴포넌트를 호출하는 것
- 로컬 변수는 렌더링 간에 지속되지 않음
- 로컬 변수의 변경 사항은 렌더링을 트리거하지 않음

## 1. 렌더링 <u>트리거</u>
---
컴포넌트가 렌더링되는 이유:
- 컴포넌트의 초기 렌더링: 앱이 시작될때 초기 렌더링 트리거, index.js의 `root.render()`가 초기 렌더링하는 부분임
- 컴포넌트(또는 그 조상 중 하나)의 상태 업데이트: `set`함수로 상태 업데이트하면 자동으로 렌더링이 대기열에 추가됨

## 2. 리액트가 컴포넌트를 <u>렌더링</u>
---
- 초기 렌더링에서 리액트는 루트 컴포넌트를 호출하며 DOM 노드 생성
- 추가적인 렌더링에서 리액트는 렌더링을 트리거한 함수 컴포넌트를 호출함
- 컴포넌트가 반환하는 컴포넌트가 더이상 없을때까지 계속 렌더링
- 재렌더링 중 리액트는 이전 렌더링과 비교하여 변경된 속성을 계산하고, 커밋 단계에서 사용하기 전까지는 아무 작업도 하지 않음

## 3. 리액트가 DOM에 변경 사항을 <u>커밋</u>
---
- 초기 렌더링에서 리액트는 생성한 모든 DOM 노드를 `appendChild()` DOM API를 사용해 화면에 배치함
- 재렌더링에서 리액트는 렌더링 중 계산된 최소한의 작업을 수행해 DOM을 최신 렌더링 결과와 일치시킴
- **리액트는 렌더링 결과가 이전과 동일하면 DOM 노드를 바꾸지 않음**
- 부모로부터 전달되는 속성이나 상태가 변해야 노드가 바뀜
- DOM을 업데이트한 후에는 브라우저가 화면을 다시 그림