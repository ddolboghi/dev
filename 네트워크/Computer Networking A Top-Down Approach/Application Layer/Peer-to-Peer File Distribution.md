# Scalability of P2P Architectures

클라이언트-서버 아키텍처와 P2P 아키텍처를 비교하고 P2P의 고유한 자체 확장성을 설명하기 위해, 고정된 수의 피어에게 파일을 배포하는 두 아키텍처 유형에 대한 간단한 정량적 모델을 고려한다. 
![[p2p_example.png | 500]]
위와 같이 서버와 피어들은 접속 링크를 통해 인터넷에 연결되어 있다. 인터넷 코어는 충분한 대역폭을 가지고 있어 모든 병목 현상은 접속 네트워크에서 발생한다고 가정한다.
- 서버의 업로드 속도: $u_s$
- i번째 피어의 업로드 속도: $u_i$
- i번째 피어의 다운로드 속도를 $d_i$
- 배포할 파일의 크기: $F$ 비트
- 파일 복사본을 얻으려는 피어의 수: $N$
- 배포 시간: $N$개의 모든 피어에게 파일 복사본을 전달하는 데 걸리는 시간

## Client-Server Architecture
- 서버는 $N$개의 각 피어에게 파일의 복사본 하나씩을 전송해야 하므로 파일 배포 시간은 최소 $NF/u_s$다.
- 가장 낮은 다운로드 속도를 가진 피어($d_{min}$)는 $F$ 비트의 파일을 $F/d_{min}$초보다 짧은 시간에 받을 수 없다. 따라서 최소 배포 시간은 최소 $F/d_{min}$이다.

이 두 가지 관찰을 종합하면, 클라이언트-서버 아키텍처의 최소 배포 시간 `D_cs`는 다음과 같이 나타낼 수 있다:
$D_{cs} = max(\frac{NF}{u_s}, \frac{F}{d_{min}})$

$N$이 충분히 크면, 배포 시간은 `NF/us`에 의해 결정되므로 피어의 수 `N`에 따라 선형적으로 증가한다.
# P2P Architecture
P2P 아키텍처에서는 각 피어가 서버를 도와 파일을 배포할 수 있다.
- 배포 초기에는 서버만이 파일을 가지고 있으므로, 모든 피어 커뮤니티에 파일을 전달하기 위해 서버는 파일의 각 비트를 최소 한 번은 자신의 접속 링크로 보내야 한다. 따라서 최소 배포 시간은 최소 $F/u_s$이다.
- 클라이언트-서버 아키텍처와 마찬가지로, 가장 낮은 다운로드 속도를 가진 피어는 $F/d_{min}$초보다 짧은 시간에 파일을 받을 수 없다. 따라서 최소 배포 시간은 최소 $F/d_{min}$이다.
- 시스템 전체의 총 업로드 용량은 서버의 업로드 속도와 모든 피어의 업로드 속도의 합인 $u_{total} = u_s + u_1 + ... + u_N$이다. 시스템은 $N$개의 각 피어에게 $F$ 비트를 전달해야 하므로 총 $NF$ 비트를 전달해야 한다. 이는 $u_{total}$보다 빠른 속도로 이루어질 수 없으므로, 최소 배포 시간은 최소 $NF/(u_s + u_1 + ... + u_N)$이다.

이 세 가지 관찰을 종합하여 P2P의 최소 배포 시간 $D_{P2P}$는 다음과 같다:

$D_{P2P} = max(F/u_s, F/d_{min}, NF/(u_s + \sum_{} u_i))$

![[distribution_time_graph.png  | 500]]
클라이언트-서버의 배포 시간은 피어 수가 증가함에 따라 선형적으로 무한히 증가하지만, P2P의 배포 시간은 항상 클라이언트-서버보다 짧고, 어떤 피어 수 $N$에 대해서도 1시간 미만으로 유지된다. 이는 P2P 애플리케이션이 비트의 소비자이자 재배포자 역할을 하는 피어 덕분에 **자체 확장성(self-scaling)** 을 가질 수 있음을 보여준다.

# BitTorrent
비트토렌트(BitTorrent)는 대용량 파일을 효율적으로 배포하기 위한 인기 있는 **P2P(Peer-to-Peer) 프로토콜**이다. 클라이언트-서버 방식과 달리 중앙 서버에 대한 의존도를 최소화하고, 사용자들이 서로 직접 파일을 주고받는 방식으로 작동한다.
### 주요 구성 요소
- **토렌트(Torrent)**: 특정 파일을 배포하는 데 참여하는 모든 사용자(피어)의 집합을 의미한다.
- **청크(Chunks)**: 파일은 보통 256KB 크기의 작은 조각들로 나뉘어 전송된다. 피어들은 이 청크 단위로 파일을 다운로드하고 다른 피어에게 업로드한다.
- **트래커(Tracker)**: 토렌트에 참여 중인 피어들의 목록을 추적하고 관리하는 중앙 인프라 노드다. 새로운 피어가 토렌트에 참여하면 트래커는 다른 피어들의 IP 주소 목록을 제공하여 연결을 돕는다.---
### 작동 방식 및 핵심 전략
비트토렌트의 효율성은 두 가지 핵심 전략에 기반한다.
#### 1. 가장 희귀한 조각 먼저 받기 (Rarest First)

피어는 파일을 다운로드할 때, 이웃 피어들 사이에서 가장 적게 복제된, 즉 가장 희귀한 청크를 먼저 요청합니다. 이 방식은 희귀한 청크가 네트워크에 빠르게 퍼지도록 하여 모든 피어가 파일의 모든 부분을 원활하게 다운로드할 수 있도록 돕습니다.

#### 2. 기브 앤 테이크 전략 (Tit-for-Tat)

피어는 데이터를 업로드할 때 자신에게 가장 높은 속도로 데이터를 보내주는 이웃에게 우선순위를 부여합니다. 이를

**팃포탯(tit-for-tat)** 전략이라고 합니다.

- **언초크(Unchoked)**: 각 피어는 자신에게 가장 빠르게 데이터를 보내주는 상위 4명의 피어를 선택하여 데이터를 보내줍니다. 이 상태를 '언초크'라고 합니다.
    
- **낙관적 언초킹(Optimistically Unchoked)**: 30초마다 무작위로 다른 이웃 한 명을 추가로 선택해 청크를 보내줍니다. 이는 새로 참여한 피어가 첫 청크를 얻어 교환을 시작할 기회를 주고, 더 나은 업로드 파트너를 찾도록 돕습니다.
    

이러한 인센티브 구조는 사용자들이 다운로드만 하는

**'프리라이딩(free-riding)'을 방지**하고 모든 참여자의 활발한 공유를 유도하여 전체 시스템의 효율성을 높이는 핵심적인 역할을 합니다.



```
다음 챕터들을 찾아 내용을 설명해라.
설명할 chapter 목록:
- Chapter 2.5
- Chapter 2.6.1
- Chapter 2.6.2
- Chapter 2.6.3
- Chapter 2.6.4

그리고 설명할때 다음 지침을 반드시 따르세요:

- 각 chapter에 대해서, 해당 chapter 내용만 그대로 설명하세요.
- 요약하거나 간략화하지 마세요.  
- 반드시 원문 흐름과 논리 전개를 최대한 충실하게 설명하세요.  
- 단, 문장 구조나 표현은 독자가 이해하기 쉽도록 자연스럽게 풀어서 설명해도 됩니다.
- 설명 시 반드시 다음 형식을 지켜 주세요:
   - 각 chapter마다 "## Chapter X.X.X" 형태의 대제목을 먼저 적으세요.
   - chapter의 하위 제목들을 "소제목 이름" 형태의 소제목을 만들어 구분하세요.
   - 하위 개념(절 또는 항목)마다 명확히 구분해서 서술하세요. 절대 내용을 한 덩어리로 합쳐서 설명하지 마세요.
   - 예시 형식:
   <Chapter x.y.z>
     <Web Objects>
     (내용)  
     <URL Components>  
     (내용)  
     <Round-Trip Time and Object Retrieval>
     (내용)

- 반드시 지정된 chapter 범위 내에서만 내용을 찾아 설명하세요. 예를들어, "chapter 2.1.5"를 설명할 때 "chapter 2.1.6" 또는 "chapter 3.x.x" 내용 포함 금지. 
   - cross-reference (다른 chapter 내용 인용 및 설명) 금지.  
- 단, 필요에 따라 관련성이 높은 다른 chapter는 **그 chapter 번호만 명시**하세요.
   - 예시: "이 내용과 관련된 추가 설명은 chapter 3.2.1에 있습니다."
- 만약 해당 chapter에서 특정 Figure를 참고하거나 설명하고 있다면, 반드시 그 Figure 번호를 명시하세요.  
   - 예시: "이 내용은 Figure 1.18에 나와 있습니다."
- 각 chapter의 설명이 끝날 때마다 반드시 다음 chapter의 설명으로 넘어가기 전에 **줄바꿈 및 제목 구분**을 명확히 하세요.
```