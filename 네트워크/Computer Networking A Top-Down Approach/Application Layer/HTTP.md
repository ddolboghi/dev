- HTTP는 브라우저와 웹 서버 간에 교환되는 메시지의 형식과 순서를 정의한다.
- 웹 페이지는 객체(objects)로 구성된다.
- 객체는 단일 URL로 주소 지정이 가능한 파일을 의미하며, HTML파일, JPEG 이미지, JavaScript 파일, CSS 파일 또는 비디오 클립 등이 있다.
- 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조된 객체로 구성된다.
## HTTP (HyperText Transfer Protocol)
### URL 구성 요소
- 기본 HTML 파일은 해당 객체들의 URL을 통해 페이지 내 다른 객체들을 참조한다.
- **URL은 객체를 소유한 서버의 호스트 이름과 객체의 경로명으로 구성**된다.
	- 예를 들어, http://www.someSchool.edu/someDepartment/picture.gif라는 URL에서 www.someSchool.edu는 호스트 이름이고, /someDepartment/picture.gif는 경로명
- 웹 브라우저는 HTTP의 클라이언트 측을 구현한다.
- 웹 서버는 HTTP의 서버 측을 구현하며, URL로 주소 지정이 가능한 웹 객체들을 저장한다.
### HTTP의 작동 방식
- HTTP는 클라이언트가 웹 서버에 웹 페이지를 요청하는 방식과 서버가 웹 페이지를 클라이언트에게 전송하는 방식을 정의한다.
- 브라우저가 웹 페이지 내의 객체들에 대한 HTTP 요청 메시지를 서버로 보내면, 서버는 이 요청을 받아 객체를 포함하는 HTTP 응답 메시지로 응답한다.
### HTTP와 TCP의 관계
- **HTTP는 TCP를 기본 전송 프로토콜로 사용**한다. UDP 위에서 실행되지 않는다.
- 계층형 아키텍처 덕분에, HTTP는 TCP가 네트워크 내에서 데이터 손실 또는 순서를 어떻게 복구하는지에 대한 세부 사항을 고려지 않아도 된다. 이는 TCP와 하위 계층 프로토콜의 역할이다.
1. 클라이언트는 먼저 서버와 TCP 연결을 시작한다.
2. 연결이 설정되면 브라우저와 서버 프로세스는 각자의 소켓 인터페이스를 통해 TCP에 접근한다.
	- 클라이언트 측 소켓 인터페이스는 클라이언트 프로세스와 TCP 연결 사이의 문이며, 서버 측에서는 서버 프로세스와 TCP 연결 사이의 문이다.
3. 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP 응답 메시를 받는다.
4. 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.
5. 클라이언트가 소켓 인터페이스로 요청 메시지를 보내면 메시지는 TCP를 통해 전달된다. 서버의 응답 메지도 마찬가지다.
6. TCP는 HTTP에 신뢰할 수 있는 데이터 전송 서비스를 제공하여 메시지가 목적지에 손상 없이 도착하도록 한다.

## 비영구 연결
- HTTP/1.0은 비영구 TCP 연결(non-persistent TCP connections)을 사용한다.
- 비영구 연결에서는 **서버가 응답을 보낸 후 TCP 연결을 닫는다.**
- **한 개의 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만을 전송**한다.
- **RTT(Round-Trip Time)** 은 작은 패킷이 클라이언트에서 서버로 이동했다가 다시 클라이언트로 돌아오는데 걸리는 시간이다.
- RTT는 패킷 전파 지연, 중간 라우터 및 스위치에서의 패킷 대기 지연, 패킷 처리 지연을 포함한다.
- TCP 연결을 시작하면 3-way handshake를 하는데, 
	1. 클라이언트가 서버로 작은 TCP 세그먼트를 보내고
	2. 서버가 승인 및 작은 TCP 세그먼트로 응답하며
	3. 마지막으로 클라이언트가 서버로 다시 승인과 함께 요청 메시지를 보낸다.
- **3-way handshake에서 1, 2단계에 1RTT가 소요**되고, **3단계에서 서버의 응답 메시지를 받을때까지 1RTT가 소요**된다.
![[http_round_trip_time_example.png | 500]]
## 영구 연결
- **HTTP/1.1 영구 연결을 사용하면 서버는 응답을 보낸 후에도 TCP 연결을 열어둔다.**
- HTTP/1.1은 단일 TCP 연결을 통해 서버의 소켓 수를 줄이고 각 전송되는 웹 페이지가 네트워크 대역폭을 공평하게 분배받을 수 있도록 한다.
- 동일한 클라이언트와 서버 간, 이어지는 요청 및 응답은 열어둔 동일한 TCP 연결을 통해 전송될 수 있다.
- 동일한 서버에 있는 여러 웹 페이지도 단일 영구 TCP 연결을 통해 동일한 클라이언트로 전송될 수 있다.
- 보류 중인 요청에 대한 응답을 기다리지 않고 연속적으로(파이프라이닝) 이뤄질 수 있다.
- 일반적으로 HTTP 서버는 특정 시간(time out) 동안 사용되지 않으면 연결을 닫는다.
- HTTP의 기본 모드는 파이프라이닝을 포함하는 영구 연결을 사용한다.
- 비영구 연결과 영구 연결의 성능 비교는 다음을 참고: Heidemann 1997; Nielsen 1997; RFC 7540
## Head-of-Line (HOL) Blocking
- 단일 TCP 연결로 웹 페이지의 모든 객체를 전송하면 HOL blocking 문제를 일으킨다.
- 예를 들어, 웹 페이지에 HTML 기본 페이지, 웹 페이지 상단 근처의 대형 비디오 클립, 그리고 비디오 아래의 많은 작은 객체들이 포함되어 있으며, 서버와 클라이언트 사이의 경로에 저속 병목 링크가 있다고 가정해보자. 단일 TCP 연결을 사용하면 비디오 클립이 병목 링크를 통과하는데 오랜 시간이 걸리는 동안, 작은 객체들은 비디오 클립 뒤에서 기다리면서 지연된다. 즉, "줄의 맨 앞"(Head-of-Line)에 있는 비오 클립이 그 뒤에 있는 작은 객체들을 block한다.
- HTTP/1.1 브라우저는 일반적으로 **여러 개의 병렬 TCP 연결을 열어** HOL Blocking 문제를 해결한다. 그면 작은 객체들은 브라우저에 훨씬 더 빠르게 도착하여 렌더링 될 수 있으며, 이는 사용자 인식 지연을 줄여준다.
# HTTP 메시지 형식
## HTTP 요청 메시지
- 요청 메시지는 ASCII텍스트로 작성되어 사람이 읽을 수 있다.
- 첫번째 줄은 **request line**이라고 불리며, **메서드(GET, POST 등)**, **URL**, **HTTP 버전**가 있다.
- 그 뒤의 줄들은 **header line**이라고 불린다:
	```
	# 예시
	GET /somedir/page.html HTTP/1.1
	Host: www.someschool.edu
	Connection: close
	User-agent: Mozilla/5.0
	Accept-language: fr
	```
- **Host**: 객체가 존재하는 호스트를 지정한다. 이 정보는 web proxy caches에 필요하다.
- **Connection**: "close"는 클라이언트가 영구 연결을 원하지 않으며, 요청된 객체를 보낸 후 서버가 연결을 닫도록 요청하는 것임을 서버에게 알린다.
- **User-agent**: 서버에 요청을 보내는 클라이언트 유형이다. 서버가 동일한 객체의 다른 버전을 다른 유형의 클라이언트에게 보낼때 유용하다.
- **Accept-language**: 사용자가 선호하는 버전의 객체다. 서버에 해당 객체가 없으면 기본 버전을 보내야 한다.
	
- header line 뒤에는 빈 줄과 entity body가 있을 수 있다.
	![[http_request_message.png]]
## HTTP 응답 메시지
- 일반적으로 status line, 여러 header line, entity body로 구성된다.
- 첫번째 줄인 **status line**은 **프로토콜 버전**(HTTP/1.1), **HTTP Status**(200), **해당 상태 메시지**(OK)로 구성된다.
- header line 예시:
	```
		HTTP/1.1 200 OK
		Connection: close
		Date: Tue, 18 Aug 2015 15:44:04 GMT
		Server: Apache/2.2.3 (CentOS)
		Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
		Content-Length: 6821
		Content-Type: text/html
		(data data data data data ...)
	```
- **Connection**: "close"값은 서버가 메시지를 보낸 후 TCP 연결을 닫을 것임을 클라이언트에 알린다.
- **Date**: 응답이 서버에 의해 생성 및 전송된 시간과 날짜를 나타낸다.
- **Server**: 응답이 생성된 서버 유형을 나타낸다.
- **Last-Modified**: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다. 객체 캐싱에 중요하다.
- **Content-Length**: 객체의 바이트 수를 나타낸다.
- **Content-Type**: 객체의 타입을 나타낸다.

![[http_response_message.png]]

> [!NOTE]
    > HTTP header line은 브라우저, 웹 서버, 네트워크 캐시 서버 등에 의해서 더 많이 추가될 수 있다.

## Cookies
쿠키 기술은 4가지 구성 요소로 이루어져 있다:
1. HTTP 응답 메시지의 **Set-Cookie** 헤더 라인
2. HTTP 요청 메시지의 **Cookie** 헤더라인
3. 클라이언트에 의해 관리되는 사용자 엔드 시스템에 보관된 쿠키 파일
4. 웹사이트의 백엔드 데이터베이스
### 쿠키 작동 방식 예시
1. 사용자가 특정 웹사이트를 처음 방문하여 사용자 ID를 제공한다
2. 이 웹사이트의 서버는 데이터베이스에 사용자의 ID와 함께 임의로 생성된 식별 번호를 저장한다.
3. 이 식별 번호는 HTTP 응답 메시지의 Set-cookie 헤더에 포함되어 클라이언트로 전송된다.
4. 클라이언트는 Set-cookie 헤더를 수신하면 식별 번호와 웹사이트의 호스트 이름을 쿠키 파일에 추가한다.
5. 이후 사용자가 동일한 웹사이트에 방문할때마다 클라이언트는 쿠키 파일에서 웹사이트의 호스트 이름을 검색하고, 해당 호스트 이름의 식별 번호를 HTTP 요청 메시지의 Cookie 헤더에 포함하여 서버로 전송한다.
6. 서버는 이 Cookie 헤더를 수신하면 데이터베이스에서 식별 번호를 확인하여 사용자를 식별한다.
### 쿠키의 활용
- 쿠키는 **stateless HTTP 위에 사용자 세션 계층을 생성**하는데 사용될 수 있다.
- 브라우저는 서버에 쿠키 정보를 보내 서버가 사용자 세션 내내 사용자를 식별할 수 있도록 한다.

## Web Caching
- 웹 캐시는 **프록시 서버**라고도 불리며, 원본 서버를 대신하여 HTTP 요청을 처리한다.
- 웹 캐시는 자체 디스크 저장 공간을 가지고 있으며, 최근 요청된 객체들의 복사본을 보관한다.
- 클라이언트는 모든 HTTP 요청이 먼저 웹 캐시로 향하도록 할 수 있다.
### Web Cache 작동 예시
1. 클라이언트가 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 복사본이 있는지 확인한다. 복사본이 있다면, 웹 캐시는 HTTP 응답 메시지에 복사본을 넣어 클라이언트로 보낸다.
3. 복사본이 없다면, 웹 캐시는 원본 서버와 TCP 연결을 열고 객체에 대한 HTTP 요청을 cashe-to-server TCP 연결로 보낸다. 서버가 요청을 받으면 객체를 HTTP 응답에 포함하여 웹 캐시로 보낸다.
4. 웹 캐시가 객체를 받으면, 로컬 스토리지에 복사본을 저장하고 HTTP 응답 메시지에 그 복사본을 넣어 1번의 TCP 연결을 통해 클라이언트로 보낸다.
### Web Cache 장점
- 클라이언트 요청에 대한 응답 시간 감소
	- 요청된 객체가 캐시의 가까운 위치에 저장되어 있어, 캐시에서 응답하는게 원본 서버에서 응답하는 것보다 훨씬 빠르다.
- 액세스 링크 트래픽 감소
	- 캐시가 원본 서버 대신 응답하면, 액세스 링크의 트래픽을 감소시켜 액세스 링크 대역폭을 업그레이드할 비용을 줄인다.
	- 전체 인터넷 트래픽을 감소시켜 모든 애플리케이션의 성능을 향상시킨다.
- CDN(Content Distribution Networks)을 통해 웹 캐시는 인터넷에서 매우 중요한 역할을 한다.
### 조건부 GET
- 웹 캐시가 최신 객체를 보유하고 있는지 확인하기 위해 조건부 GET 요청을 사용한다.
- 조건부 GET 요청은 HTTP 요청 메시지에 **If-Modified-Since** 헤더를 추가한다.
- 이 헤더에는 캐시가 객체의 복사본을 마지막으로 수정한 날짜가 포함된다.
	```
	GET /fruit/kiwi.gif HTTP/1.1
	Host: www.exotiquecuisine.com
	If-modified-since: Wed, 9 Sep 2015 09:23:24
	```
- 웹 서버는 조건부 GET 요청을 받으면, 요청된 객체가 If-Modified-Since 헤더에 명시된 날짜 이후로 수정되지 않았다면 HTTP 응답 메시지에 객체를 포함하지 않고 **304 Not Modified** 응답을 보낸다.
	```
	HTTP/1.1 304 Not Modified
	Date: Sat, 10 Oct 2015 15:39:29
	Server: Apache/1.3.0 (Unix)
	(empty entity body)
	```
- 304 Not Modified는 웹 캐시에 캐시된 오브젝트 복사본을 클라이언트에 전달할 수 있다고 알려준다.
- 웹 캐시가 304 응답을 받으면, 로컬에 저장된 객체를 클라이언트로 보낸다.
- 객체가 수정된 경우, 서버는 200 OK 응답과 함께 수정된 객체를 보낸다.
## HTTP/2
- HTTP/2는 단일 TCP 연결의 요청 및 응답 multiplexing을 통해 HOL blocking을 피하여 사용자의 인식 지연을 감소시킨다.
- 요청 우선순위 지정, 서버 푸쉬, 효율적인 HTTP 헤더 압축을 제공한다.
- HTTP/1.1의 HTTP 메서드, 상태 코드, URL, 헤더 필드를 그대로 사용하는 대신, 클라이언트와 서버 간 데이터 포맷팅과 데이터 변환 방법이 다르다. 
- HTTP/1.1은 HOL을 해결하기 위해 여러 개의 TCP 연결을 연다. 이 경우 TCP 혼잡 제어는  N개의 TCP 연결이 있다면, 각 TCP 연결에 링크의 대역폭을 1/N만큼 할당한다.
- HTTP/2는 오직 하나의 TCP 연결만 사용하여 서버의 socket 수를 줄이고, TCP 혼잡제어가 의도대로 작동하도록 한다.
### HTTP/2 Framing
- HTTP/2는 HOL blocking을 피하기 위해 메시지를 작은 프레임으로 쪼개고, 동일한 TCP 연결에 **번갈아 배치(interleave)** 시킨다. 그리고 목적지에서 쪼개진 프레임들을 재조립한다.
	- 예를 들어, 웹 페이지가 1000프레임짜리 비디오와 2프레임짜리 객체 8개로 이뤄지고, 모든 프레임들의 길이가 고정되있을때, 첫번째 비디오 프레임을 보낸 후, 각 객체의 첫번째 프레임을 보낸다. 그러므로 18 프레임을 보낸 후에야 2프레임짜리 객체들을 받을 수 있다.
- 응답 메시지의 헤더는 하나의 프레임이 되고, body는 하나의 프레임으로 분해되어 더 많은 추가 프레임이 생성된다.
- **프레임 하위 계층**에 의해 다른 응답의 프레임들과 **교차 배치**되어 단일 지속 TCP 연결을 통해 전송된다.
- 프레임이 클라이언트에 도착하면 프레임 하위 계층에서 원래 응답 메시지로 재구성된다.
- 클라이언트의 요청 메시지도 프레임으로 분해되어 교차 배치된다.
- 프레임 하위 계층은 프레임일 **binary 인코딩**한다.
- binary 프로토콜은 구문 분석이 더 효율적이고 프레임이 약간 작으며 오류 발생 가능성이 적다.
### 응답 메시지 의존성, 우선순위 설정
- 프레이밍 하위 계층은 메시지를 동일한 요청자에게 전달되는 **병렬 데이터 스트림**으로 구성한다.
- 클라이언트는 **특정 스트림(요청)이 다른 스트림에 의존한다고 명시**할 수 있다. 예를 들어, HTML 파일이 먼저 처리되어야 CSS나 JavaScript를 파싱할 수 있으므로, CSS와 JS 요청을 HTML 요청에 의존하도록 설정할 수 있다. 이렇게 하면 부모 스트림(HTML)이 완료되기 전까지 자식 스트림(CSS, JS)의 처리가 보류된다.
- 클라이언트가 서버에 동시에 요청을 보낼 때, 각 메시지에 **1에서 256 사이의 가중치**를 할당하여 응답 우선순위를 정할 수 있다. 숫자가 높을수록 우선순위가 높다. **서버는 가중치가 높은 요청에 더 많은 리소스를 할당**하여 더 빨리 완료될 수 있도록 한다.
### 서버 푸시
- 서버가 단일 클라이언트 요청에 대해 여러 응답을 보낼 수 있다. 즉, 서버는 원래 요청에 대한 응답 외에 클라이언트가 각 응답을 요청할 필요 없이 추가 개체를 클라이언트에 푸시할 수 있다.
- HTML에 웹 페이지를 완전히 렌더링하는데 필요한 객체가 표시되어 있기 때문에, 서버는 명시적인 요청을 받기 전에, HTML을 분석하여 필요한 객체를 식별하고 클라이언트에게 보낼 수 있다.
## HTTP/3
- QUIC는 UDP 프로토콜 기반의 애플리케이션 계층의 전송 프로토콜이다.
- QUIC는 메시지 다중화(interleaving), 스트림별 흐름제어, 저지연 연결 설정 등 HTTP에 적합한 여러 기능을 갖고 있다.
- HTTP/3는 QUIC를 통해 작동한다.
