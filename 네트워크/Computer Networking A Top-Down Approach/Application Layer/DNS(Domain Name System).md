인터넷 호스트는 호스트 이름(hostname)과 IP 주소라는 두 가지 식별자를 가진다. 사람들은 기억하기 쉬운 호스트 이름을 선호하지만, 라우터는 계층 구조를 가진 고정 길이의 IP 주소를 선호한다. 이 두 가지 선호도를 조화시키기 위해 호스트 이름을 IP 주소로 변환하는 디렉터리 서비스가 필요한데, 이것이 바로 인터넷의 **도메인 이름 시스템(Domain Name System, DNS)** 의 주요 임무다.
# DNS에 의해 제공되는 서비스
## Hostname-IP 주소 변환
DNS는 계층 구조의 DNS 서버로 구현된 분산 데이터베이스이자, **호스트가 이 분산 데이터베이스를 쿼리할 수 있게 하는 애플리케이션 계층 프로토콜**이다. 
DNS 서버는 주로 BIND(Berkeley Internet Name Domain) 소프트웨어를 실행하는 UNIX 컴퓨터이며, DNS 프로토콜은 UDP를 통해 53번 포트를 사용한다.
HTTP나 SMTP와 같은 다른 애플리케이션 계층 프로토콜은 사용자가 제공한 호스트 이름을 IP 주소로 변환하기 위해 DNS를 사용한다.
사용자가 브라우저에서 `www.someschool.edu/index.html`이라는 URL을 요청하면 다음과 같은 과정이 일어난다:
1. 사용자 컴퓨터에서 DNS 애플리케이션의 클라이언트 측이 실행된다.
2. 브라우저는 URL에서 호스트 이름(`www.someschool.edu`)을 추출하여 DNS 클라이언트에 전달한다.
3. DNS 클라이언트는 해당 호스트 이름을 포함하는 쿼리를 DNS 서버로 전송한다.
4. DNS 클라이언트는 호스트 이름에 해당하는 IP 주소가 포함된 응답을 받는다.
5. 브라우저는 DNS로부터 IP 주소를 받은 후, 해당 IP 주소의 80번 포트에서 실행 중인 HTTP 서버 프로세스와 TCP 연결을 시작할 수 있다.
이 과정에서 DNS는 추가적인 지연을 발생시킬 수 있지만, 일반적으로 원하는 IP 주소는 근처 DNS 서버에 캐시되어 있어 평균 DNS 지연과 네트워크 트래픽을 줄일 수 있다.
## Host Aliasing
복잡한 호스트 이름을 가진 호스트는 하나 이상의 별칭(alias name)을 가질 수 있다. 예를 들어, `relay1.west-coast.enterprise.com`이라는 정식 호스트 이름(canonical hostname)은 `enterprise.com`이나 `www.enterprise.com`과 같은 별칭을 가질 수 있다.
DNS는 별칭에 대한 정식 호스트 이름과 IP 주소를 제공할 수 있다.
## Mail Server Aliasing
이메일 주소를 기억하기 쉽게 만들기 위해 사용된다. 예를 들어, `bob@yahoo.com`과 같은 간단한 주소를 사용할 수 있지만 실제 메일 서버의 호스트 이름은 훨씬 복잡할 수 있다. DNS는 메일 애플리케이션이 제공된 별칭에 대한 정식 호스트 이름과 IP 주소를 얻을 수 있도록 한다. **MX 레코드**를 사용하면 회사의 메일 서버와 웹 서버가 `enterprise.com`처럼 동일한 별칭 호스트 이름을 가질 수 있다.
## 부하 분산(Load Distribution)
DNS는 `cnn.com`과 같이 트래픽이 많은 사이트들을 위해 여러 복제된 서버 간에 부하를 분산시키는 데 사용된다. **복제된 웹 서버의 경우, 하나의 별칭 호스트 이름에 여러 IP 주소가 연결**된다. 
DNS 데이터베이스는 이 IP 주소 집합을 저장하고, 클라이언트가 DNS 쿼리를 하면 서버는 매번 주소의 순서를 바꿔서 응답한다. 
클라이언트는 보통 목록의 첫 번째 IP 주소로 HTTP 요청을 보내기 때문에, DNS 순환(rotation) 방식은 트래픽을 여러 서버로 분산시킬 수 있다. Akamai와 같은 콘텐츠 전송 회사들은 웹 콘텐츠 분산을 위해 DNS를 더 정교한 방식으로 사용한다(자세한 내용은 chapter 2.6.3 참조)
# DNS 동작 방식
사용자 호스트의 애플리케이션이 호스트 이름을 IP 주소로 변환해야 할 때, DNS의 클라이언트 측을 호출한다. 그러면 사용자 호스트의 DNS는 쿼리 메시지를 네트워크로 보내고, 모든 DNS 쿼리 및 응답 메시지는 UDP 데이터그램을 통해 53번 포트로 전송된다. 잠시 후, 사용자 호스트의 DNS는 원하는 매핑 정보가 담긴 DNS 응답 메시지를 수신하여 호출한 애플리케이션에 전달한다. 이처럼 애플리케이션 관점에서는 DNS가 간단한 변환 서비스를 제공하는 블랙박스처럼 보이지만, 실제로는 전 세계에 분산된 수많은 DNS 서버와 이들 간의 통신을 규정하는 애플리케이션 계층 프로토콜로 구성된 복잡한 시스템이다.
# 분산/계층형 데이터베이스
DNS를 단일 서버로 구성하면 다음과 같은 문제가 발생한다:
- **단일 장애 지점**: DNS 서버가 다운되면 인터넷 전체가 마비될 수 있다.
- **트래픽 양**: 단일 서버가 수억 개의 호스트에서 발생하는 모든 DNS 쿼리를 처리해야 한다.
- **클라이언트와 물리적으로 먼 거리로 인한 지연**: 단일 서버는 모든 클라이언트와 물리적으로 가까울 수 없어 상당한 지연을 유발할 수 있다.
- **유지보수성 저하**: 모든 인터넷 호스트의 기록을 유지하고 자주 업데이트해야 하므로 데이터베이스가 거대해진다.
이러한 확장성 문제를 해결하기 위해 **DNS는 수많은 서버를 계층적으로 구성하고 전 세계에 분산**시키는 방식을 사용한다. 어떤 단일 DNS 서버도 인터넷의 모든 호스트에 대한 매핑 정보를 가지고 있지 않으며, 이 매핑 정보는 여러 DNS 서버에 분산되어 있다.
## DNS 서버 계층
- **루트 DNS 서버**: 전 세계에 1000개 이상의 인스턴스가 있으며, 13개의 다른 루트 서버의 복사본으로 12개 기관이 관리한다. 이 서버들은 TLD 서버의 IP 주소를 제공한다.
- **최상위 도메인(Top-Level Domain, TLD) DNS 서버**: `.com`, `.org`, `.net`과 같은 일반 최상위 도메인과 `.uk`, `.fr`과 같은 모든 국가 최상위 도메인에 대해 TLD 서버가 존재한다. 이들은 권한 DNS 서버의 IP 주소를 제공한다.
- **권한 DNS 서버(Authoritative DNS server)**: 인터넷에 공개적으로 접근 가능한 호스트(웹 서버, 메일 서버 등)를 가진 모든 조직은 해당 호스트의 이름을 IP 주소로 매핑하는 DNS 레코드를 제공해야 한다. 조직의 권한 DNS 서버가 이 레코드를 관리한다. 대부분의 대학과 대기업은 자체 권한 DNS 서버를 운영하고 유지한다.
- 로컬 DNS 서버: 계층에 속하지는 않지만 DNS 아키텍처의 중심 역할을 한다. 각 ISP는 로컬 DNS 서버를 가지며, 호스트가 ISP에 연결될 때 이 서버의 IP 주소를 제공받는다. 호스트가 DNS 쿼리를 하면, 이 쿼리는 로컬 DNS 서버로 전송되고, **로컬 DNS 서버는 프록시 역할을 하여 DNS 계층으로 쿼리를 전달**한다.
## DNS 서버들의 상호 작용
![[img/dns_server_query.png | 400]]
1. `cse.nyu.edu` 호스트가 `gaia.cs.umass.edu`의 IP 주소를 알고 싶어 하면, 먼저 로컬 DNS 서버인 `dns.nyu.edu`에 쿼리를 보낸다.
2. 로컬 DNS 서버는 이 쿼리를 루트 DNS 서버로 전달한다.
3. 루트 서버는 `.edu` TLD 서버 목록을 반환한다.
4. 로컬 DNS 서버는 이 TLD 서버 중 하나에 다시 쿼리한다.
5. TLD 서버는 `umass.edu`에 대한 권한 DNS 서버인 `dns.umass.edu`의 IP 주소를 응답한다.
6. 로컬 DNS 서버는 `dns.umass.edu`에 직접 쿼리를 보내 `gaia.cs.umass.edu`의 IP 주소를 받아 요청한 호스트에 전달한다.

이 예시는 **재귀적 쿼리(recursive query)** 와 **반복적 쿼리(iterative query)** 를 모두 사용한다. 1,8번이 재귀적 쿼리이며, 이후의 세 쿼리는 반복적 쿼리다. 
실제로는 요청 호스트에서 로컬 DNS 서버로의 쿼리는 재귀적이고, 나머지 쿼리들은 반복적으로 이루어지는 패턴이 일반적이다. 

다음은 모든 쿼리가 재귀적인 경우의 연쇄 과정이다:
![[dns_recursive_query.png | 400]]
# DNS Caching
DNS는 지연 성능을 개선하고 인터넷의 DNS 메시지 수를 줄이기 위해 **DNS 캐싱**을 광범위하게 활용한다. 
DNS 서버가 DNS 응답을 받으면 그 매핑 정보를 **로컬 메모리에 캐시**할 수 있다. 예를 들어, 로컬 DNS 서버 `dns.nyu.edu`는 응답을 받을 때마다 정보를 캐시할 수 있다. 만약 캐시된 호스트 이름에 대한 다른 쿼리가 도착하면, 로컬 DNS 서버는 권한이 없더라도 캐시된 IP 주소를 즉시 제공할 수 있다.
호스트와 매핑 정보는 영구적이지 않으므로, DNS 서버는 일정 시간(보통 이틀)이 지나면 캐시된 정보를 폐기한다.
캐싱 덕분에 루트 서버는 극히 일부의 DNS 쿼리를 제외하고는 대부분 거치지 않는다.
# DNS 레코드
DNS 분산 데이터베이스를 구현하는 DNS 서버들은 호스트 이름과 IP 주소 간의 매핑을 제공하는 **리소스 레코드(Resource Records, RR)** 를 저장한다. 각 DNS 응답 메시지는 하나 이상의 리소스 레코드를 담고 있다.

리소스 레코드는 `(Name, Value, Type, TTL)`의 네 가지 필드로 구성된 튜플이다.
- **TTL**: 리소스 레코드의 유효 기간으로, 캐시에서 언제 제거되어야 하는지를 결정한다.
- **Name, Value**: 이 필드들의 의미는 `Type`에 따라 달라진다.
    - **Type=A**: `Name`은 호스트 이름이고 `Value`는 해당 호스트의 IP 주소다. 이는 표준적인 호스트 이름-IP 주소 매핑을 제공한다.
	    - e.g. `(relay1.bar.foo.com, 145.37.93.126, A)`
    - **Type=NS**: `Name`은 도메인(예: `foo.com`)이고 `Value`는 해당 도메인 내 호스트들의 IP 주소를 얻는 방법을 아는 권한 DNS 서버의 호스트 이름이다. 이 레코드는 DNS 쿼리를 계층의 다음 단계로 전달하는 데 사용된다.
        - e.g. `(foo.com, dns.foo.com, NS)`
    - **Type=CNAME**: `Value`는 별칭 호스트 이름인 `Name`에 대한 정식 호스트 이름(canonical hostname)이다.
        - e.g. `(foo.com, relay1.bar.foo.com, CNAME)`
    - **Type=MX**: `Value`는 별칭 호스트 이름 `Name`을 가진 메일 서버의 정식 이름이다. MX 레코드를 사용하면 회사의 메일 서버와 웹 서버가 동일한 별칭 이름을 가질 수 있다. 메일 서버의 정식 이름을 얻으려면 MX 레코드를, 다른 서버의 정식 이름을 얻으려면 CNAME 레코드를 쿼리해야 한다.
        - e.g. `(foo.com, mail.bar.foo.com, MX)`

만약 DNS 서버가 특정 호스트 이름에 대한 권한을 가지고 있다면, 해당 호스트 이름에 대한 **Type A** 레코드를 포함한다. 권한이 없는 서버라도 캐시에 Type A 레코드를 가질 수 있다. 권한이 없는 서버는 해당 호스트 이름을 포함하는 도메인에 대한 **Type NS** 레코드를 가지며, 이 NS 레코드의 `Value` 필드에 있는 DNS 서버의 IP 주소를 제공하는 Type A 레코드도 함께 가진다.
# DNS 메시지
DNS 메시지에는 **쿼리 메시지**와 **응답 메시지** 두 종류만 있으며, 두 메시지는 동일한 형식을 가진다.
![[dns_message_format.png | 600]]
- **헤더 섹션(Header Section)**: 처음 12바이트로, 쿼리를 식별하는 16비트 **식별자(Identification)** 필드와 여러 플래그 필드가 있다. 쿼리/응답 플래그는 메시지가 쿼리인지 응답인지를 나타내고, 권한 플래그는 DNS 서버가 쿼리된 이름에 대한 권한 서버임을 나타낸다. 헤더에는 또한 질문, 응답, 권한, 추가 정보 섹션의 레코드 수를 나타내는 필드들이 있다.
- **질문 섹션(Question Section)**: 쿼리 중인 이름과 질문의 유형(예: Type A 또는 Type MX)이 있다.
- **응답 섹션(Answer Section)**: 쿼리된 이름에 대한 리소스 레코드가 있다. 하나의 호스트 이름이 여러 IP 주소를 가질 수 있으므로, 응답은 여러 RR을 포함할 수 있다.
- **권한 섹션(Authority Section)**: 다른 권한 서버의 레코드가 있다.
- **추가 정보 섹션(Additional Section)**: 도움이 될 만한 추가 레코드가 있다. 예를 들어, MX 쿼리에 대한 응답에는 메일 서버의 정식 호스트 이름에 대한 Type A 레코드가 포함될 수 있다.

> [!tip]
    > `nslookup` 프로그램을 사용하면 사용자가 직접 DNS 쿼리 메시지를 보내고 응답 메시지를 확인할 수 있다.

# DNS 데이터베이스에 레코드 삽입
DNS 데이터베이스에 레코드를 삽입하려면, 먼저 **등록기관(registrar)** 에 도메인 이름을 등록해야 한다. 등록기관은 도메인 이름의 고유성을 확인하고 DNS 데이터베이스에 이름을 입력하며 수수료를 받는다. ICANN(Internet Corporation for Assigned Names and Numbers)이 다양한 등록기관을 인증한다.
도메인 이름을 등록할 때, 주 DNS 서버와 보조 DNS 서버의 이름 및 IP 주소를 등록기관에 제공해야 한다. 예를 들어, `networkutopia.com`을 등록하고 주 DNS 서버가 `dns1.networkutopia.com`(IP: `212.212.212.1`)이라면, 등록기관은 TLD `.com` 서버에 다음 두 개의 리소스 레코드를 삽입한다:
- `(networkutopia.com, dns1.networkutopia.com, NS)`
- `(dns1.networkutopia.com, 212.212.212.1, A)`

또한, 자신의 권한 DNS 서버에 웹 서버(`www.networkutopia.com`)에 대한 Type A 레코드와 메일 서버(`mail.networkutopia.com`)에 대한 Type MX 레코드를 입력해야 한다. 이 모든 절차가 완료되면 전 세계 사용자가 내 웹사이트를 방문하고 이메일을 보낼 수 있게 된다.