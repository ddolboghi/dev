# 라우터 구성 요소
![[router_architecture.png]]
### 입력 포트(Input port)
- 라우터로 들어오는 물리적 링크를 종단하는 물리 계층 기능을 수행한다.
- 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하는 데 필요한 링크 게층 기능도 처리한다.
- 도착한 패킷이 스위칭 구조를 통해 **전달될 출력 포트를 결정하는 조회**(lookup) 기능을 수행한다.
- 제어 패킷(e.g. 라우팅 프로토콜 정보)은 입력 포트에서 라우팅 프로세서로 전달된다.
### 스위칭 구조(Switching fabric)
- 입력 포트와 출력 포트를 연결한다.
- 라우터의 성능을 결정하는 핵심 요소다.
### 출력 포트(Output port)
- 스위칭 구조로부터 받은 패킷을 저장한 후, 이를 출력 링크로 전송하는 데 필요한 링크 계층 및 물리 계층 기능을 수행한다.
- 입력 포트와 마찬가지로, 패킷을 전달하기 전에 조회 및 포워딩 기능을 수행해야 할 수 있다.
### 라우팅 프로세서(Routing processor)
- 제어 평면 기능을 실행한다.
- 전통적인 라우터에서는 라우팅 프로토콜(e.g. OSPF, BGP)을 실행하고, 포워딩 테이블을 유지하며, 라우터의 흐름 제어 및 관리한다.
- SDN 라우터에서는 라우팅 프로세서가 원격 컨트롤러와 통신하여 컨트롤러가 계산한 포워딩 테이블을 수신하고, 이를 라우터의 입력 포트에 설치한다.
# 라우터 기능 구분
### 데이터 평면(Data Plane)
- 데이터그램을 입력 포트에서 출력 포트로 전달(포워딩)
- 나노초 단위의 매우 짧은 시간 내에 처리되어야 하므로 주로 하드웨어에 구현
- 라우터의 포워딩 평면(forwarding plane)이라고도 한다.
- 입력 및 출력 포트 기능은 데이터 평면의 일부다.
### 제어 평면(Control Plane)
- 네트워크 전체에 걸쳐 데이터그램이 송신지에서 목적지까지 어떻게 라우팅될지 결정
- 라우팅 프로토콜을 통해 이뤄진다.
- 밀리초 또는 초 단위로 작동하며 주로 소프트웨어로 구현되어 라우팅 프로세서(CPU)에서 실행된다.
- 제어 평면의 접근 방식은 전통적인 라우터별 제어([[Network Layer의 개요#전통적인 접근 방식]])와 SDN([[Network Layer의 개요#SDN(Software-Defined Networking) 접근 방식]])이 있다.

포워딩 테이블은 라우팅 프로세서(제어 평면)에 의해 계산되거나 컨트롤러부터 수신된 후, 각 입력 포트(포워딩 평면)에 설치된다. 이러한 분리된 접근 방식 덕분에 라우터는 **패킷별로 제어 평면의 개입 없이** 매우 빠르게 패킷을 포워딩할 수 있다.

# 입력 포트 처리와 목적지 기반 포워딩
## 입력 포트의 기능
- **물리 계층 및 링크 계층 기능**: 입력 포트는 라우터로 들어오는 물리적 링크를 종단(line termination)하는 물리 계층 기능을 수행하고, 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하는 데 필요한 링크 계층 기능(프로토콜, 역캡슐화)도 처리한다.
- **조회(Lookup) 기능**: 라우터의 핵심 동작인 조회 기능이 입력 포트에서 수행된다. 여기서 포워딩 테이블을 참조하여 도착한 패킷이 스위칭 구조를 통해 어느 출력 포트로 전달될지 결정한다.(forwarding, queuing)
    - 포워딩 테이블은 라우팅 프로세서에서 각 라인 카드로 복사되어, 패킷별로 중앙 라우팅 프로세서를 호출하지 않고도 각 입력 포트에서 로컬로 포워딩 결정을 내릴 수 있게 한다. 이는 중앙 처리 병목 현상을 방지한다.
## 목적지 기반 포워딩 테이블의 구조
- 가장 간단한 경우, 패킷의 출력 포트는 패킷의 목적지 주소에 따라 결정된다.
- 32비트 IP 주소에 대해 모든 가능한 목적지 주소마다 항목을 갖는 포워딩 테이블을 만드는 것은 40억 개 이상의 항목이 필요하므로 현실적으로 불가능하다.
- **접두어 일치(Prefix Matching)**: 이러한 확장성 문제를 해결하기 위해 라우터는 패킷 목적지 주소의 **접두어**를 테이블 항목과 비교한다.
    - 예를 들어, 4개의 링크(0-3)를 가진 라우터가 특정 주소 범위에 따라 패킷을 포워딩해야 할 때, 전체 주소 대신 주소의 앞부분(접두어)만 사용하여 포워딩 테이블을 구성할 수 있다.
    - 만약 목적지 주소가 `11001000 00010111 00010110 10100001`이고, 테이블에 `11001000 00010111 00010`라는 21비트 접두어와 일치하는 항목이 있다면, 라우터는 해당 패킷을 그 항목과 연결된 링크 인터페이스로 포워딩한다.
- **최장 접두어 일치 규칙**: 하나의 목적지 주소가 포워딩 테이블의 여러 항목과 일치할 수 있다. 예를 들어, 특정 주소의 24비트 접두어가 한 항목과 일치하고, 21비트 접두어는 다른 항목과 일치할 수 있다. 이 경우, 테이블에서 **가장 길게 일치하는 항목을 찾아** 해당 항목과 연결된 링크 인터페이스로 패킷을 포워딩한다.
## 고속 조회를 위한 하드웨어 구현
기가비트 전송 속도에서는 포워딩 테이블 조회가 수 나노초 내에 이루어져야 하므로, 하드웨어에서의 구현이 필수적이다.
- **TCAMs (Ternary Content Addressable Memories)**: 실제로 TCAM이 조회에 자주 사용된다. TCAM에 32비트 IP 주소를 제시하면, 거의 일정한 시간 내에 해당 주소에 대한 포워딩 테이블 항목의 내용을 반환한다. 이를 통해 매우 빠른 조회가 가능하다.
## 매치 플러스 액션 (Match Plus Action) 추상화
입력 포트 처리 과정은 단순히 목적지 주소를 조회하고(매치) 패킷을 스위칭 구조로 보내는(액션)것 이상으로, 더 일반적인 **"매치 플러스 액션"** 추상화의 한 예시로 볼 수 있다.

이 추상화는 라우터뿐만 아니라 다양한 네트워크 장치에서 수행된다.
- **링크 계층 스위치**: 링크 계층 목적지 주소를 조회하고 프레임을 포워딩하는 것 외에 여러 액션을 수행할 수 있다.
- **방화벽**: 특정 기준(예: 출발지/목적지 IP 주소와 포트 번호 조합)과 일치하는 헤더를 가진 패킷을 차단(액션)한다.     
- **NAT (Network Address Translator)**: 특정 포트 번호와 일치하는 패킷의 포트 번호를 재작성한 후 포워딩(액션)한다.

이 "매치 플러스 액션" 추상화는 현대 네트워크 장치에서 매우 강력하고 널리 퍼져 있으며, 일반화된 포워딩 개념의 중심이다.

# 스위칭
스위칭 구조는 라우터의 핵심으로, 패킷을 입력 포트에서 출력 포트로 포워딩하는 역할을 한다.
## 메모리를 통한 스위칭
![[switching_memory.png]]
가장 간단하고 전통적인 컴퓨터 구조를 사용한 초기의 라우터에서 사용된 방식이다.
CPU(라우팅 프로세서)의 직접적인 제어 하에 입력 포트와 출력 포트 간의 스위칭이 이루어졌다.
- 패킷이 입력 포트에 도착하면, 라우팅 프로세서에 인터럽트를 발생시킨다.
- 패킷은 입력 포트에서 프로세서 메모리로 복사된다.
- 라우팅 프로세서는 헤더에서 목적지 주소를 추출하고, 포워딩 테이블에서 적절한 출력 포트를 조회한 뒤, 패킷을 해당 출력 포트의 버퍼로 복사한다.
- 이 방식에서는 메모리 대역폭이 스위칭 성능을 제한한다. 메모리가 초당 `B`개의 패킷을 쓰거나 읽을 수 있다면, 전체 포워딩 처리량은 `B/2` 미만이어야 한다. 
- 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기만 가능하므로 두 개의 패킷이 동시에 포워딩될 수 없다.
- 일부 최신 라우터도 메모리를 통한 스위칭을 사용하지만, 목적지 주소 조회 및 패킷 저장은 입력 라인 카드에서 직접 처리된다는 차이가 있다.
## 버스를 통한 스위칭
![[switching_bus.png]]
이 방식에서는 입력 포트가 라우팅 프로세서의 개입 없이 공유 버스를 통해 패킷을 직접 출력 포트로 전송한다.
- 입력 포트는 패킷에 스위치 내부 레이블(헤더)을 추가하여 패킷이 전달될 출력 포트를 표시한 후 버스로 전송한다.
- 모든 출력 포트가 패킷을 수신하지만, 레이블과 일치하는 포트만이 패킷을 유지한다.
- 한 번에 하나의 패킷만 버스를 통과할 수 있으므로, 여러 패킷이 동시에 도착하면 하나를 제외한 나머지는 대기해야 한다.
- 스위칭 속도는 버스 속도에 의해 제한된다. 이 방식은 소규모 로컬 및 기업 네트워크의 라우터에 종종 사용된다.
## 상호연결 네트워크를 통한 스위칭
![[switching_interconnection.png]]
단일 공유 버스의 대역폭 한계를 극복하기 위해 더 정교한 상호연결 네트워크가 사용된다.
- **크로스바 스위치(Crossbar Switch)**: `N`개의 입력 포트와 `N`개의 출력 포트를 연결하는 `2N`개의 버스로 구성된 상호연결 네트워크다.
    - 스위치 구조 컨트롤러가 교차점을 열고 닫음으로써 입력 버스와 출력 버스를 연결한다.
    - 예를 들어, 포트 A에서 Y로 가는 패킷과 포트 B에서 X로 가는 패킷은 서로 다른 입출력 버스를 사용하므로 동시에 포워딩될 수 있다.
    - 크로스바 스위치는 **non-blocking** 방식이다. 즉, 다른 패킷이 이미 해당 출력 포트로 전송되고 있지 않는 한, 패킷이 출력 포트에 도달하는 것을 막지 않는다.
    - 그러나 두 개의 다른 입력 포트에서 온 패킷이 동일한 출력 포트로 향하면, 하나는 입력단에서 대기해야 한다.

- 더 정교한 상호연결 네트워크는 다단계 스위칭 소자를 사용하여 여러 입력 포트의 패킷이 동일한 출력 포트로 동시에 진행할 수 있도록 한다. 
- 라우터의 스위칭 용량은 여러 스위칭 구조를 병렬로 운영하여 확장할 수도 있다.
# 출력 포트 처리
출력 포트는 스위칭 구조로부터 받은 패킷을 출력 포트의 메모리에 저장한 후, 이를 출력 링크로 전송한다. 이 과정은 다음과 같은 세부 기능을 포함한다.
- **패킷 선택 및 디큐잉(De-queuing)**: 전송할 패킷을 큐에서 선택하고 꺼내는 스케줄링 작업을 수행한다.
- **링크 계층 및 물리 계층 기능**: 선택된 패킷을 전송하기 위해 필요한 링크 계층 및 물리 계층 기능(프로토콜, 캡슐화)을 수행한다.
# Queuing이 발생하는 곳
- 패킷 큐는 입력 포트와 출력 포트 양쪽 모두에서 형성될 수 있다. 
- 큐잉의 위치와 정도는 트래픽 부하, 스위칭 구조의 상대적 속도, 그리고 회선 속도에 따라 달라진다. 
- 큐가 너무 커지면 라우터의 메모리가 소진되어 도착하는 패킷이 손실(drop)될 수 있다.
### 전송률이 입출력 회선 속도보다 N배 빠를 경우
- 스위칭 구조의 전송률($R_{switch}$)이 입출력 회선 속도($R_{line}$)보다 N배(여기서 N은 입력 및 출력 포트 수) 빠르다면, 입력 포트에서의 큐잉은 거의 발생하지 않는다.
- 최악의 경우, 즉 모든 N개의 입력 회선에서 패킷이 들어오고 모두 동일한 출력 포트로 향하더라도, 다음 패킷 그룹이 도착하기 전에 스위칭 구조를 통해 모두 처리할 수 있기 때문이다.
## 입력 큐잉 (Input Queuing)
스위칭 구조가 입력 회선 속도에 비해 충분히 빠르지 않다면, 패킷이 스위칭 구조를 통과하기 위해 대기하면서 입력 포트 큐잉이 발생할 수 있다.

- **회선 선두 차단 (Head-of-the-Line, HOL) 블로킹**: 입력 큐 방식 스위치에서 발생하는 중요한 현상이다(Figure 4.8 참조).
    
    - 두 개 이상의 입력 큐의 선두에 있는 패킷들이 동일한 출력 큐로 가려고 할 때, 하나를 제외한 나머지 패킷은 차단되어 대기해야 한다.
        
    - 이때, 차단된 패킷 뒤에 있는 다른 패킷들(다른 출력 포트로 갈 수 있음에도 불구하고)도 함께 대기하게 되는데, 이를 HOL 블로킹이라고 한다.
        
    - HOL 블로킹 때문에 입력 큐 방식 스위치는 입력 링크 용량의 58%만 도달해도 큐 길이가 무한정 길어질 수 있다(즉, 심각한 패킷 손실이 발생할 수 있다).
        

"출력 큐잉 (Output Queuing)" 스위칭 구조가 회선 속도보다 `N`배 빠르더라도 출력 포트에서는 큐잉이 발생할 수 있다.

- 만약 `N`개의 입력 포트로 들어온 패킷이 모두 동일한 출력 포트로 향한다면, 출력 링크가 한 패킷을 전송하는 시간 동안 `N`개의 새로운 패킷이 해당 출력 포트에 도착한다.
    
- 출력 포트는 한 번에 하나의 패킷만 전송할 수 있으므로, 도착한 `N`개의 패킷은 전송을 위해 큐에서 대기해야 한다(Figure 4.9 참조).
    
- 이 과정이 반복되면 큐의 패킷 수가 계속 증가하여 출력 포트의 메모리를 소진시키고 패킷 손실을 유발할 수 있다.
    
- **패킷 폐기 정책**: 버퍼가 가득 찼을 때 도착하는 패킷을 처리하는 정책에는 여러 가지가 있다.
    
    - **Drop-tail**: 도착하는 패킷을 그냥 버리는 정책이다.
        
    - **액티브 큐 관리 (Active Queue Management, AQM)**: 버퍼가 가득 차기 전에 미리 패킷을 버리거나 헤더를 표시하여 송신자에게 혼잡 신호를 보낸다. **Random Early Detection (RED)**, **PIE**, **CoDel** 등이 대표적인 AQM 알고리즘이다.
        
- 출력 포트 큐잉으로 인해, 출력 포트의 **패킷 스케줄러**는 큐에 있는 패킷 중 어느 것을 전송할지 선택해야 한다.
    

"버퍼는 얼마나 필요한가?" 라우터 포트에 얼마나 많은 버퍼링을 제공해야 하는지에 대한 질문은 생각보다 복잡하며, 네트워크 엣지의 송신자와 네트워크 코어 간의 미묘한 상호작용을 보여준다.

- **전통적인 규칙**: 오랫동안 사용된 경험 법칙은 버퍼 크기 `B`가 평균 왕복 시간(RTT)과 링크 용량(C)의 곱과 같아야 한다는 것이었다 (`B = RTT * C`).
    
- **새로운 연구**: 다수의 독립적인 TCP 흐름(`N`)이 링크를 통과할 때는 필요한 버퍼 크기가 `B = RTT * C / sqrt(N)`으로 줄어들 수 있다는 것이 밝혀졌다. 코어 네트워크에서는 `N`이 매우 크므로 필요한 버퍼 크기가 크게 감소할 수 있다.
    
- **버퍼블로트 (Bufferbloat)**: 버퍼가 많으면 패킷 손실률은 줄어들지만, 큐잉 지연이 길어질 수 있다. 특히, 엣지 라우터에서 소수의 흐름만 있을 때, 과도한 버퍼링은 지속적으로 높은 지연을 유발하는 **버퍼블로트** 현상을 일으킬 수 있다(Figure 4.10 참조). 이는 ACK 클록킹으로 인해 큐가 지속적으로 채워진 상태를 유지하기 때문이다. 따라서 버퍼링은 처리량과 지연 사이의 균형을 맞춰야 하는 양날의 검과 같다.