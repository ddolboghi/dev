# 라우터 구성 요소
![[router_architecture.png]]
### 입력 포트(Input port)
- 라우터로 들어오는 물리적 링크를 종단하는 물리 계층 기능을 수행한다.
- 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하는 데 필요한 링크 게층 기능도 처리한다.
- 도착한 패킷이 스위칭 구조를 통해 **전달될 출력 포트를 결정하는 조회**(lookup) 기능을 수행한다.
- 제어 패킷(e.g. 라우팅 프로토콜 정보)은 입력 포트에서 라우팅 프로세서로 전달된다.
### 스위칭 구조(Switching fabric)
- 입력 포트와 출력 포트를 연결한다.
- 라우터의 성능을 결정하는 핵심 요소다.
### 출력 포트(Output port)
- 스위칭 구조로부터 받은 패킷을 저장한 후, 이를 출력 링크로 전송하는 데 필요한 링크 계층 및 물리 계층 기능을 수행한다.
- 입력 포트와 마찬가지로, 패킷을 전달하기 전에 조회 및 포워딩 기능을 수행해야 할 수 있다.
### 라우팅 프로세서(Routing processor)
- 제어 평면 기능을 실행한다.
- 전통적인 라우터에서는 라우팅 프로토콜(e.g. OSPF, BGP)을 실행하고, 포워딩 테이블을 유지하며, 라우터의 흐름 제어 및 관리한다.
- SDN 라우터에서는 라우팅 프로세서가 원격 컨트롤러와 통신하여 컨트롤러가 계산한 포워딩 테이블을 수신하고, 이를 라우터의 입력 포트에 설치한다.
# 라우터 기능 구분
### 데이터 평면(Data Plane)
- 데이터그램을 입력 포트에서 출력 포트로 전달(포워딩)
- 나노초 단위의 매우 짧은 시간 내에 처리되어야 하므로 주로 하드웨어에 구현
- 라우터의 포워딩 평면(forwarding plane)이라고도 한다.
- 입력 및 출력 포트 기능은 데이터 평면의 일부다.
### 제어 평면(Control Plane)
- 네트워크 전체에 걸쳐 데이터그램이 송신지에서 목적지까지 어떻게 라우팅될지 결정
- 라우팅 프로토콜을 통해 이뤄진다.
- 밀리초 또는 초 단위로 작동하며 주로 소프트웨어로 구현되어 라우팅 프로세서(CPU)에서 실행된다.
- 제어 평면의 접근 방식은 전통적인 라우터별 제어([[Network Layer의 개요#전통적인 접근 방식]])와 SDN([[Network Layer의 개요#SDN(Software-Defined Networking) 접근 방식]])이 있다.

포워딩 테이블은 라우팅 프로세서(제어 평면)에 의해 계산되거나 컨트롤러부터 수신된 후, 각 입력 포트(포워딩 평면)에 설치된다. 이러한 분리된 접근 방식 덕분에 라우터는 **패킷별로 제어 평면의 개입 없이** 매우 빠르게 패킷을 포워딩할 수 있다.

# 입력 포트 처리와 목적지 기반 포워딩
## 입력 포트의 기능
- **물리 계층 및 링크 계층 기능**: 입력 포트는 라우터로 들어오는 물리적 링크를 종단(line termination)하는 물리 계층 기능을 수행하고, 들어오는 링크의 반대편에 있는 링크 계층과 상호 운용하는 데 필요한 링크 계층 기능(프로토콜, 역캡슐화)도 처리한다.
- **조회(Lookup) 기능**: 라우터의 핵심 동작인 조회 기능이 입력 포트에서 수행된다. 여기서 포워딩 테이블을 참조하여 도착한 패킷이 스위칭 구조를 통해 어느 출력 포트로 전달될지 결정한다.(forwarding, queuing)
    - 포워딩 테이블은 라우팅 프로세서에서 각 라인 카드로 복사되어, 패킷별로 중앙 라우팅 프로세서를 호출하지 않고도 각 입력 포트에서 로컬로 포워딩 결정을 내릴 수 있게 한다. 이는 중앙 처리 병목 현상을 방지한다.
## 목적지 기반 포워딩 테이블의 구조
- 가장 간단한 경우, 패킷의 출력 포트는 패킷의 목적지 주소에 따라 결정된다.
- 32비트 IP 주소에 대해 모든 가능한 목적지 주소마다 항목을 갖는 포워딩 테이블을 만드는 것은 40억 개 이상의 항목이 필요하므로 현실적으로 불가능하다.
- **접두어 일치(Prefix Matching)**: 이러한 확장성 문제를 해결하기 위해 라우터는 패킷 목적지 주소의 **접두어**를 테이블 항목과 비교한다.
    - 예를 들어, 4개의 링크(0-3)를 가진 라우터가 특정 주소 범위에 따라 패킷을 포워딩해야 할 때, 전체 주소 대신 주소의 앞부분(접두어)만 사용하여 포워딩 테이블을 구성할 수 있다.
    - 만약 목적지 주소가 `11001000 00010111 00010110 10100001`이고, 테이블에 `11001000 00010111 00010`라는 21비트 접두어와 일치하는 항목이 있다면, 라우터는 해당 패킷을 그 항목과 연결된 링크 인터페이스로 포워딩한다.
- **최장 접두어 일치 규칙**: 하나의 목적지 주소가 포워딩 테이블의 여러 항목과 일치할 수 있다. 예를 들어, 특정 주소의 24비트 접두어가 한 항목과 일치하고, 21비트 접두어는 다른 항목과 일치할 수 있다. 이 경우, 테이블에서 **가장 길게 일치하는 항목을 찾아** 해당 항목과 연결된 링크 인터페이스로 패킷을 포워딩한다.
## 고속 조회를 위한 하드웨어 구현
기가비트 전송 속도에서는 포워딩 테이블 조회가 수 나노초 내에 이루어져야 하므로, 하드웨어에서의 구현이 필수적이다.
- **TCAMs (Ternary Content Addressable Memories)**: 실제로 TCAM이 조회에 자주 사용된다. TCAM에 32비트 IP 주소를 제시하면, 거의 일정한 시간 내에 해당 주소에 대한 포워딩 테이블 항목의 내용을 반환한다. 이를 통해 매우 빠른 조회가 가능하다.
## 매치 플러스 액션 (Match Plus Action) 추상화
입력 포트 처리 과정은 단순히 목적지 주소를 조회하고(매치) 패킷을 스위칭 구조로 보내는(액션)것 이상으로, 더 일반적인 **"매치 플러스 액션"** 추상화의 한 예시로 볼 수 있다.

이 추상화는 라우터뿐만 아니라 다양한 네트워크 장치에서 수행된다.
- **링크 계층 스위치**: 링크 계층 목적지 주소를 조회하고 프레임을 포워딩하는 것 외에 여러 액션을 수행할 수 있다.
- **방화벽**: 특정 기준(예: 출발지/목적지 IP 주소와 포트 번호 조합)과 일치하는 헤더를 가진 패킷을 차단(액션)한다.     
- **NAT (Network Address Translator)**: 특정 포트 번호와 일치하는 패킷의 포트 번호를 재작성한 후 포워딩(액션)한다.

이 "매치 플러스 액션" 추상화는 현대 네트워크 장치에서 매우 강력하고 널리 퍼져 있으며, 일반화된 포워딩 개념의 중심이다.

# 스위칭
스위칭 구조는 라우터의 핵심으로, 패킷을 입력 포트에서 출력 포트로 포워딩하는 역할을 한다.
## 메모리를 통한 스위칭
![[switching_memory.png]]
가장 간단하고 전통적인 컴퓨터 구조를 사용한 초기의 라우터에서 사용된 방식이다.
CPU(라우팅 프로세서)의 직접적인 제어 하에 입력 포트와 출력 포트 간의 스위칭이 이루어졌다.
- 패킷이 입력 포트에 도착하면, 라우팅 프로세서에 인터럽트를 발생시킨다.
- 패킷은 입력 포트에서 프로세서 메모리로 복사된다.
- 라우팅 프로세서는 헤더에서 목적지 주소를 추출하고, 포워딩 테이블에서 적절한 출력 포트를 조회한 뒤, 패킷을 해당 출력 포트의 버퍼로 복사한다.
- 이 방식에서는 메모리 대역폭이 스위칭 성능을 제한한다. 메모리가 초당 `B`개의 패킷을 쓰거나 읽을 수 있다면, 전체 포워딩 처리량은 `B/2` 미만이어야 한다. 
- 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기만 가능하므로 두 개의 패킷이 동시에 포워딩될 수 없다.
- 일부 최신 라우터도 메모리를 통한 스위칭을 사용하지만, 목적지 주소 조회 및 패킷 저장은 입력 라인 카드에서 직접 처리된다는 차이가 있다.
## 버스를 통한 스위칭
![[switching_bus.png]]
이 방식에서는 입력 포트가 라우팅 프로세서의 개입 없이 공유 버스를 통해 패킷을 직접 출력 포트로 전송한다.
- 입력 포트는 패킷에 스위치 내부 레이블(헤더)을 추가하여 패킷이 전달될 출력 포트를 표시한 후 버스로 전송한다.
- 모든 출력 포트가 패킷을 수신하지만, 레이블과 일치하는 포트만이 패킷을 유지한다.
- 한 번에 하나의 패킷만 버스를 통과할 수 있으므로, 여러 패킷이 동시에 도착하면 하나를 제외한 나머지는 대기해야 한다.
- 스위칭 속도는 버스 속도에 의해 제한된다. 이 방식은 소규모 로컬 및 기업 네트워크의 라우터에 종종 사용된다.
## 상호연결 네트워크를 통한 스위칭
![[switching_interconnection.png]]
단일 공유 버스의 대역폭 한계를 극복하기 위해 더 정교한 상호연결 네트워크가 사용된다.
- **크로스바 스위치(Crossbar Switch)**: `N`개의 입력 포트와 `N`개의 출력 포트를 연결하는 `2N`개의 버스로 구성된 상호연결 네트워크다.
    - 스위치 구조 컨트롤러가 교차점을 열고 닫음으로써 입력 버스와 출력 버스를 연결한다.
    - 예를 들어, 포트 A에서 Y로 가는 패킷과 포트 B에서 X로 가는 패킷은 서로 다른 입출력 버스를 사용하므로 동시에 포워딩될 수 있다.
    - 크로스바 스위치는 **non-blocking** 방식이다. 즉, 다른 패킷이 이미 해당 출력 포트로 전송되고 있지 않는 한, 패킷이 출력 포트에 도달하는 것을 막지 않는다.
    - 그러나 두 개의 다른 입력 포트에서 온 패킷이 동일한 출력 포트로 향하면, 하나는 입력단에서 대기해야 한다.

- 더 정교한 상호연결 네트워크는 다단계 스위칭 소자를 사용하여 여러 입력 포트의 패킷이 동일한 출력 포트로 동시에 진행할 수 있도록 한다. 
- 라우터의 스위칭 용량은 여러 스위칭 구조를 병렬로 운영하여 확장할 수도 있다.
# 출력 포트 처리
출력 포트는 스위칭 구조로부터 받은 패킷을 출력 포트의 메모리에 저장한 후, 이를 출력 링크로 전송한다. 이 과정은 다음과 같은 세부 기능을 포함한다.
- **패킷 선택 및 디큐잉(De-queuing)**: 전송할 패킷을 큐에서 선택하고 꺼내는 스케줄링 작업을 수행한다.
- **링크 계층 및 물리 계층 기능**: 선택된 패킷을 전송하기 위해 필요한 링크 계층 및 물리 계층 기능(프로토콜, 캡슐화)을 수행한다.
# Queuing이 발생하는 곳
- 패킷 큐는 입력 포트와 출력 포트 양쪽 모두에서 형성될 수 있다. 
- 큐잉의 위치와 정도는 트래픽 부하, 스위칭 구조의 상대적 속도, 그리고 회선 속도에 따라 달라진다. 
- 큐가 너무 커지면 라우터의 메모리가 소진되어 도착하는 패킷이 손실(drop)될 수 있다.
### 전송률이 입출력 회선 속도보다 빠를 경우
- 스위칭 구조의 전송률($R_{switch}$)이 입출력 회선 속도($R_{line}$)보다 N배(여기서 N은 입력 및 출력 포트 수) 빠르다면, 입력 포트에서의 큐잉은 거의 발생하지 않는다.
- 최악의 경우, 즉 모든 N개의 입력 회선에서 패킷이 들어오고 모두 동일한 출력 포트로 향하더라도, 다음 패킷 그룹이 도착하기 전에 스위칭 구조를 통해 모두 처리할 수 있기 때문이다.
## 입력 큐잉 (Input Queuing)
스위칭 구조가 입력 회선 속도에 비해 충분히 빠르지 않다면, 패킷이 스위칭 구조를 통과하기 위해 대기하면서 입력 포트 큐잉이 발생할 수 있다.
### **HOL(Head-of-the-Line) 블로킹**
- 두 개 이상의 입력 큐의 선두에 있는 패킷들이 동일한 출력 큐로 가려고 할 때, 하나를 제외한 나머지 패킷은 차단되어 대기해야 한다.
- 이때, 차단된 패킷 뒤에 있는 다른 패킷들(다른 출력 포트로 갈 수 있음에도 불구하고)도 함께 대기하게 되는데, 이를 HOL 블로킹이라고 한다.
- HOL 블로킹 때문에 입력 큐 방식 스위치는 입력 링크 용량의 58%만 도달해도 큐 길이가 무한정 길어져 심각한 패킷 손실이 발생할 수 있다.

## 출력 큐잉 (Output Queuing)
스위칭 구조가 회선 속도보다 `N`배 빠르더라도 출력 포트에서는 큐잉이 발생할 수 있다.
- 만약 `N`개의 입력 포트로 들어온 패킷이 모두 동일한 출력 포트로 향한다면, 출력 링크가 한 패킷을 전송하는 시간 동안 `N`개의 새로운 패킷이 해당 출력 포트에 도착한다.
- 출력 포트는 한 번에 하나의 패킷만 전송할 수 있으므로, 도착한 `N`개의 패킷은 전송을 위해 큐에서 대기해야 한다.
- 이 과정이 반복되면 큐의 패킷 수가 계속 증가하여 출력 포트의 메모리를 소진시키고 패킷 손실을 유발할 수 있다. 
- 출력 포트 큐잉으로 인해, 출력 포트의 **패킷 스케줄러**는 큐에 있는 패킷 중 어느 것을 전송할지 선택해야 한다.
### 패킷 폐기 정책
버퍼가 가득 찼을 때 도착하는 패킷을 처리하는 정책에는 여러 가지가 있다.
- **Drop-tail**: 도착하는 패킷을 그냥 버리는 정책이다.
- **AQM (Active Queue Management)**: 버퍼가 가득 차기 전에 미리 패킷을 버리거나 헤더를 표시하여 송신자에게 혼잡 신호를 보낸다. **Random Early Detection (RED)**, **PIE**, **CoDel** 등이 대표적인 AQM 알고리즘이다.
## 적절한 버퍼 크기는?
- 전통적인 규칙: 버퍼 크기 `B`가 평균 왕복 시간(RTT)과 링크 용량(C)의 곱과 같다.(`B = RTT * C`)
- 새로운 연구: 다수의 독립적인 TCP 흐름(`N`)이 링크를 통과할 때는 필요한 버퍼 크기가 `B = RTT * C / sqrt(N)`으로 줄어들 수 있다는 것이 밝혀졌다. 코어 네트워크에서는 `N`이 매우 크므로 필요한 버퍼 크기가 크게 감소할 수 있다.
- **버퍼블로트 (Bufferbloat)**: 버퍼 크기가 크면 패킷 손실률은 줄어들지만, 큐잉 지연이 길어질 수 있다. 버퍼 크기가 크면 버퍼가 차는데 걸리는 시간이 늘어나고, 그동안 송신측 slow-start 알고리즘은 패킷의 drop이 감지되지 않았으므로 송신속도를 점점 높여간다. 그러다가 버퍼가 꽉 찼을 때 tail drop 알고리즘에 의해 버퍼 안에 있는 패킷을 제외한 전송된 패킷들은 모두 폐기(drop) 된다. 이를 인지한 송신 측은 송신 속도를 줄여 전송 지연이 발생한다. 또한 이미 버퍼에 들어간 패킷들은 처리될 때까지 기다리면서 큐잉 지연이 발생한다. 이 때문에 사용자 입장에서는 인터넷의 속도가 빨라졌다가 어느 순간 급격히 느려지는 것이 반복되는 현상이 나타난다.
# 패킷 스케줄링
큐에 대기 중인 패킷들이 어떤 순서로 출력 링크를 통해 전송되는지를 결정하는 다양한 큐잉 원칙들이 있다.
## 선입선출 (First-in-First-Out, FIFO)
출력 링크 큐에 도착한 순서대로 패킷을 전송한다.
- **동작 방식**: 링크가 다른 패킷을 전송 중이면 도착한 패킷은 큐에서 대기한다. 버퍼 공간이 부족하면 패킷 폐기 정책에 따라 패킷이 버려지거나 다른 패킷이 제거된다. 패킷 전송이 완료되면 큐에서 제거된다.

## 우선순위 큐잉 (Priority Queuing)
출력 링크에 도착하는 패킷들이 큐에 도착할 때 우선순위 클래스로 분류된다.
![[priority_queuing_model.png]]
- **동작 방식**: 각 우선순위 클래스는 보통 자신만의 큐를 가진다. 전송할 패킷을 선택할 때, 우선순위 큐잉 원칙은 비어있지 않은 큐 중에서 가장 높은 우선순위 클래스의 패킷을 전송한다. 동일한 우선순위 클래스 내의 패킷들 간의 선택은 보통 FIFO 방식으로 이루어진다.
- **비선점 우선순위 큐잉(Non-preemptive priority queuing)**: 일단 패킷 전송이 시작되면 중단되지 않는다. 따라서 우선순위가 높은 패킷(4)이 우선순위가 낮은 패킷(2)의 전송 도중에 도착해도, 패킷 2의 전송이 끝날 때까지 기다렸다가 전송된다.
## 라운드 로빈 (Round Robin)
패킷들이 우선순위 큐잉에서처럼 클래스로 분류되지만, 클래스 간에 엄격한 서비스 우선순위는 없다. 대신, 라운드 로빈 스케줄러는 클래스들 사이에서 서비스를 번갈아 가며 제공한다.
- **작업 보존 큐잉(Work-conserving queuing)** 원칙을 따르며, 전송할 패킷이 있는 한 링크를 유휴 상태로 두지 않는다. 특정 클래스의 큐가 비어있으면 즉시 다음 클래스로 넘어간다.
## 가중 공정 큐잉 (Weighted Fair Queuing, WFQ)
라운드 로빈의 일반화된 형태로, 라우터에서 널리 구현되어 있다.
- WFQ는 라운드 로빈처럼 순환 방식으로 클래스에 서비스를 제공하지만, 각 클래스가 시간 간격 동안 받는 서비스의 양을 차등화할 수 있다.
- 각 클래스 `i`에 가중치 $w_i$가 할당된다. 전송할 패킷이 있는 시간 동안 클래스 `i`는 $w_i / (\sum w_j)$에 해당하는 서비스 비율을 보장받는다.
- 따라서 전송률이 `R`인 링크에서 클래스 `i`는 최소 $R * w_i / (\sum w_j)$의 처리량을 항상 달성할 수 있다.

## 넷 중립성 (Net Neutrality)
넷 중립성은 일반적으로 모든 인터넷 트래픽이 동등하게 취급되어야 한다는 원칙을 말한다.
**패킷 스케줄링 메커니즘은 트래픽 클래스에 따라 차등적인 서비스를 제공하는 데 사용될 수 있다.** 
2015년 미국 FCC는 "차단 금지", "스로틀링 금지", "유료 우선순위 부여 금지"라는 세 가지 명확한 규칙을 제시했다. 이러한 규칙들은 ISP가 특정 콘텐츠, 애플리케이션, 서비스를 차단하거나 속도를 저하시키거나, 비용을 지불하는 트래픽을 우대하는 것을 금지한다. 하지만 2017년 이 규칙들은 폐지되고 ISP의 투명성에 초점을 맞추는 방향으로 정책이 변경되었다. 넷 중립성에 대한 논쟁은 계속 진행 중이다.