---
chapter: "4"
---
# IPv4 데이터그램 형식
![[IPv4_datagram_format.png]]
- **Version number (버전 번호)**: 4bit 필드. 데이터그램의 IP 프로토콜 버전을 명시한다. 라우터는 이 버전 번호를 보고 데이터그램의 나머지 부분을 어떻게 해석할지 결정한다. IPv4는 이 필드 값이 4다.
- **Header length (헤더 길이)**: 4bit 필드. IP 데이터그램에서 페이로드(e.g. 이 데이터그램안에 캡슐화된 전송 계층 세그먼트)가 실제로 시작되는 위치를 결정하는 데 필요하다. 대부분의 IP 데이터그램은 가변 길이 옵션을 포함하지 않으므로 일반적으로 20byte 헤더를 가진다.
- **Type of service (서비스 유형)**: 이 필드로 서로 다른 유형의 IP 데이터그램을 구별한다. 예를 들어, 실시간 데이터그램(IP 전화 애플리케이션)과 비실시간 트래픽(FTP)을 구별할 수 있다. 이 중 2비트는 명시적 혼잡 알림(Explicit Congestion Notification)에 사용된다.
- **Datagram length (데이터그램 길이)**: IP 데이터그램의 전체 길이(헤더 + 데이터)를 byte 단위로 나타낸다. 이 필드는 16bit이므로 이론상 최대 크기는 65,535byte($2^{16} - 1$)다. 그러나 데이터그램은 일반적으로 1,500byte를 넘지 않는다.
- **Identifier, flags, fragmentation offset (식별자, 플래그, 단편화 오프셋)**: 이 세 필드는 큰 IP 데이터그램이 여러 개의 작은 데이터그램으로 나뉘는 **IP 단편화(IP fragmentation)** 와 관련이 있다. 단편화된 데이터그램들은 목적지까지 독립적으로 전달된 후, 페이로드 데이터가 전송 계층으로 전달되기 전에 재조립된다. IPv6에서는 단편화를 허용하지 않는다.
- **Time-to-live (TTL, 생존 시간)**: 데이터그램이 네트워크에서 영원히 순환하는 것을 방지하기 위해 포함된다. 이 필드는 데이터그램이 라우터를 통과할 때마다 1씩 감소하며, 0이 되면 라우터는 해당 데이터그램을 폐기해야 한다.
- **Protocol**: 이 필드는 데이터그램이 최종 목적지에 도달했을 때만 사용된다. 필드의 값은 이 IP 데이터그램의 데이터 부분을 어떤 전송 계층 프로토콜로 전달해야 하는지를 나타낸다. 예를 들어, 값이 6이면 TCP로, 17이면 UDP로 데이터가 전달된다. 이 프로토콜 번호는 네트워크 계층과 전송 계층을 연결하는 역할을 한다.
- **Header checksum**: 라우터가 수신한 IP 데이터그램의 비트 오류를 감지하는 데 도움을 준다. 헤더의 각 2바이트를 숫자로 취급하고 1의 보수 연산으로 합산하여 계산된다. TTL 필드 등이 라우터마다 변경되므로, 체크섬은 각 라우터에서 다시 계산되고 저장되어야 한다. 
> [!tip]
    > TCP/UDP와 IP 모두에서 오류 검사를 수행하는 이유는, IP 헤더만 IP 계층에서 체크섬되고 TCP/UDP 세그먼트는 전체에 대해 체크섬이 계산되기 때문이며, 또한 TCP가 IP가 아닌 다른 프로토콜 위에서 실행될 수도 있기 때문이다.
- **Source 및 Destination IP 주소**: 출발지 호스트가 데이터그램을 생성할 때, 자신의 IP 주소를 출발지 IP 주소 필드에, 최종 목적지의 주소를 목적지 IP 주소 필드에 삽입한다.
- **Options**: IP 헤더를 확장할 수 있게 해주는 필드다. 드물게 사용되도록 의도되었으나, 이 필드를 사용하면 헤더 길이가 가변적이게 되어 데이터 필드의 시작 위치를 예측하기 어렵워 진다. 이러한 이유로 IPv6 헤더에는 이 필드가 포함되지 않는다.
- **Data (payload)**: 대부분의 경우 목적지로 전달될 전송 계층 세그먼트(TCP 또는 UDP)를 포함한다. 그러나 ICMP 메시지와 같은 다른 유형의 데이터를 전달할 수도 있다.
# IPv4 주소 지정 방식
## 인터페이스와 IP 주소
호스트와 라우터가 IP 데이터그램을 송수신하려면 각 인터페이스에 고유한 IP 주소가 필요하다. 따라서 IP 주소는 호스트나 라우터 자체가 아닌, **인터페이스**에 연결된다. **하나의 라우터는 여러 인터페이스를 가지므로 여러 개의 IP 주소를 가질 수 있다.**

각 IP 주소는 32bit(4byte) 길이이며, **8bit 씩 4개 구간으로 나눠** 10진수 표기법으로 작성된다(e.g. `193.32.216.9`). 전역 인터넷의 모든 호스트와 라우터 인터페이스는 전역적으로 고유한 IP 주소를 가져야 한다 (NAT 뒤의 인터페이스는 예외).
## 서브넷
IP 주소의 일부는 연결된 **서브넷(subnet)** 에 의해 결정된다.
![[interface_addresses_and_subnets.png]]
- 왼쪽 상단의 세 호스트와 라우터 인터페이스는 모두 `223.1.1.xxx` 형태의 IP 주소를 가진다. 즉, 왼쪽 24bit가 동일하다.
- 라우터 없이 서로 연결된 이 인터페이스들의 집합은 하나의 **서브넷**을 형성한다. 이 서브넷의 주소는 `223.1.1.0/24`로 표현되며, `/24` 표기법(서브넷 마스크)은 주소의 첫 24bit가 서브넷 주소임을 나타낸다.
- 마찬가지로 223.1.2.0/24, 223.1.3.0/24 서브넷이 있다.

여러 라우터와 호스트가 복잡하게 연결된 시스템에서 서브넷을 식별하는 방법: 
1. 각 인터페이스를 호스트나 라우터에서 분리하여 고립된 네트워크들의 '섬'을 만든다. 
2. 이 각각의 고립된 네트워크가 하나의 서브넷이 된다.
![[complexed_subnets.png | 500]]
위 그림에는 223.1.1.0/24, 223.1.2.0/24, 223.1.3.0/24, 223.1.7.0/24, 223.1.8.0/24, 223.1.9.0/24으로 총 6개의 서브넷이 있다.
## CIDR(Classless Interdomain Routing)
CIDR은 서브넷 주소 지정 개념을 일반화한 것으로, 32비트 IP 주소를 `a.b.c.d/x` 형식으로 표현한다.
- `x`는 주소의 첫 부분을 구성하는 비트 수를 나타내며, 이 `x`개의 비트를 주소의 **prefix** 또는 네트워크 부분이라고 한다.
- 조직 외부의 라우터는 패킷을 전달할 때 이 프리픽스만을 고려하므로, 라우팅 테이블의 크기를 크게 줄일 수 있다.
- 나머지 `32 - x`bit는 조직 내의 장치들을 구별하는 데 사용된다.

과거에는 8, 16, 24비트 길이의 네트워크 부분만 허용하는 **클래스 기반 주소 지정**을 사용했다. 이는 각각 클래스 A, B, C 네트워크로 불렸다. 이 방식은 주소 공간의 고갈과 비효율적인 할당 문제를 야기했다. 예를 들어, 2,000개의 호스트를 가진 기관이 클래스 B(/16) 주소를 할당받으면 65,534개의 주소 공간을 차지하게 되어 약 63,000개의 주소가 낭비된다.

> [!NOTE]
    > 인터넷 사용 조직은 ISP로부터 주소 블록을 할당받는다. ISP는 ICANN(Internet Corporation for Assigned Names and Numbers)으로부터 더 큰 주소 블록을 할당받아 이를 다시 고객에 나눠준다. ICANN은 IP 주소 할당, DNS 루트 서버 관리, 도메인 이름 할당 등의 역할을 수행하는 비영리 단체다.
## DHCP (Dynamic Host Configuration Protocol)
기관이 주소 블록을 받으면 각 호스트에 개별 IP 주소를 할당하는데, 이 작업은 보통 DHCP로 자동화된다.
- 네트워크에 연결된 장치에 IP 주소와 기타 네트워크 설정 정보(서브넷 마스크, 기본 게이트웨이 주소, 로컬 DNS 서버 주소 등)를 자동으로 할당한다.
- DHCP 서버는 엣지 라우터에 있다.
- DHCP 서버는 장치가 네트워크에 연결되면 IP 주소를 할당하고, 네트워크 연결이 끊기면 IP 주소를 회수한다.
### DHCP 프로토콜 과정
1. **DHCP 서버 발견**: 새로 연결된 호스트가 DHCP 발견 메시지를 브로드캐스트하여 DHCP 서버를 찾는다.
2. **DHCP 서버 제공**: DHCP 서버가 발견 메시지에 응답하여 IP 주소, 네트워크 마스크, IP 주소 임대 시간 등을 포함한 DHCP 제공 메시지를 브로드캐스트한다.
3. **DHCP 요청**: 클라이언트가 여러 메시지들 중 하나를 선택하고, DHCP 요청 메시지로 응답한다.
4. **DHCP ACK**: 서버가 요청된 매개변수를 확인하는 DHCP ACK 메시지로 응답한다. 이 과정이 완료되면 클라이언트는 할당된 IP 주소를 사용할 수 있다.

위 4단계 중 실제로는 마지막 두 단계만 필요하다. 자세한 동작은 다음과 같다.
1. 운영체제가 DHCP 요청 메시지를 UDP 세그먼트에 넣는다. 이때 destination 포트는 DHCP 서버 포트인 67이고, 소스 포트는 DHCP 클라이언트 포트인 68이다. UDP 세그먼트는 브로드캐스트 IP destination 주소와 0.0.0.0의 소스 IP 주소를 가지고 IP 데이터그램안에 위치한다.
2. IP 데이터그램은 이더넷프레임 내에 배치된다. 이더넷프레임은 destination MAC 주소를 가지고 스위치에 연결된 모든 장치들에 전파된다. 이때 이더넷프레임의 소스 MAC 주소는 내 컴퓨터의 MAC 주소다.
3. 2의 이더넷 프레임은 내 컴퓨터가 이더넷 스위치로 전송하는 첫번째 프레임이다. 스위치는 들어온 프레임을 라우터와 연결된 포트를 포함한 모든 아웃 포트로 전파한다.
4. 라우터는 자신의 MAC 주소를 가진 인터페이스에서 DHCP 요청이 포함된 이더넷프레임을 수신하고 이더넷프레임에서 IP 데이터그램을 추출한다. 데이터그램의 브로드캐스트 IP destination 주소는 이 IP 데이터그램이 이 노드에서 상위계층 프로토콜에 의해 처리되어야 함을 나타낸다. 따라서 데이터그램의 페이로드(UDP 세그먼트)는 UDP까지 demultiplexed 되고, DHCP 요청 메시지가 UDP 세그먼트로부터 추출된다.
5. 라우터 안에서 작동 중인 DHCP 서버는 CIDR 블록 내의 IP 주소를 할당한다. DHCP 서버는 DHCP ACK 메시지를 만드는데, 이 안에는 할당할 IP 주소, DNS 서버의 IP 주소, 기본 게이트웨이의 IP 주소, 서브넷 마스크가 들어있다. DHCP 메시지는 UDP 세그먼트 안에 들어가고, UDP 세그먼트는 IP 데이터그램 안에 들어가며, IP 데이터그램은 이더넷프레임 안에 들어간다. 이더넷프레임 안에는 라우터가 속한 네트워크에 대한 라우터 인터페이스의 출발지 MAC 주소와 목적지(내 컴퓨터) MAC 주소가 들어있다.
6. DHCP ACK를 포함한 이더넷프레임은 라우터에 의해서 스위치로 보내진다. 스위치는 2에서 DHCP 요청이 포함된 이더넷프레임을 받은 적이 있기 때문에 프레임의 목적지 MAC 주소를 보고 내 컴퓨터로 연결되는 포트에만 전달한다.
7. 내 컴퓨터는 이더넷프레임을 수신하고나서 IP 데이터그램 -> UDP 세그먼트 -> DHCP ACK 메시지 순서로 추출한다. DHCP 클라이언트는 DHCP ACK 메시지 안에서 할당받은 IP 주소와 DNS 서버의 IP 주소를 기록한다. 그리고 기본 게이트웨이의 주소를 IP 포워딩 테이블에 설치한다. 그러면 이제부터 내 컴퓨터는 서브넷 외 주소를 가진 모든 데이터그램을 기본 게이트웨이로 받게 된다. 이제 내 컴퓨터는 네트워크 컴포넌트로 초기화되고, 웹페이지 페치를 시작할 준비를 한다.

DHCP는 이동성에 한계가 있는데, 노드가 새 서브넷에 연결될 때마다 새 IP 주소를 받기 때문에 원격 애플리케이션과의 TCP 연결을 유지할 수 없다.

# Network Address Translation(NAT)
## NAT의 필요성
소규모 사무실이나 가정 네트워크에서 여러 장치를 인터넷에 연결하려면 각 장치마다 ISP로부터 IP 주소를 할당받아야 한다. 이는 주소 관리의 복잡성을 증가시키고, ISP가 할당한 주소 블록이 부족해지는 문제를 야기할 수 있다. **네트워크 주소 변환(Network Address Translation, NAT)** 은 이러한 문제를 해결하는 간단한 접근법이다.
## NAT의 동작 원리
NAT를 지원하는 라우터는 외부 세계에는 단일 IP 주소를 가진 단일 장치처럼 보인다.

- **사설 네트워크 주소**: 가정과 같은 내부 네트워크에서는 `10.0.0.0/24`와 같은 사설 주소 공간을 사용한다. 이 주소는 해당 네트워크 내에서만 의미를 가지며, 외부 인터넷에서는 고유하지 않다.
- **NAT 변환 테이블**: 외부 인터넷으로 나가는 모든 트래픽은 NAT 라우터의 공인 IP 주소(e.g. `138.76.29.7`)를 출발지 IP 주소로 사용한다. 라우터는 **NAT 변환 테이블**을 사용하여 내부의 사설 IP 주소 및 포트 번호와 외부에서 사용하는 공인 IP 주소 및 새로운 포트 번호를 매핑한다.

    1. 내부 호스트(e.g. `10.0.0.1`, 포트 `3345`)가 외부 웹 서버(e.g. `128.119.40.186`, 포트 `80`)로 요청을 보낸다.
    2. NAT 라우터는 이 데이터그램을 수신하고, 출발지 IP 주소를 자신의 공인 IP(`138.76.29.7`)로, 출발지 포트 번호를 **새로운 임시 포트 번호**(`5001`)로 변경한다. 그리고 `(10.0.0.1, 3345)`와 `(138.76.29.7, 5001)`의 매핑 정보를 NAT 변환 테이블에 추가한다.
    3. 웹 서버는 NAT 라우터의 공인 IP 주소와 임시 포트 번호로 응답을 보낸다.
    4. NAT 라우터는 응답 데이터그램을 수신하면, 변환 테이블을 참조하여 목적지 IP 주소와 포트 번호를 원래의 내부 호스트 주소(`10.0.0.1`)와 포트 번호(`3345`)로 다시 변경한 후 내부 네트워크로 전달한다.
## NAT의 문제점
- **포트 번호의 용도 위반**: 포트 번호는 호스트가 아닌 **프로세스를 식별**하는 데 사용되어야 한다는 원칙을 위반한다. 이로 인해 P2P 애플리케이션이나 외부에서 내부 서버로 접속해야 하는 경우 문제가 발생할 수 있다.
- **계층 구조 위반**: 라우터는 네트워크 계층(L3) 장치로서 IP 주소까지만 처리해야 하지만, NAT는 전송 계층(L4)의 포트 번호까지 수정한다. 이는 호스트 간의 직접적인 통신을 방해하는 요소로 작용할 수 있다.