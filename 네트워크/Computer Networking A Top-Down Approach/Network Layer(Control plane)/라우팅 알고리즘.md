# 그래프를 이용한 알고리즘
- 네트워크는 그래프로 추상화할 수 있다.
- 각 라우터는 노드고, 이웃한 라우터를 잇는 물리적 링크는 간선이다.
- 간선에는 비용이 있다.
- 라우팅 알고리즘은 두 노드 간의 최소 비용 경로 또는 모든 간선의 비용이 동일할때 최단 경로를 찾는 것이다.
# 라우팅 알고리즘의 분류
## 중앙 집중식 vs 분산식
### **중앙 집중식** 라우팅 알고리즘
- 송신자와 수신자 사이의 모든 노드 간의 연결성과 모든 링크 비용을 입력으로 받 최소 비용 경로를 계산한다.
- 계산 자체는 논리적으로 중앙 집중화된 컨트롤러에서 실행될 수도 있고, 각 라우터의 라우팅 구성 요소에서 복제되어 실행될 수도 있다.
- 전역 상태 정보를 가진 알고리즘은 종종 **링크 상태(Link-State, LS) 알고리즘**이라고 불린다.
### **분산식** 라우팅 알고리즘
- 최소 비용 경로의 계산은 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.
- 어떤 노드도 모든 네트워크 링크의 비용에 대한 완전한 정보를 가지지 않는다. 대신, 각 노드는 **자신에게 직접 연결된 링크의 비용 정보만으로 계산**을 시작한다. 그런 다음, **이웃 노드와의 반복적인 계산 및 정보 교환** 과정을 통해 점진적으로 목적지까지의 최소 비용 경로를 계산한다.
- 분산 알고리즘을 **거리 벡터(Distance-Vector, DV) 알고리즘**이라고 부르며, 각 노드는 네트워크의 다른 모든 노드까지의 비용(거리) 추정치 벡터를 유지한다.
## 정적 vs 동적
경로 변경 주기
### 정적 라우팅 알고리즘
- 경로는 시간이 지나도 매우 느리게 변경되며, 종종 인간의 개입에 의해 변경된다.
### 동적 라우팅 알고리즘
- 네트워크 트래픽 부하 또는 토폴로지가 변경됨에 따라 라우팅 경로를 변경한다.
- 동적 알고리즘은 주기적으로 실행되거나 토폴로지 또는 링크 비용 변경에 직접 반응하여 실행될 수 있다.
## 부하 감지 여부
네트워크 부하를 경로 계산에 반영하는지 여부
### 부하 감지 알고리즘
- 링크 비용이 현재 링크의 혼잡 수준을 반영하여 동적으로 변한다.
### 부하 비감지 알고리즘
- 링크의 비용이 현재 또는 최근의 혼잡 수준을 명시적으로 반영하지 않는다.
- RIP, OSPF, BGP은 부하 비감지 방식이다.
# 링크 상태(LS) 알고리즘
- 각 노드가 자신의 링크 상태 정보를 네트워크의 다른 모든 노드에게 브로드캐스트함으로써 모든 노드는 네트워크에 대한 동일하고 완전한 정보를 가지게 된다.
- 각 노드는 LS 알고리즘을 실행하여 다른 모든 노드와 동일한 최소 비용 경로 집합을 계산할 수 있다.
## 다익스트라 알고리즘(Dijkstra's Algorithm)
알고리즘에 사용되는 표기법은 다음과 같다.
- $D(v)$: 현재 반복 단계에서 출발 노드 $u$로부터 목적지 $v$까지의 최소 비용 경로의 비용.
- $p(v)$: 출발지로부터 $v$까지의 현재 최소 비용 경로상에서 $v$의 직전 노드.
- $N'$: 노드의 부분 집합. 소스로부터 $v$까지의 최소 비용 경로가 확정적으로 알려진 경우 $v$는 $N'$에 포함된다. 즉, 경로 비용이 계산된 노드 집합
- $c(x, y)$: 노드 x와 y 사이의 비용. x와 y가 이웃이 아니라면 비용은 무한대다.

중앙 집중식 라우팅 알고리즘은 초기화 단계와 루프(loop)로 구성된다. 루프는 네트워크의 노드 수만큼 실행된다. 알고리즘이 종료되면 출발 노드 $u$에서 네트워크의 다른 모든 노드까지의 최단 경로가 계산된다.

```
# 초기화:
N' = {u}
for v in 모든 노드:
	if v가 u의 이웃이면:
		D(v) = c(u, v)
	else:
		D(v) = infinity
		
# 루프:
1. N'에 속하지 않는 w 중에서 D(w)가 최소인 w를 찾는다
2. w를 N'에 추가한다
3. w의 모든 이웃 중 N'에 속하지 않은 이웃 v들의 비용을 갱신한다:
	D(v) = min(D(v), D(w) + c(w, v))
# v에 대한 새 비용은 v에 대한 기존 비용이거나 w에 대한 알려진 최소 경로 비용에 w에서 v까지의 비용을 더한 값이다		
```

### 예시
![[network_graph_example.png ]]
u에서 다른 모든 노드들까지의 최소 비용 경로를 계산해보자.
#### 초기화
- N' = {u}
- u에서 직접 연결된 이웃 노드인 v, x, w까지의 최소 비용은 2, 1, 5로 초기화된다.
- u와 직접 연결되지 않은 y, z까지의 비용은 무한대(infinity)로 초기화된다.
#### 첫 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 x다.
- N' = {u, x}
- x의 이웃 중 N'에 포함되지 않은 v, w, y까지의 비용을 갱신한다.
	- v까지의 기존 비용 = D(v) = 2
	- v까지의 새로운 비용 = D(x) + c(x, v) = 1 + 2 = 3
	- D(v) = min(2, 3) = 2
	- w까지의 기존 비용 = D(w) = 5
	- w까지의 새로운 비용 = D(w) + c(x, w) = 1 + 3 = 4
	- D(w) = min(5, 4) = 4
	- y까지의 기존 비용 = D(y) = infinity
	- y까지의 새로운 비용 = D(y) + c(x, y) = 1 + 1 = 2
	- D(y) = min(infinity, 2) = 2
#### 두 번째 루프
- N'에 포함되지 않은 노드 중 비용(D(node))이 가장 작은 노드는 v, y다.
- N' = {u, x, y} (임의로 y 추가)
- y의 이웃 중 N'에 포함되지 않은 w, z까지의 비용을 갱신한다.
	- w까지의 기존 비용 = D(w) = 4
	- w까지의 새로운 비용 = D(y) + c(y, w) = 2 + 1 = 3
	- D(w) = min(4, 3) = 3
	- z까지의 기존 비용 = D(z) = infinity
	- z까지의 새로운 비용 = D(y) + c(y, z) = 2 + 2 = 4
	- D(z) = min(infinity, 4) = 4
#### 세 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 v다.
- N' = {u, x, y, v}
- v의 이웃 중 N'에 포함되지 않은 w, z까지의 비용을 갱신한다.
	- w까지의 기존 비용 = D(w) = 3
	- w까지의 새로운 비용 = D(v) 