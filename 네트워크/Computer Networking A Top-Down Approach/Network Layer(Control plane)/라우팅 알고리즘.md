# 그래프를 이용한 알고리즘
- 네트워크는 그래프로 추상화할 수 있다.
- 각 라우터는 노드고, 이웃한 라우터를 잇는 물리적 링크는 간선이다.
- 간선에는 비용이 있다.
- 라우팅 알고리즘은 두 노드 간의 최소 비용 경로 또는 모든 간선의 비용이 동일할때 최단 경로를 찾는 것이다.
# 라우팅 알고리즘의 분류
## 중앙 집중식 vs 분산식
### **중앙 집중식** 라우팅 알고리즘
- 송신자와 수신자 사이의 모든 노드 간의 연결성과 모든 링크 비용을 입력으로 받 최소 비용 경로를 계산한다.
- 계산 자체는 논리적으로 중앙 집중화된 컨트롤러에서 실행될 수도 있고, 각 라우터의 라우팅 구성 요소에서 복제되어 실행될 수도 있다.
- 전역 상태 정보를 가진 알고리즘은 종종 **링크 상태(Link-State, LS) 알고리즘**이라고 불린다.
### **분산식** 라우팅 알고리즘
- 최소 비용 경로의 계산은 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.
- 어떤 노드도 모든 네트워크 링크의 비용에 대한 완전한 정보를 가지지 않는다. 대신, 각 노드는 **자신에게 직접 연결된 링크의 비용 정보만으로 계산**을 시작한다. 그런 다음, **이웃 노드와의 반복적인 계산 및 정보 교환** 과정을 통해 점진적으로 목적지까지의 최소 비용 경로를 계산한다.
- 분산 알고리즘을 **거리 벡터(Distance-Vector, DV) 알고리즘**이라고 부르며, 각 노드는 네트워크의 다른 모든 노드까지의 비용(거리) 추정치 벡터를 유지한다.
## 정적 vs 동적
경로 변경 주기
### 정적 라우팅 알고리즘
- 경로는 시간이 지나도 매우 느리게 변경되며, 종종 인간의 개입에 의해 변경된다.
### 동적 라우팅 알고리즘
- 네트워크 트래픽 부하 또는 토폴로지가 변경됨에 따라 라우팅 경로를 변경한다.
- 동적 알고리즘은 주기적으로 실행되거나 토폴로지 또는 링크 비용 변경에 직접 반응하여 실행될 수 있다.
## 부하 감지 여부
네트워크 부하를 경로 계산에 반영하는지 여부
### 부하 감지 알고리즘
- 링크 비용이 현재 링크의 혼잡 수준을 반영하여 동적으로 변한다.
### 부하 비감지 알고리즘
- 링크의 비용이 현재 또는 최근의 혼잡 수준을 명시적으로 반영하지 않는다.
- RIP, OSPF, BGP은 부하 비감지 방식이다.
# 링크 상태(LS) 알고리즘
- 각 노드가 자신의 링크 상태 정보를 네트워크의 다른 모든 노드에게 브로드캐스트함으로써 모든 노드는 네트워크에 대한 동일하고 완전한 정보를 가지게 된다.
- 각 노드는 LS 알고리즘을 실행하여 다른 모든 노드와 동일한 최소 비용 경로 집합을 계산할 수 있다.
## 다익스트라 알고리즘(Dijkstra's Algorithm)
알고리즘에 사용되는 표기법은 다음과 같다.
- $D(v)$: 현재 반복 단계에서 출발 노드 $u$로부터 목적지 $v$까지의 최소 비용 경로의 비용.
- $p(v)$: 출발지로부터 $v$까지의 현재 최소 비용 경로상에서 $v$의 직전 노드.
- $N'$: 노드의 부분 집합. 소스로부터 $v$까지의 최소 비용 경로가 확정적으로 알려진 경우 $v$는 $N'$에 포함된다. 즉, 경로 비용이 계산된 노드 집합
- $c(x, y)$: 노드 x와 y 사이의 비용. x와 y가 이웃이 아니라면 비용은 무한대다.

중앙 집중식 라우팅 알고리즘은 초기화 단계와 루프(loop)로 구성된다. 루프는 네트워크의 노드 수만큼 실행된다. 알고리즘이 종료되면 출발 노드 $u$에서 네트워크의 다른 모든 노드까지의 최단 경로가 계산된다.

```
# 초기화:
N' = {u}
for v in 모든 노드:
	if v가 u의 이웃이면:
		D(v) = c(u, v)
	else:
		D(v) = infinity
		
# 루프:
1. N'에 속하지 않는 w 중에서 D(w)가 최소인 w를 찾는다
2. w를 N'에 추가한다
3. w의 모든 이웃 중 N'에 속하지 않은 이웃 v들의 비용을 갱신한다:
	D(v) = min(D(v), D(w) + c(w, v))
# v에 대한 새 비용은 v에 대한 기존 비용이거나 w에 대한 알려진 최소 경로 비용에 w에서 v까지의 비용을 더한 값이다		
```

### 예시
![[network_graph_example.png ]]
u에서 다른 모든 노드들까지의 최소 비용 경로를 계산해보자.
#### 초기화
- N' = {u}
- u에서 직접 연결된 이웃 노드인 v, x, w까지의 최소 비용은 2, 1, 5로 초기화된다.
- u와 직접 연결되지 않은 y, z까지의 비용은 무한대로 초기화된다.

| N'에 포함되지 않은 이웃 노드(node') | 기존 비용(D(node')) | 직전 노드(p(node')) |
| ------------------------ | --------------- | --------------- |
| v                        | 2               | u               |
| x                        | 1               | u               |
| w                        | 5               | u               |
#### 첫 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 x다.
- N' = {u, x}
- x의 이웃 중 N'에 포함되지 않은 v, w, y까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| v                                | 2               | 1 + 2 = 3                        | 2                | u               |
| w                                | 5               | 1 + 3 = 4                        | 4                | x               |
| y                                | inf             | 1 + 1 = 2                        | 2                | x               |
#### 두 번째 루프
- N'에 포함되지 않은 노드 중 비용(D(node))이 가장 작은 노드는 v, y다.
- N' = {u, x, y} (임의로 y 추가)
- y의 이웃 중 N'에 포함되지 않은 w, z까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| w                                | 4               | 2 + 1 = 3                        | 3                | y               |
| z                                | inf             | 2 + 2 = 4                        | 4                | y               |
#### 세 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 v다.
- N' = {u, x, y, v}
- v의 이웃 중 N'에 포함되지 않은 w까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| w                                | 3               | 2 + 3 = 5                        | 3                | y               |
#### 네 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 w다.
- N' = {u, x, y, v, w}
- w의 이웃 중 N'에 포함되지 않은 z까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| z                                | 4               | 3 + 5 = 8                        | 4                | y               
#### 다섯 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 z다.
- N' = {u, x, y, v, w, z}
- z의 이웃 중 N'에 포함되지 않은 노드는 없으므로 루프는 종료된다.
#### 표
| 루프  | N'               | D(v), p(v) | D(w), p(w) | D(x), p(x) | D(y), p(y) | D(z), p(z) |
| --- | ---------------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| 0   | u                | 2, u       | 5, u       | 1, u       | inf        | inf        |
| 1   | u, x             | 2, u       | 4, x       |            | 2, x       | inf        |
| 2   | u, x, y          | 2, u       | 3, y       |            |            | 4, y       |
| 3   | u, x, y, v       |            | 3, y       |            |            | 4, y       |
| 4   | u, x, y, v, w    |            |            |            |            | 4, y       |
| 5   | u, x, y, v, w, z |            |            |            |            |            |
### 계산 복잡도
다익스트라 알고리즘의 계산 복잡도는 $n$개의 노드가 있을 때, 단순 구현 시 $O(n^2)$이다. 힙(heap) 자료구조를 사용하면 복잡도를 줄일 수 있다.
## 진동 현상(Oscillation)
링크 비용이 트래픽 양(부하)에 따라 변하는 경우, 진동(oscillation)이라는 병리 현상이 발생할 수 있다. 
![[oscillations_with_congestion-sensitive_routing.png]]

모든 라우터가 동시에 라우팅 알고리즘을 실행하고 트래픽을 특정 경로로 몰면, 해당 경로의 비용이 급증하고 다음 계산에서는 다른 경로가 선택된다. 이러한 과정이 반복되면서 **경로가 계속 바뀌게 된다**. 이를 방지하기 위해 모든 라우터가 동시에 알고리즘을 실행하지 않도록 하거나, 각 라우터가 링크 상태 정보를 보내는 시간을 무작위로 설정하는 방법이 있다.
# 거리 벡터(Distance-Vector, DV) 알고리즘
LS 알고리즘이 전역 정보를 사용하는 알고리즘인 반면, 거리 벡터(Distance-Vector, DV) 알고리즘은 **반복적(iterative), 비동기적(asynchronous), 분산적(distributed)** 이다.
- **분산적**: 각 노드는 자신의 직접 연결된 이웃 중 하나 이상으로부터 정보를 받고, 계산을 수행한 후, 그 계산 결과를 다시 이웃에게 배포한다.
- **반복적**: 이 과정은 이웃 간에 더 이상 정보가 교환되지 않을 때까지 계속된다. 이 알고리즘은 계산을 중단하라는 신호 없이 스스로 종료된다.
- **비동기적**: 모든 노드가 서로 보조를 맞추어 작동할 필요가 없다.
## 벨만-포드 방정식 (Bellman-Ford Equation)
DV 알고리즘을 이해하기 전에, 최소 비용 경로들 사이에 존재하는 중요한 관계를 먼저 살펴보는 것이 유용하다. 노드 x에서 y까지의 최소 비용 경로의 비용을 dₓ(y)라고 하자. 이 최소 비용들은 유명한 벨만-포드 방정식으로 관련된다.

dₓ(y) = minᵥ{c(x, v) + dᵥ(y)}

여기서 minᵥ는 x의 모든 이웃 v에 대해 취해진다. 
x에서 v로 이동한 후 v에서 y까지의 최소 비용 경로를 택하면 경로 비용은 c(x, v) + dᵥ(y)가 된다. 어떤 이웃 v로든 시작해야 하므로, x에서 y까지의 최소 비용은 모든 이웃 v에 대해 c(x, v) + dᵥ(y)를 취한 것의 최솟값이다.
벨만-포드 방정식의 해는 노드 x의 전달 테이블 항목을 제공하며, 이는 DV 알고리즘에서 이웃 간 통신의 형태를 제시하는 실용적인 기여를 한다.

## 거리 벡터 (DV) 알고리즘
기본 아이디어는 다음과 같다. 
각 노드 x는 자신으로부터 네트워크 N의 모든 다른 노드 y까지의 최소 비용 경로에 대한 추정치 Dₓ(y)로 시작한다. Dₓ = \[Dₓ(y): y in N]는 x의 거리 벡터이며, 이는 x에서 네트워크 N의 다른 모든 노드 y까지의 비용 추정치 벡터이다. 
DV 알고리즘에서 각 노드 x는 다음 라우팅 정보를 유지한다.
- 각 이웃 v에 대해, x에서 직접 연결된 이웃 v까지의 비용 c(x, v).
- 노드 x의 거리 벡터, 즉 Dₓ = \[Dₓ(y): y in N].
- 각 이웃의 거리 벡터, 즉 x의 각 이웃 v에 대한 Dᵥ = \[Dᵥ(y): y in N].

각 노드는 때때로 자신의 거리 벡터 사본을 각 이웃에게 보낸다.
노드 x가 이웃 w로부터 새로운 거리 벡터를 받으면, w의 거리 벡터를 저장하고 벨만-포드 방정식을 사용하여 자신의 거리 벡터를 다음과 같이 갱신한다.

Dₓ(y) = minᵥ{c(x, v) + Dᵥ(y)} for each node y in N

이 갱신 단계의 결과로 노드 x의 거리 벡터가 변경되면, 노드 x는 갱신된 거리 벡터를 각 이웃에게 보내고, 이웃들은 차례로 자신의 거리 벡터를 갱신할 수 있다.
모든 노드가 비동기적으로 자신의 거리 벡터를 계속 교환하는 한, 각 비용 추정치 Dₓ(y)는 노드 x에서 노드 y까지의 실제 최소 비용 경로의 비용인 dₓ(y)로 수렴한다.

```
각 노드 x에서:

# 초기화
for 모든 목적지 y in N:
	Dₓ(y) = c(x, y) (y가 이웃이 아니면 c(x, y) = ∞)
for 각 이웃 w:
	모든 목적지 y in N에 대해 D_w(y) = ?
for 각 이웃 w:
	거리 벡터 Dₓ = \[Dₓ(y): y in N]을 w에게 보냄
	
# 루프
	이웃 w로의 링크 비용 변경을 감지하거나 이웃 w로부터 거리 벡터를 받을 때까지 대기
	
	for y in N:
		Dₓ(y) = minᵥ{c(x, v) + Dᵥ(y)}
		
if 어떤 목적지 y에 대해 Dₓ(y)가 변경되면:
	거리 벡터 Dₓ = [Dₓ(y): y in N]을 모든 이웃에게 보냄

영원히 반복
```

DV 알고리즘에서 노드 x는 직접 연결된 링크 중 하나의 비용 변경을 감지하거나 이웃으로부터 거리 벡터 업데이트를 받을 때 자신의 거리 벡터 추정치를 갱신한다.
각 노드는 업데이트를 기다리고, 업데이트를 받으면 새로운 거리 벡터를 계산하며, 비용이 변경된 경우 이웃에게 새로운 거리 벡터를 배포한다.
DV와 유사한 알고리즘은 인터넷의 RIP 및 BGP, ISO IDRP, Novell IPX, 그리고 원래의 ARPAnet을 포함한 많은 실제 라우팅 프로토콜에서 사용된다.

## 링크 비용 변경과 링크 실패
DV 알고리즘을 실행하는 노드가 이웃으로의 링크 비용 변경을 감지하면, 거리 벡터를 갱신하고 최소 비용 경로의 비용이 변경된 경우 이웃에게 새로운 거리 벡터를 알린다.

- **링크 비용 감소**: 링크 비용이 감소했다는 좋은 소식은 네트워크를 통해 빠르게 전파된다. 예를 들어, Figure 5.7(a)에서 y에서 x로의 링크 비용이 4에서 1로 변경되면, y는 거리 벡터를 갱신하고 이웃에게 알린다. z는 y로부터 업데이트를 받고 자신의 테이블을 갱신한다. y는 z의 업데이트를 받고 자신의 테이블을 갱신하지만, 최소 비용이 변경되지 않았으므로 z에게 메시지를 보내지 않는다. 알고리즘은 두 번의 반복만으로 안정 상태에 도달한다.

- **링크 비용 증가와 무한 계수 문제(Count-to-Infinity Problem)**: 링크 비용이 증가하면 문제가 발생할 수 있다. Figure 5.7(b)에서 x와 y 사이의 링크 비용이 4에서 60으로 증가했다고 가정하자.

    1. y는 x로 가는 새로운 최소 비용 경로를 계산한다. y는 z가 x에 비용 5로 도달할 수 있다고 마지막으로 들었기 때문에, z를 통해 x로 라우팅하려고 한다. 이로 인해 y와 z 사이에 라우팅 루프가 발생한다.        
    2. y는 z에게 새로운 거리 벡터를 알린다.
    3. z는 y의 새로운 거리 벡터를 받고, x까지의 새로운 최소 비용을 7로 계산하고, y에게 알린다.
    4. 이 과정은 y와 z 사이의 메시지 교환을 통해 반복되며, z가 결국 y를 통한 경로 비용이 50보다 크다고 계산할 때까지 계속된다. 이 시점에서 z는 x로의 최소 비용 경로가 직접 연결을 통하는 것임을 결정한다. 이처럼 링크 비용 증가라는 나쁜 소식은 매우 느리게 전파된다. 이 문제를 **무한 계수 문제**라고 한다.

### 포이즌 리버스 (Poisoned Reverse)
앞서 설명한 특정 루핑 시나리오는 **포이즌 리버스(poisoned reverse)** 라는 기술을 사용하여 피할 수 있다. 

만약 z가 목적지 x에 도달하기 위해 y를 통해 라우팅한다면, z는 y에게 x까지의 거리가 무한대라고 광고한다. 즉, z는 y에게 D₂(x) = ∞라고 알린다(실제로는 z가 D₂(x)=5라는 것을 알고 있음에도 불구하고). z가 y를 통해 x로 라우팅하는 동안 z는 y에게 이 작은 거짓말을 계속한다. y는 z가 x로 가는 경로가 없다고 믿기 때문에, z가 x로의 라우팅을 y를 통해 계속하는 한(그리고 그렇게 하는 것에 대해 거짓말을 하는 한) y는 z를 통해 x로 라우팅을 시도하지 않을 것이다.

포이즌 리버스는 앞선 특정 루핑 문제를 해결하지만, 일반적인 무한 계수 문제를 해결하지는 못한다. 세 개 이상의 노드가 관련된 루프는 포이즌 리버스 기술로 감지되지 않는다.

# LS와 DV 라우팅 알고리즘 비교
| 특징      | LS (링크 상태)                                       | DV (거리 벡터)                                      |
| ------- | ------------------------------------------------ | ----------------------------------------------- |
| 메시지 복잡도 | O(\|N\|E\|) 메시지 필요. 링크 비용 변경 시 모든 노드에 전파.        | 이웃 간에만 메시지 교환. 링크 비용 변경 시, 최소 비용 경로가 변경될 때만 전파. |
| 수렴 속도   | O(\|N\|²) 알고리즘. 상대적으로 빠름.                        | 느리게 수렴할 수 있으며, 수렴 중 라우팅 루프 발생 가능. 무한 계수 문제 발생.  |
| 견고성     | 한 라우터의 오류가 해당 라우터의 계산에만 영향을 미침. 계산이 분리되어 있어 견고함. | 한 라우터의 오류가 이웃으로 전파되고, 간접적으로 네트워크 전체에 확산될 수 있음.  |
결론적으로, 어느 한 알고리즘이 다른 알고리즘보다 명백하게 우월하지는 않으며, 실제로 인터넷에서는 두 알고리즘 모두 사용된다.