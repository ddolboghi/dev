# 그래프를 이용한 알고리즘
- 네트워크는 그래프로 추상화할 수 있다.
- 각 라우터는 노드고, 이웃한 라우터를 잇는 물리적 링크는 간선이다.
- 간선에는 비용이 있다.
- 라우팅 알고리즘은 두 노드 간의 최소 비용 경로 또는 모든 간선의 비용이 동일할때 최단 경로를 찾는 것이다.
# 라우팅 알고리즘의 분류
## 중앙 집중식 vs 분산식
### **중앙 집중식** 라우팅 알고리즘
- 송신자와 수신자 사이의 모든 노드 간의 연결성과 모든 링크 비용을 입력으로 받 최소 비용 경로를 계산한다.
- 계산 자체는 논리적으로 중앙 집중화된 컨트롤러에서 실행될 수도 있고, 각 라우터의 라우팅 구성 요소에서 복제되어 실행될 수도 있다.
- 전역 상태 정보를 가진 알고리즘은 종종 **링크 상태(Link-State, LS) 알고리즘**이라고 불린다.
### **분산식** 라우팅 알고리즘
- 최소 비용 경로의 계산은 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.
- 어떤 노드도 모든 네트워크 링크의 비용에 대한 완전한 정보를 가지지 않는다. 대신, 각 노드는 **자신에게 직접 연결된 링크의 비용 정보만으로 계산**을 시작한다. 그런 다음, **이웃 노드와의 반복적인 계산 및 정보 교환** 과정을 통해 점진적으로 목적지까지의 최소 비용 경로를 계산한다.
- 분산 알고리즘을 **거리 벡터(Distance-Vector, DV) 알고리즘**이라고 부르며, 각 노드는 네트워크의 다른 모든 노드까지의 비용(거리) 추정치 벡터를 유지한다.
## 정적 vs 동적
경로 변경 주기
### 정적 라우팅 알고리즘
- 경로는 시간이 지나도 매우 느리게 변경되며, 종종 인간의 개입에 의해 변경된다.
### 동적 라우팅 알고리즘
- 네트워크 트래픽 부하 또는 토폴로지가 변경됨에 따라 라우팅 경로를 변경한다.
- 동적 알고리즘은 주기적으로 실행되거나 토폴로지 또는 링크 비용 변경에 직접 반응하여 실행될 수 있다.
## 부하 감지 여부
네트워크 부하를 경로 계산에 반영하는지 여부
### 부하 감지 알고리즘
- 링크 비용이 현재 링크의 혼잡 수준을 반영하여 동적으로 변한다.
### 부하 비감지 알고리즘
- 링크의 비용이 현재 또는 최근의 혼잡 수준을 명시적으로 반영하지 않는다.
- RIP, OSPF, BGP은 부하 비감지 방식이다.
# 링크 상태(LS) 알고리즘
- 각 노드가 자신의 링크 상태 정보를 네트워크의 다른 모든 노드에게 브로드캐스트함으로써 모든 노드는 네트워크에 대한 동일하고 완전한 정보를 가지게 된다.
- 각 노드는 LS 알고리즘을 실행하여 다른 모든 노드와 동일한 최소 비용 경로 집합을 계산할 수 있다.
## 다익스트라 알고리즘(Dijkstra's Algorithm)
알고리즘에 사용되는 표기법은 다음과 같다.
- $D(v)$: 현재 반복 단계에서 출발 노드 $u$로부터 목적지 $v$까지의 최소 비용 경로의 비용.
- $p(v)$: 출발지로부터 $v$까지의 현재 최소 비용 경로상에서 $v$의 직전 노드.
- $N'$: 노드의 부분 집합. 소스로부터 $v$까지의 최소 비용 경로가 확정적으로 알려진 경우 $v$는 $N'$에 포함된다. 즉, 경로 비용이 계산된 노드 집합
- $c(x, y)$: 노드 x와 y 사이의 비용. x와 y가 이웃이 아니라면 비용은 무한대다.

중앙 집중식 라우팅 알고리즘은 초기화 단계와 루프(loop)로 구성된다. 루프는 네트워크의 노드 수만큼 실행된다. 알고리즘이 종료되면 출발 노드 $u$에서 네트워크의 다른 모든 노드까지의 최단 경로가 계산된다.

```
# 초기화:
N' = {u}
for v in 모든 노드:
	if v가 u의 이웃이면:
		D(v) = c(u, v)
	else:
		D(v) = infinity
		
# 루프:
1. N'에 속하지 않는 w 중에서 D(w)가 최소인 w를 찾는다
2. w를 N'에 추가한다
3. w의 모든 이웃 중 N'에 속하지 않은 이웃 v들의 비용을 갱신한다:
	D(v) = min(D(v), D(w) + c(w, v))
# v에 대한 새 비용은 v에 대한 기존 비용이거나 w에 대한 알려진 최소 경로 비용에 w에서 v까지의 비용을 더한 값이다		
```

### 예시
![[network_graph_example.png ]]
u에서 다른 모든 노드들까지의 최소 비용 경로를 계산해보자.
#### 초기화
- N' = {u}
- u에서 직접 연결된 이웃 노드인 v, x, w까지의 최소 비용은 2, 1, 5로 초기화된다.
- u와 직접 연결되지 않은 y, z까지의 비용은 무한대로 초기화된다.

| N'에 포함되지 않은 이웃 노드(node') | 기존 비용(D(node')) | 직전 노드(p(node')) |
| ------------------------ | --------------- | --------------- |
| v                        | 2               | u               |
| x                        | 1               | u               |
| w                        | 5               | u               |
#### 첫 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 x다.
- N' = {u, x}
- x의 이웃 중 N'에 포함되지 않은 v, w, y까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| v                                | 2               | 1 + 2 = 3                        | 2                | u               |
| w                                | 5               | 1 + 3 = 4                        | 4                | x               |
| y                                | inf             | 1 + 1 = 2                        | 2                | x               |
#### 두 번째 루프
- N'에 포함되지 않은 노드 중 비용(D(node))이 가장 작은 노드는 v, y다.
- N' = {u, x, y} (임의로 y 추가)
- y의 이웃 중 N'에 포함되지 않은 w, z까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| w                                | 4               | 2 + 1 = 3                        | 3                | y               |
| z                                | inf             | 2 + 2 = 4                        | 4                | y               |
#### 세 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 v다.
- N' = {u, x, y, v}
- v의 이웃 중 N'에 포함되지 않은 w까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| w                                | 3               | 2 + 3 = 5                        | 3                | y               |
#### 네 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 w다.
- N' = {u, x, y, v, w}
- w의 이웃 중 N'에 포함되지 않은 z까지의 비용을 갱신한다.

| node의 이웃 중 N'에 포함되지 않은 노드(node') | 기존 비용(D(node')) | 새로운 비용(D(node) + c(node, node')) | 갱신된 비용(D(node')) | 직전 노드(p(node')) |
| -------------------------------- | --------------- | -------------------------------- | ---------------- | --------------- |
| z                                | 4               | 3 + 5 = 8                        | 4                | y               
#### 다섯 번째 루프
- N'에 포함되지 않은 노드 중 비용이 가장 작은 노드는 z다.
- N' = {u, x, y, v, w, z}
- z의 이웃 중 N'에 포함되지 않은 노드는 없으므로 루프는 종료된다.
#### 표
| 루프  | N'               | D(v), p(v) | D(w), p(w) | D(x), p(x) | D(y), p(y) | D(z), p(z) |
| --- | ---------------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| 0   | u                | 2, u       | 5, u       | 1, u       | inf        | inf        |
| 1   | u, x             | 2, u       | 4, x       |            | 2, x       | inf        |
| 2   | u, x, y          | 2, u       | 3, y       |            |            | 4, y       |
| 3   | u, x, y, v       |            | 3, y       |            |            | 4, y       |
| 4   | u, x, y, v, w    |            |            |            |            | 4, y       |
| 5   | u, x, y, v, w, z |            |            |            |            |            |
### 계산 복잡도
다익스트라 알고리즘의 계산 복잡도는 $n$개의 노드가 있을 때, 단순 구현 시 $O(n^2)$이다. 힙(heap) 자료구조를 사용하면 복잡도를 줄일 수 있다.
## 진동 현상(Oscillation)
링크 비용이 트래픽 양(부하)에 따라 변하는 경우, 진동(oscillation)이라는 병리 현상이 발생할 수 있다. 
![[oscillations_with_congestion-sensitive_routing.png]]

모든 라우터가 동시에 라우팅 알고리즘을 실행하고 트래픽을 특정 경로로 몰면, 해당 경로의 비용이 급증하고 다음 계산에서는 다른 경로가 선택된다. 이러한 과정이 반복되면서 **경로가 계속 바뀌게 된다**. 이를 방지하기 위해 모든 라우터가 동시에 알고리즘을 실행하지 않도록 하거나, 각 라우터가 링크 상태 정보를 보내는 시간을 무작위로 설정하는 방법이 있다.
# 거리 벡터(Distance-Vector, DV) 알고리즘
LS 알고리즘이 전역 정보를 사용하는 알고리즘인 반면, 거리 벡터(Distance-Vector, DV) 알고리즘은 **반복적(iterative), 비동기적(asynchronous), 분산적(distributed)** 이다.
- **분산적**: 각 노드는 자신의 직접 연결된 이웃 중 하나 이상으로부터 정보를 받고, 계산을 수행한 후, 그 계산 결과를 다시 이웃에게 배포한다.
- **반복적**: 이 과정은 이웃 간에 더 이상 정보가 교환되지 않을 때까지 계속된다. 이 알고리즘은 계산을 중단하라는 신호 없이 스스로 종료된다.
- **비동기적**: 모든 노드가 서로 보조를 맞추어 작동할 필요가 없다.
## 벨만-포드 방정식 (Bellman-Ford Equation)
