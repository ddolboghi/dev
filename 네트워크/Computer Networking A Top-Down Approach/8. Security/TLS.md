# TLS의 필요성
향수 판매 사이트에서 Bob이 물건을 구매하는 상황을 가정해보자. Bob은 주문 양식에 신용카드 번호와 주소를 입력한다. 만약 보안 조치가 없다면 다음과 같은 문제가 발생할 수 있다.
- 기밀성 부재: 침입자가 Bob의 주문을 가로채 결제 정보를 획득하고 이를 도용할 수 있다.
- 데이터 무결성 부재: 침입자가 Bob의 주문 내용을 수정하여 의도하지 않은 수량을 구매하게 만들 수 있다.
- 서버 인증 부재: 침입자가 향수 판매 사이트를 가장한 가짜 사이트를 운영하여 Bob의 정보를 탈취하거나 금전적 피해를 입힐 수 있다.

TLS는 기밀성, 데이터 무결성, 서버 인증 및 클라이언트 인증을 제공하여 이러한 문제를 해결하고 TCP를 강화한다.
# TLS의 위치와 API
- TLS는 HTTP뿐만 아니라 TCP 위에서 실행되는 모든 애플리케이션에서 사용할 수 있다.
- TLS는 TCP의 소켓 API와 유사한 간단한 API를 제공한다.
- TLS는 애플리케이션 계층(L7)에 위치한다.
- 애플리케이션이 TLS를 사용하려면 SSL 클래스나 라이브러리를 포함해야 한다.
- 애플리케이션 데이터는 TCP로 전달되기 전에 TLS 하위 계층(TLS sublayer)을 통과하며 보안 처리가 이루어진다.
	![[tsl_in_application_layer.png]]
# 간단한 TLS의 작동 원리
## 1. handshake
클라이언트와 서버가 통신하는 과정은 다음과 같다.
1. TCP 연결 수립
2. 인증 및 마스터 시크릿 생성:
	- 클라이언트는 서버에게 hello 메시지를 보낸다.
	- 서버는 자신의 공개 키가 포함된 인증서를 클라이언트에게 보낸다.
	- 클라이언트는 인증서를 통해 서버를 검증한 후, 이번 세션에서만 사용할 **마스터 시크릿(Master Secret, MS)** 을 생성한다.
	- 클라이언트는 서버의 공개 키로 MS를 암호화하여 **암호화된 마스터 시크릿(EMS)** 을 서버에게 보낸다.
	- 서버는 자신의 개인 키로 EMS를 복호화하여 MS를 획득한다.
![[TLS_handshake.png]]

## 2. key derivation(키 파생)
보안을 위해 MS를 직접 사용하는 대신, MS를 사용하여 4개의 세션 키를 생성하여 사용한다.
- $E_B$: 클라이언트에서 서버로 가는 데이터의 암호화 키
- $M_B$: 클라이언트에서 서버로 가는 데이터의 HMAC(무결성 검증) 키
- $E_A$: 서버에서 클라이언트로 가는 데이터의 암호화 키
- $M_A$: 서버에서 클라이언트로 가는 데이터의 HMAC 키

## 3. 데이터 전송
TCP는 바이트 스트림 프로토콜이므로, TLS는 데이터를 **레코드(record)** 단위로 쪼개어 처리한다.

1. 데이터 무결성을 위해 각 레코드에 HMAC을 덧붙인다. HMAC은 레코드의 데이터 필드와 키 $M_B$를 해시 함수에 넣어 생성한다.    
2. 레코드와 HMAC을 합친 패키지를 세션 암호화 키 $E_B$로 암호화한다.
3. 암호화된 패키지를 TCP를 통해 전송한다.
### 순서 번호(sequence number)를 이용한 중간자 공격 방지
- 단순히 데이터를 암호화하고 HMAC을 붙이는 것만으로는 중간자가 세그먼트의 순서를 바꾸거나, 삭제하거나, 다시 전송하는(replay) 공격을 막을 수 없다.
- 클라이언트는 0부터 시작하는 sequence number 카운터를 유지하며, 각 TLS 레코드마다 이를 증가시킨다.
- sequence number는 레코드에 직접 포함되어 전송되지 않으며, 대신 HMAC을 계산할 때 포함된다.
- 서버도 클라이언트의 sequence number를 추적하고 있으므로, HMAC 계산 시 해당 번호를 포함하여 무결성을 검증한다.
- 중간자가 세그먼트 순서를 바꾸거나 재전송할 경우, HMAC 검증이 실패하게 만들어 공격을 방어한다.
### TLS 레코드 포맷
![[TLS_record_format.png]]
- **Type**: 레코드가 핸드셰이크 메시지인지 애플리케이션 데이터인지, 또는 연결 종료 메시지인지를 나타낸다.
- **Version**: TLS 버전을 나타낸다.
- **Length**: 수신 측에서 TCP 스트림으로부터 TLS 레코드를 추출하는 데 사용된다.
- **Data**: 애플리케이션 데이터.
- **HMAC**: 무결성 검증 코드. 이 중 Data와 HMAC 필드는 암호화되지만, Type, Version, Length 필드는 암호화되지 않는다.

# 실제 TLS 동작 방식
## TLS handshake 상세 과정
1. **알고리즘 제안**: 클라이언트는 자신이 지원하는 암호화 알고리즘 목록과 **클라이언트 nonce**를 서버에 보낸다.
- **알고리즘 선택 및 인증서 전송**: 서버는 목록에서 대칭 키 알고리즘(e.g. AES), 공개 키 알고리즘(e.g. RSA), HMAC 알고리즘(e.g. SHA-1) 등을 선택한다. 그리고 자신의 선택 결과와 함께 인증서, **서버 nonce**를 클라이언트에 보낸다.
- **Pre-Master Secret(PMS) 전송**: 클라이언트는 인증서를 검증하고 서버의 공개 키를 추출한다. 그리고 **PMS**를 생성하여 서버의 공개 키로 암호화한 뒤 서버에 전송한다.
- **Master Secret 계산**: 클라이언트와 서버는 PMS와 교환된 nonce들을 사용하여 독립적으로 **MS**를 계산한다. 이 MS로부터 2개의 암호화 키와 2개의 HMAC 키를 생성한다. CBC 방식의 대칭 암호를 사용할 경우 2개의 초기화 벡터(IV)도 함께 생성한다. 이후 모든 메시지는 암호화되고 인증된다.
    
- **핸드셰이크 무결성 확인:**
    
    - 클라이언트는 모든 핸드셰이크 메시지의 HMAC을 전송한다.
        
    - 서버도 모든 핸드셰이크 메시지의 HMAC을 전송한다.