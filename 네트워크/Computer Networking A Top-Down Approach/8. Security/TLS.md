# TLS의 필요성
향수 판매 사이트에서 Bob이 물건을 구매하는 상황을 가정해보자. Bob은 주문 양식에 신용카드 번호와 주소를 입력한다. 만약 보안 조치가 없다면 다음과 같은 문제가 발생할 수 있다.
- 기밀성 부재: 침입자가 Bob의 주문을 가로채 결제 정보를 획득하고 이를 도용할 수 있다.
- 데이터 무결성 부재: 침입자가 Bob의 주문 내용을 수정하여 의도하지 않은 수량을 구매하게 만들 수 있다.
- 서버 인증 부재: 침입자가 향수 판매 사이트를 가장한 가짜 사이트를 운영하여 Bob의 정보를 탈취하거나 금전적 피해를 입힐 수 있다.

TLS는 기밀성, 데이터 무결성, 서버 인증 및 클라이언트 인증을 제공하여 이러한 문제를 해결하고 TCP를 강화한다.
# TLS의 위치와 API
- TLS는 HTTP뿐만 아니라 TCP 위에서 실행되는 모든 애플리케이션에서 사용할 수 있다.
- TLS는 TCP의 소켓 API와 유사한 간단한 API를 제공한다.
- TLS는 애플리케이션 계층(L7)에 위치한다.
- 애플리케이션이 TLS를 사용하려면 SSL 클래스나 라이브러리를 포함해야 한다.
- 애플리케이션 데이터는 TCP로 전달되기 전에 TLS 하위 계층(TLS sublayer)을 통과하며 보안 처리가 이루어진다.
	![[tsl_in_application_layer.png]]
# TLS의 작동 원리
## 1. handshake
클라이언트와 서버가 통신하는 과정은 다음과 같다.
1. TCP 연결 수립
2. 인증 및 마스터 시크릿 생성:
	- 클라이언트는 서버에게 hello 메시지를 보낸다.
	- 서버는 자신의 공개 키가 포함된 인증서를 클라이언트에게 보낸다.
	- 클라이언트는 인증서를 통해 서버를 검증한 후, 이번 세션에서만 사용할 **마스터 시크릿(Master Secret, MS)** 을 생성한다.
	- 클라이언트는 서버의 공개 키로 MS를 암호화하여 **암호화된 마스터 시크릿(EMS)** 을 서버에게 보낸다.
	- 서버는 자신의 개인 키로 EMS를 복호화하여 MS를 획득한다.
![[TLS_handshake.png]]

## 2. key derivation(키 파생)
보안을 위해 MS를 직접 사용하는 대신, MS를 사용하여 4개의 세션 키를 생성하여 사용한다.
- $E_B$: 클라이언트에서 서버로 가는 데이터의 암호화 키
- $M_B$: 클라이언트에서 서버로 가는 데이터의 HMAC(무결성 검증) 키
- $E_A$: 서버에서 클라이언트로 가는 데이터의 암호화 키
- $M_A$: 서버에서 클라이언트로 가는 데이터의 HMAC 키

## 3. 데이터 전송
TCP는 바이트 스트림 프로토콜이므로, TLS는 데이터를 **레코드(record)** 단위로 쪼개어 처리한다.

1. 데이터 무결성을 위해 각 레코드에 HMAC을 덧붙인다. HMAC은 레코드의 데이터 필드와 키 $M_B$를 해시 함수에 넣어 생성한다.    
2. 레코드와 HMAC을 합친 패키지를 세션 암호화 키 $E_B$로 암호화한다.
3. 암호화된 패키지를 TCP를 통해 전송한다.
### 순서 번호(sequence number)를 이용한 중간자 공격 방지
- 단순히 데이터를 암호화하고 HMAC을 붙이는 것만으로는 중간자가 세그먼트의 순서를 바꾸거나, 삭제하거나, 다시 전송하는(replay) 공격을 막을 수 없다.
- 클라이언트는 0