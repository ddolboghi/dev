- 엔드포인트 인증 프로토콜은 일반적으로 두 통신 개체가 다른 프로토콜을 실행하기 전에 먼저 실행된다.
# Authentication Protocol 1.0
- 가장 단순한 인증 프로토콜은 송신자가 수신자에게 단순히 **"내가 {송신자}다."라는 메시지를 보내**는 것이다.
- 이 방식은 공격자도 똑같은 메시지를 보낼 수 있어 매우 취약하다.
# Authentication Protocol 2.0
- 송신자가 자신의 **네트워크 주소**(e.g. IP 주소)를 갖고 있다면, 수신자는 데이터그램의 소스 주소가 송신자의 주소와 일치하는지 확인하여 인증한다.
- IP spoofing: 공격자는 IP 데이터그램을 생성하고 소스 주소를 송신자의 IP 주소로 설정하여 보낼 수 있다.
# Authentication Protocol 3.0
- 송신자가 수신자에게 **비밀번호**를 보낸다.
- 공격자가 송신자의 통신을 도청하여 비밀번호를 알아낼 수 있다.
	- telnet 연결 시 로그인 비밀번호는 암호화되지 않은 상태로 전송되므로, 패킷 스니퍼를 이용해 이를 훔쳐볼 수 있다.
# Authentication Protocol 3.1
- **대칭키 암호화**를 이용한 인증 프로토콜이다.
- 송신자가 비밀키로 비밀번호를 암호화하여 보내면, 수신자는 공유하는 비밀키로 복호화하여 인증한다.
- playback attack: 공격자가 송신자의 통신을 도청하여 암호화된 비밀번호를 알아내어(녹음) 수신자에게 이를 그대로 보낼 수 있다.
- 수신자는 송신자가 현재 실제로 연결되어 있는지, 이전 인증의 녹화된 재생인지 알 수 없다.
# Authentication Protocol 4.0
- 프로토콜 라이플사이클 동안 단 한 번만 사용되는 숫자인 **nonce**를 사용한다.

1. 송신자는 수신자에게 "나는 {송신자}다"라는 메시지를 보낸다.
2. 수신자는 nonce $R$을 선택하여 송신자에게 보낸다.
3. 수신자는 대칭 비밀키를 사용하여 nonce를 암호화하고, 암호화된 nonce를 수신자에게 보낸다.
4. 수신자는 받은 메시지를 복호화하고, 복호화된 nonce가 $R$과 같다면 송신자가 인증된다.

- 수신자는 한 번만 사용되는 값 $R$을 송신자가 비밀키로 암호화하여 보냈다는 사실을 확인함으로써, 상대방이 비밀키를 알고 있는 송신자임과 동시에 현재 실제로 활동 중(live)임을 확신할 수 있다.
- 이 방식은 playback attack을 방지한다.