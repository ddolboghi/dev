# 암호화 시 공격 시나리오
- **암호문 단독 공격**: 침입자가 암호문함 가지고 있는 경우다. 단일 문자 치환 암호의 경우 통계적 분석으로 암호문을 해독할 수 있다.
- **알려진 평문 공격**: 침입자가 암호문 내에 특정 단어가 포함되어 있음을 알거나, 과거의 평문과 그에 대응하는 암호문 쌍을 알고 있는 경우다.
- **선택 평문 공격**: 침입자가 특정 평문을 선택하여 그에 해당하는 암호문을 얻을 수 있는 경우다.
# 대칭키 암호화
- 송신자와 수신자가 동일한 비밀키를 공유하는 방식이다.
- 비밀키는 송신자와 수신자만 가지고 있어야 한다.
## 블록 암호(block cipher)
- 현대의 대칭키 암호화(e.g. PGP, SSL/TLS, IPsec)는 블록 암호를 사용한다.
- 블록 암호는 메시지를 k비트 단위의 블록으로 나누고 각 블록을 독립적으로 암호화한다.
- k비트 입력을 k비트 출력으로 1:1 매핑한다.
- 가능한 매핑의 수가 매우 많아 전체 테이블을 사용하는 것은 불가능하다.
- 임의로 순열된 테이블을 시뮬레이션하는 함수를 사용한다.
- DES(Data Encryption Standard), 3DES, AES(Advanced Encryption Standard)는 블록 암호다.
- AES는 128비트 블록을 사용하며 128, 192, 256비트 키로 작동할 수 있다.
## 암호 블록 체인(Cipher-Block Chaining)
- 같은 평문 블록이 항상 같은 암호문 블록으로 암호화되는 것을 방지하는 기술이다.
- 첫 번째 메시지와 함께 임의의 값인 초기화 벡터(Initialization Vector, IV)를 보내고, 이후 블록들은 계산된 코드 블록을 사용하여 연쇄적으로 암호화한다.

1. 송신자는 임의의 k비트 문자열인 IV를 생성하고 평문으로 보낸다.
2. 첫 번째 블록에 대해, 송신자는 평문 블록과 IV를 XOR 연산한 후 블록 암호 알고리즘을 통해 암호화한다.
3. i번째 블록에 대해, 송신자는 $c(i) = K_S(m(i) \oplus c(i-1))$을 계산한다.
4. 수신자는 IV와 $c(i-1)$을 알고 있으므로 $m(i) = K_S(c(i)) \oplus c(i-1)$을 통해 원본 평문을 복구할 수 있다.
# 공개키 암호화
- 송신자와 수신자가 비밀키를 공유하지 않는 방식이다.
- 송신자와 수신자는 공개키와 개인키 쌍을 가지며, 공개키로 암호화된 메시지는 오직 개인키로만 복호화할 수 있다.
- 수신자는 전 세계에 공개된 **공개키 ($K_B^+$)** 와 자신만 알고 있는 **개인키 ($K_B^-$)** 를 가진다. 송신자가 수신자에게 통신하려면 수신자의 공개키를 가져와 메시지 $m$을 $K_B^+(m)$으로 암호화한다. 송신자는 자신의 개인키로 $K_B^-(K_B^+(m))$을 계산하여 메시지를 복호화한다.
## RSA
- RSA 알고리즘은 모듈러 연산을 광범위하게 사용하는 공개키 암호화 방식이다.
- RSA 키 생성 과정:
	1. 둑