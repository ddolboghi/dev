---
chapter: "2"
---
# Network Application Architectures
## Client-Server Architecture
- 항상 켜져있는 서버라는 호스트가 클라이언트라고 불리는 다른 호스트들로부터 서비스 요청을 처리한다.
- 서버는 고정된, 잘 알려진 주소(IP 주소)를 가지고 있으며, 클라이언트는 이 IP 주소를 통해 서버에 접근할 수 있다.
- 클라이언트와 서버의 프로세스는 네트워크 애플리케이션 통신이 종단 시스템 간의 애플리케이션 계층에서 일어난다는 것을 보여준다.
- 대부분의 대규모 클라이언트-서버 애플리케이션은 데이터 센터라고 불리는 **대규모 서버 farm**을 사용한다.
## Peer-to-Peer Architecture
- 항상 켜져있는 전용 서버에 최소한으로 의존하는 대신, 애플리케이션은 간헐적으로 연결된 호스트 쌍 간의 직접적인 통신을 활용한다.
- 직접적인 통신을 하는 호스트들을 peer라고 부른다.
- peer는 사용자의 개인 컴퓨터이며, 다양한 장소에서 제어되는 경우가 많다.
- peer 간의 직접 통신은 매우 비용 효율적이다.
- P2P 아키텍처의 **자가 확장성**: peer가 콘텐츠를 요구하는 동시에 다른 peer에게 콘텐츠를 제공하여 시스템 용량을 추가한다.
- P2P 아키텍처는 peer가 간헐적으로 연결되어 IP 주소가 변경될 수 있기 때문에 관리하기 복잡하다.
# 프로세스 통신
## 프로세스
- 네트워크 애플리케이션의 컨텍스트에서, 호스트에서 실행되는 프로그램을 프로세스라고 부른다.
- **네트워크 애플리케이션에서 실제로 통신하는 것은 프로세스**이며, 프로세스는 동일한 종단 시스템에서 실행될 수도 있고 다른 종단 시스템에서 실행될 수도 있다.
- 동일한 종단 시스템에서 두 프로세스가 통신하는 것은 운영체제에 의해 관리되며, 프로세스 간 통신 규칙을 통해 이뤄진다.
- 다른 종단 시스템에서 실행되는 프로세스 간의 통신은 메시지를 교환하여 이뤄진다.
- 송신 프로세스는 메시지를 **socket**으로 보내고, 수신 프로세스는 메시지를 socket으로부터 받는다.
## Socket
- 소켓은 네트워크에서 프로세스가 메시지를 보내거나 받는 소프트웨어 인터페이스다.
- **프로세스에서 네트워크로 비트를 전달하는 문과 같은 역할**을 한다.
- 애플리케이션 개발자는 소켓에 대한 완전한 통제권을 가지므로 소켓의 양 끝에서 애플리케이션이 어떻게 행동하는지 결정할 수 있다.
- 메시지가 소켓을 떠나 다른 호스트의 소켓으로 도착하기 전에 발생하는 네트워크 내부의 모든 과정(라우터, 링크 등)은 애플리케이션 개발자의 통제 밖에 있다.
- 애플리케이션 프로세스는 socket interface를 통해 네트워크로부터 제공되는 전송 계층에 접근한다.
![[socket_interface.png]]
- 소켓 인터페이스는 소켓이 데이터를 보내고 받는 방법에 대한 규칙 세트다.
- 인터넷 소켓 인터페이스는 발신 프로그램이 인터넷이 데이터를 수신 프로그램에 전달하기 위해 따라야 하는 규칙 세트를 지정한다.
- 인터넷은 애플리케이션에 여러 서비스를 제공하며, 인터넷 애플리케이션을 개발할때 애플리케이션에 대한 인터넷 서비스 중 하나를 선택해야 한다.
## 주소 지정
- 메시지를 수신하는 프로세스를 식별하기 위해, 수신 호스트의 **IP 주소**와 **Port 번호**가 필요하다.
- IP 주소는 32bit 값으로, 호스트를 고유하게 식별한다. 이 주소는 점선 십진법 표기법(예: 127.7.106.83)으로 표시된다.
- 목적지 호스트에서 프로세스를 식별하기 위해 포트 번호가 사용된다.
# 애플리케이션에서 사용할 수 있는 Transport 서비스
- 애플리케이션은 전송 계층 프로토콜을 사용하여 다른 종단 시스템에서 실행되는 애플리케이션 프로세스와 메시지를 교환한다.
- 전송 계층 프로토콜은 프로세스 간의 논리적 통신을 제공하며, 네트워크 게층 프로토콜은 호스트 간의 논리적 통신을 제공한다.
- 애플리케이션은 다양한 전송 계층 서비스를 사용할 수 있다.
## 전송 계층 프로토콜의 4가지 특성
### 신뢰적 데이터 전송
- 프로토콜이 송신 프로세스가 보낸 모든 데이터가 수신 프로세스로 오류 없이 도착하는 것을 보장하는지 여부다.
### 처리량
- 전송 계층 프로토콜이 애플리케이션에 제공할 수 있는 처리량과 이것이 가변적이거나 보장되는지 여부다.
- 처리량은 송신 프로세스가 수신 프로세스에 데이터를 전달할 수 있는 속도다.
- 멀티미디어 애플리케이션 같은 경우 특정 최소 처리량으로 데이터를 전송할 수 있는 보장된 처리량 서비스를 요구할 수 있다.
### 타이밍
- 데이터가 송신 프로세스에서 수신 프로세스로 전달되는데 걸리는 시간이다.
- 인터넷 전화 같은 애플리케이션은 엄격한 타이밍 보장을 요구하며, 데이터가 도착에 큰 지연이 발생하면 안된다.
### 보안
- 전송 계층 프로토콜이 애플리케이션에 제공할 수 있는 보안 기능이다.
- 데이터의 암호화, 데이터 무결성 및 종단점 인증 같은 서비스를 제공할 수 있다.
# 인터넷이 제공하는 Transport 서비스
## TCP (Transmission Control Protocol)
### 연결 지향형 서비스
- 애플리케이션 계층 메시지를 보내기 전에 TCP 클라이언트와 서버는 서로 handshaking을 한다.
- handshaking으로 클라이언트와 서버가 서로 준비되었다는 것을 알려주고, 매개변수를 교환한다.
- 통신이 끝날때 양쪽은 연결을 해제하기 위해 handshaking을 다시 수행한다.
### 신뢰적 데이터 전송 서비스
- 발신 프로세스가 보낸 바이트가 수신 프로세스에 오류 없이 순서대로 전달되도록 한다.
- 손실된 바이트를 재전송하고, 순서가 뒤바뀐 바이트를 재정렬하며, 중복 바이트를 폐기한다.
### 흐름 제어
- 송신자가 너무 많은 데이터를 너무 빨리 전송하여 수신자의 버퍼를 오버플로우시키는 것을 방지한다.
- TCP 혼잡 제어 메커니즘은 전송 프로세스(클라이언트 또는서버) 네트워크가 혼잡할 때 발신자와 수신자 간의 트래픽을 조절한다.
- TCP 혼잡 제어는 각 TCP 연결이 네트워크 대역폭을 공정하게 공유하도록 제한하려고 시도한다.
## UDP (User Datagram Protocol)
- 최소한의 서비스를 제공하는 간결하고 가벼운 전송 프로토콜이다.
- 신뢰성, 흐름 제어, 혼잡 제어를 제공하지 않는다.
- 인터넷 전화 같은 애플리케이션은 많은 방화벽들이 UDP 트래픽을 차단하기 때문에 UDP 통신이 실패 시 TCP를 사용하도록 한다.
### 비연결형 서비스
- handshaking이 없다.
### 비신뢰적 데이터 전송 서비스
- 수신 프로세스에 대한 데이터 전달을 보장하지 않으며, 데이터의 순서도 보장하지 않는다.

> [!tip]
>  ### TLS (Transport Layer Security)
    > - TLS 는 TCP, UDP와 같은 전송 계층에 해당하며, 암호화, 데이터 무결성, 종단 인증을 제공한다.
    > - 애플리케이션은 라이브러리 등에서 제공하는 TLS 코드로 TLS 서비스를 사용할 수 있다.
    > - TLS는 TCP socket API와 비슷한 socket API를 가진다.
    > 1. 송신 프로세스가 TLS socket으로 평문 데이터를 보내면 TLS는 데이터를 암호화하여 TCP socket에 전달한다.
    > 2. 암호화된 데이터는 인터넷을 지나 수신 프로세스의 TCP socket으로 향한다.
    > 3. 수신 socket은 암호화된 데이터를 TLS에 전달하여 복호화한다.
    > 4. TLS는 TLS socket을 통해 평문 데이터를 수신 프로세스에 전달한다.

## Application-Layer Protocols
- 애플리케이션 계층 프로토콜은 애플리케이션 프로세스들이 어떻게 서로 메시지를 전달하는지 정의한다.
- 애플리케이션 계층에서 정의하는 것:
	- 교환되는 메시지 타입: 요청 메시지인지 응답 메시지인지
	- 메시지 타입의 문법: 메시지의 필드와 필드를 어떻게 작성하는지
	- 필드의 문장: 필드의 정보가 무엇을 의미하는지
	- 프로세스가 언제, 어떻게 메시지를 주고 받을지 결정하는 규칙
- 다른 많은 애플리케이션 계층 프로토콜은 독점적이며 공개 도메인에서는 의도적으로 사용할 수 없다. 예를 들어, Skype는 독점적인 애플리케이션 계층 프로토콜을 사용한다.
- 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 조각이다.

# Web과 HTTP
- HTTP는 브라우저와 웹 서버 간에 교환되는 메시지의 형식과 순서를 정의한다.
- 웹 페이지는 객체(objects)로 구성된다.
- 객체는 단일 URL로 주소 지정이 가능한 파일을 의미하며, HTML파일, JPEG 이미지, JavaScript 파일, CSS 파일 또는 비디오 클립 등이 있다.
- 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조된 객체로 구성된다.
## HTTP (HyperText Transfer Protocol)
### URL 구성 요소
- 기본 HTML 파일은 해당 객체들의 URL을 통해 페이지 내 다른 객체들을 참조한다.
- **URL은 객체를 소유한 서버의 호스트 이름과 객체의 경로명으로 구성**된다.
	- 예를 들어, http://www.someSchool.edu/someDepartment/picture.gif라는 URL에서 www.someSchool.edu는 호스트 이름이고, /someDepartment/picture.gif는 경로명
- 웹 브라우저는 HTTP의 클라이언트 측을 구현한다.
- 웹 서버는 HTTP의 서버 측을 구현하며, URL로 주소 지정이 가능한 웹 객체들을 저장한다.
### HTTP의 작동 방식
- HTTP는 클라이언트가 웹 서버에 웹 페이지를 요청하는 방식과 서버가 웹 페이지를 클라이언트에게 전송하는 방식을 정의한다.
- 브라우저가 웹 페이지 내의 객체들에 대한 HTTP 요청 메시지를 서버로 보내면, 서버는 이 요청을 받아 객체를 포함하는 HTTP 응답 메시지로 응답한다.
### HTTP와 TCP의 관계
- **HTTP는 TCP를 기본 전송 프로토콜로 사용**한다. UDP 위에서 실행되지 않는다.
- 계층형 아키텍처 덕분에, HTTP는 TCP가 네트워크 내에서 데이터 손실 또는 순서를 어떻게 복구하는지에 대한 세부 사항을 고려지 않아도 된다. 이는 TCP와 하위 계층 프로토콜의 역할이다.
1. 클라이언트는 먼저 서버와 TCP 연결을 시작한다.
2. 연결이 설정되면 브라우저와 서버 프로세스는 각자의 소켓 인터페이스를 통해 TCP에 접근한다.
	- 클라이언트 측 소켓 인터페이스는 클라이언트 프로세스와 TCP 연결 사이의 문이며, 서버 측에서는 서버 프로세스와 TCP 연결 사이의 문이다.
3. 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 소켓 인터페이스로부터 HTTP 응답 메시를 받는다.
4. 서버는 소켓 인터페이스로부터 요청 메시지를 받고 응답 메시지를 소켓 인터페이스로 보낸다.
5. 클라이언트가 소켓 인터페이스로 요청 메시지를 보내면 메시지는 TCP를 통해 전달된다. 서버의 응답 메지도 마찬가지다.
6. TCP는 HTTP에 신뢰할 수 있는 데이터 전송 서비스를 제공하여 메시지가 목적지에 손상 없이 도착하도록 한다.

## 비영구 연결
- HTTP/1.0은 비영구 TCP 연결(non-persistent TCP connections)을 사용한다.
- 비영구 연결에서는 **서버가 응답을 보낸 후 TCP 연결을 닫는다.**
- **한 개의 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만을 전송**한다.
- **RTT(Round-Trip Time)** 은 작은 패킷이 클라이언트에서 서버로 이동했다가 다시 클라이언트로 돌아오는데 걸리는 시간이다.
- RTT는 패킷 전파 지연, 중간 라우터 및 스위치에서의 패킷 대기 지연, 패킷 처리 지연을 포함한다.
- TCP 연결을 시작하면 3-way handshake를 하는데, 
	1. 클라이언트가 서버로 작은 TCP 세그먼트를 보내고
	2. 서버가 승인 및 작은 TCP 세그먼트로 응답하며
	3. 마지막으로 클라이언트가 서버로 다시 승인과 함께 요청 메시지를 보낸다.
- **3-way handshake에서 1, 2단계에 1RTT가 소요**되고, **3단계에서 서버의 응답 메시지를 받을때까지 1RTT가 소요**된다.
![[http_round_trip_time_example.png | 500]]
## 영구 연결
- **HTTP/1.1 영구 연결을 사용하면 서버는 응답을 보낸 후에도 TCP 연결을 열어둔다.**
- HTTP/1.1은 단일 TCP 연결을 통해 서버의 소켓 수를 줄이고 각 전송되는 웹 페이지가 네트워크 대역폭을 공평하게 분배받을 수 있도록 한다.
- 동일한 클라이언트와 서버 간, 이어지는 요청 및 응답은 열어둔 동일한 TCP 연결을 통해 전송될 수 있다.
- 동일한 서버에 있는 여러 웹 페이지도 단일 영구 TCP 연결을 통해 동일한 클라이언트로 전송될 수 있다.
- 보류 중인 요청에 대한 응답을 기다리지 않고 연속적으로(파이프라이닝) 이뤄질 수 있다.
- 일반적으로 HTTP 서버는 특정 시간(time out) 동안 사용되지 않으면 연결을 닫는다.
- HTTP의 기본 모드는 파이프라이닝을 포함하는 영구 연결을 사용한다.
- 비영구 연결과 영구 연결의 성능 비교는 다음을 참고: Heidemann 1997; Nielsen 1997; RFC 7540
## Head-of-Line (HOL) Blocking
- 단일 TCP 연결로 웹 페이지의 모든 객체를 전송하면 HOL blocking 문제를 일으킨다.
- 예를 들어, 웹 페이지에 HTML 기본 페이지, 웹 페이지 상단 근처의 대형 비디오 클립, 그리고 비디오 아래의 많은 작은 객체들이 포함되어 있으며, 서버와 클라이언트 사이의 경로에 저속 병목 링크가 있다고 가정해보자. 단일 TCP 연결을 사용하면 비디오 클립이 병목 링크를 통과하는데 오랜 시간이 걸리는 동안, 작은 객체들은 비디오 클립 뒤에서 기다리면서 지연된다. 즉, "줄의 맨 앞"(Head-of-Line)에 있는 비오 클립이 그 뒤에 있는 작은 객체들을 block한다.
- HTTP/1.1 브라우저는 일반적으로 **여러 개의 병렬 TCP 연결을 열어** HOL Blocking 문제를 해결한다. 그면 작은 객체들은 브라우저에 훨씬 더 빠르게 도착하여 렌더링 될 수 있으며, 이는 사용자 인식 지연을 줄여준다.
# HTTP 메시지 형식
## HTTP 요청 메시지
- 요청 메시지는 ASCII텍스트로 작성되어 사람이 읽을 수 있다.
- 첫번째 줄은 **request line**이라고 불리며, **메서드(GET, POST 등)**, **URL**, **HTTP 버전**가 있다.
- 그 뒤의 줄들은 **header line**이라고 불린다:
	```
	# 예시
	GET /somedir/page.html HTTP/1.1
	Host: www.someschool.edu
	Connection: close
	User-agent: Mozilla/5.0
	Accept-language: fr
	```
- **Host**: 객체가 존재하는 호스트를 지정한다. 이 정보는 web proxy caches에 필요하다.
- **Connection**: "close"는 클라이언트가 영구 연결을 원하지 않으며, 요청된 객체를 보낸 후 서버가 연결을 닫도록 요청하는 것임을 서버에게 알린다.
- **User-agent**: 서버에 요청을 보내는 클라이언트 유형이다. 서버가 동일한 객체의 다른 버전을 다른 유형의 클라이언트에게 보낼때 유용하다.
- **Accept-language**: 사용자가 선호하는 버전의 객체다. 서버에 해당 객체가 없으면 기본 버전을 보내야 한다.
	
- header line 뒤에는 빈 줄과 entity body가 있을 수 있다.
	![[http_request_message.png]]
## HTTP 응답 메시지
- 일반적으로 status line, 여러 header line, entity body로 구성된다.
- 첫번째 줄인 **status line**은 **프로토콜 버전**(HTTP/1.1), **HTTP Status**(200), **해당 상태 메시지**(OK)로 구성된다.
- header line 예시:
	```
		HTTP/1.1 200 OK
		Connection: close
		Date: Tue, 18 Aug 2015 15:44:04 GMT
		Server: Apache/2.2.3 (CentOS)
		Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
		Content-Length: 6821
		Content-Type: text/html
		(data data data data data ...)
	```
- **Connection**: "close"값은 서버가 메시지를 보낸 후 TCP 연결을 닫을 것임을 클라이언트에 알린다.
- **Date**: 응답이 서버에 의해 생성 및 전송된 시간과 날짜를 나타낸다.
- **Server**: 응답이 생성된 서버 유형을 나타낸다.
- **Last-Modified**: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다. 객체 캐싱에 중요하다.
- **Content-Length**: 객체의 바이트 수를 나타낸다.
- **Content-Type**: 객체의 타입을 나타낸다.

![[http_response_message.png]]

> [!NOTE]
    > HTTP header line은 브라우저, 웹 서버, 네트워크 캐시 서버 등에 의해서 더 많이 추가될 수 있다.

## Cookies
쿠키 기술은 4가지 구성 요소로 이루어져 있다:
1. HTTP 응답 메시지의 **Set-Cookie** 헤더 라인
2. HTTP 요청 메시지의 **Cookie** 헤더라인
3. 클라이언트에 의해 관리되는 사용자 엔드 시스템에 보관된 쿠키 파일
4. 웹사이트의 백엔드 데이터베이스
### 쿠키 작동 방식 예시
1. 사용자가 특정 웹사이트를 처음 방문하여 사용자 ID를 제공한다
2. 이 웹사이트의 서버는 데이터베이스에 사용자의 ID와 함께 임의로 생성된 식별 번호를 저장한다.
3. 이 식별 번호는 HTTP 응답 메시지의 Set-cookie 헤더에 포함되어 클라이언트로 전송된다.
4. 클라이언트는 Set-cookie 헤더를 수신하면 식별 번호와 웹사이트의 호스트 이름을 쿠키 파일에 추가한다.
5. 이후 사용자가 동일한 웹사이트에 방문할때마다 클라이언트는 쿠키 파일에서 웹사이트의 호스트 이름을 검색하고, 해당 호스트 이름의 식별 번호를 HTTP 요청 메시지의 Cookie 헤더에 포함하여 서버로 전송한다.
6. 서버는 이 Cookie 헤더를 수신하면 데이터베이스에서 식별 번호를 확인하여 사용자를 식별한다.
### 쿠키의 활용
- 쿠키는 **stateless HTTP 위에 사용자 세션 계층을 생성**하는데 사용될 수 있다.
- 브라우저는 서버에 쿠키 정보를 보내 서버가 사용자 세션 내내 사용자를 식별할 수 있도록 한다.

## Web Caching
- 웹 캐시는 **프록시 서버**라고도 불리며, 원본 서버를 대신하여 HTTP 요청을 처리한다.
- 웹 캐시는 자체 디스크 저장 공간을 가지고 있으며, 최근 요청된 객체들의 복사본을 보관한다.
- 클라이언트는 모든 HTTP 요청이 먼저 웹 캐시로 향하도록 할 수 있다.
### Web Cache 작동 예시
1. 클라이언트가 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 복사본이 있는지 확인한다. 복사본이 있다면, 웹 캐시는 HTTP 응답 메시지에 복사본을 넣어 클라이언트로 보낸다.
3. 복사본이 없다면, 웹 캐시는 원본 서버와 TCP 연결을 열고 객체에 대한 HTTP 요청을 cashe-to-server TCP 연결로 보낸다. 서버가 요청을 받으면 객체를 HTTP 응답에 포함하여 웹 캐시로 보낸다.
4. 웹 캐시가 객체를 받으면, 로컬 스토리지에 복사본을 저장하고 HTTP 응답 메시지에 그 복사본을 넣어 1번의 TCP 연결을 통해 클라이언트로 보낸다.
### Web Cache 장점
- 클라이언트 요청에 대한 응답 시간 감소
	- 요청된 객체가 캐시의 가까운 위치에 저장되어 있어, 캐시에서 응답하는게 원본 서버에서 응답하는 것보다 훨씬 빠르다.
- 액세스 링크 트래픽 감소
	- 캐시가 원본 서버 대신 응답하면, 액세스 링크의 트래픽을 감소시켜 액세스 링크 대역폭을 업그레이드할 비용을 줄인다.
	- 전체 인터넷 트래픽을 감소시켜 모든 애플리케이션의 성능을 향상시킨다.
- CDN(Content Distribution Networks)을 통해 웹 캐시는 인터넷에서 매우 중요한 역할을 한다.
### 조건부 GET
- 웹 캐시가 최신 객체를 보유하고 있는지 확인하기 위해 조건부 GET 요청을 사용한다.
- 조건부 GET 요청은 HTTP 요청 메시지에 **If-Modified-Since** 헤더를 추가한다.
- 이 헤더에는 캐시가 객체의 복사본을 마지막으로 수정한 날짜가 포함된다.
	```
	GET /fruit/kiwi.gif HTTP/1.1
	Host: www.exotiquecuisine.com
	If-modified-since: Wed, 9 Sep 2015 09:23:24
	```
- 웹 서버는 조건부 GET 요청을 받으면, 요청된 객체가 If-Modified-Since 헤더에 명시된 날짜 이후로 수정되지 않았다면 HTTP 응답 메시지에 객체를 포함하지 않고 **304 Not Modified** 응답을 보낸다.
	```
	HTTP/1.1 304 Not Modified
	Date: Sat, 10 Oct 2015 15:39:29
	Server: Apache/1.3.0 (Unix)
	(empty entity body)
	```
- 304 Not Modified는 웹 캐시에 캐시된 오브젝트 복사본을 클라이언트에 전달할 수 있다고 알려준다.
- 웹 캐시가 304 응답을 받으면, 로컬에 저장된 객체를 클라이언트로 보낸다.
- 객체가 수정된 경우, 서버는 200 OK 응답과 함께 수정된 객체를 보낸다.
## HTTP/2
- HTTP/2는 단일 TCP 연결의 요청 및 응답 multiplexing을 통해 HOL blocking을 피하여 사용자의 인식 지연을 감소시킨다.
- 요청 우선순위 지정, 서버 푸쉬, 효율적인 HTTP 헤더 압축을 제공한다.
- HTTP/1.1의 HTTP 메서드, 상태 코드, URL, 헤더 필드를 그대로 사용하는 대신, 클라이언트와 서버 간 데이터 포맷팅과 데이터 변환 방법이 다르다. 
- HTTP/1.1은 HOL을 해결하기 위해 여러 개의 TCP 연결을 연다. 이 경우 TCP 혼잡 제어는  N개의 TCP 연결이 있다면, 각 TCP 연결에 링크의 대역폭을 1/N만큼 할당한다.
- HTTP/2는 오직 하나의 TCP 연결만 사용하여 서버의 socket 수를 줄이고, TCP 혼잡제어가 의도대로 작동하도록 한다.
### HTTP/2 Framing
- HTTP/2는 HOL blocking을 피하기 위해 메시지를 작은 프레임으로 쪼개고, 동일한 TCP 연결에 **번갈아 배치(interleave)** 시킨다. 그리고 목적지에서 쪼개진 프레임들을 재조립한다.
	- 예를 들어, 웹 페이지가 1000프레임짜리 비디오와 2프레임짜리 객체 8개로 이뤄지고, 모든 프레임들의 길이가 고정되있을때, 첫번째 비디오 프레임을 보낸 후, 각 객체의 첫번째 프레임을 보낸다. 그러므로 18 프레임을 보낸 후에야 2프레임짜리 객체들을 받을 수 있다.
- HTTP/2 프로토콜의 프레이밍 하위 계층에의해 프레이밍 작업이 이뤄진다.
-   


## DNS
- 로컬 DNS 서버는 서버의 계층 구조에 강하게 속하지 않지만 DNS 아키텍처의 중심이다.
- 각 ISP는 로컬 DNS 서버를 가지며, 이는 default name server 라고도 불린다.
- 호스트가 ISP에 연결되면, ISP는 호스트에게 로컬 DNS 서버들의 한 개 이상의 IP 주소들을 제공한다.
- 호스트의 로컬 DNS 서버는 보통 호스트와 물리적으로 가까운 곳에 있다.
- 호스트가 DNS 쿼리를 하면 프록시 역할을 하는 로컬 DNS 서버로 쿼리가 전송되며, 로컬 DNS 서버는 DNS 서버 계층 구조로 쿼리를 전달한다.
158p 끝에서 4번째 줄부터


프롬프트: 
```
다음 지침을 반드시 따르세요:

1. 아래에 나열된 각 chapter에 대해서, 해당 chapter 내용만 그대로 설명하세요.  
   - 요약하거나 간략화하지 마세요.  
   - 반드시 원문 흐름과 논리 전개를 최대한 충실하게 설명하세요.  
   - 단, 문장 구조나 표현은 독자가 이해하기 쉽도록 자연스럽게 풀어서 설명해도 됩니다.

2. 설명 시 반드시 다음 형식을 지켜 주세요:

   - 각 chapter마다 "**Chapter X.X.X**" 형태의 대제목(Heading)을 먼저 적으세요.
   - 그 chapter 내에 포함된 소제목(Section Title)과 하위 개념별로 "**소제목 이름**" 형태의 소제목 Heading을 만들어 구분하세요.
   - 하위 개념(절 또는 항목)마다 명확히 구분해서 서술하세요. 절대 내용을 한 덩어리로 합쳐서 설명하지 마세요.
   - 예시 형식:  

   ## Chapter 2.2.1  
   ### <Web Objects>  
   (내용)  
   ### <URL Components>  
   (내용)  
   ### <Round-Trip Time and Object Retrieval>
   (내용)

3. 설명 중에는 지정된 chapter 범위를 절대 넘기지 마세요.  
   - 예: "chapter 2.1.5"를 설명할 때 "chapter 2.1.6" 또는 "chapter 3.x.x" 내용 포함 금지.  
   - cross-reference (다른 chapter 내용 인용 및 설명) 금지.  
   - 단, 필요에 따라 관련성이 높은 다른 chapter를 언급할 수는 있지만, 그 경우에도 **그 chapter 번호만 짧게 언급**하고 절대 내용을 풀어서 설명하지 마세요.  
   - 예시: "이 내용과 관련된 추가 설명은 chapter 3.2.1에 있습니다."

4. 만약 해당 chapter에서 특정 Figure를 참고하거나 설명하고 있다면, 반드시 그 Figure 번호를 명시하세요.  
   - 예시: "이 내용은 Figure 1.18에 나와 있습니다."

5. 각 chapter의 설명이 끝날 때마다 반드시 다음 chapter의 설명으로 넘어가기 전에 **줄바꿈 및 제목 구분**을 명확히 하세요.

---

### 설명할 chapter들 목록:

- Chapter 2.3.1
- Chapter 2.3.2
- Chapter 2.3.3
- Chapter 2.4.1
```

