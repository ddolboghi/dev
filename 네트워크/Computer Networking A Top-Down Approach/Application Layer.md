---
chapter: "2"
---
# Network Application Architectures
## Client-Server Architecture
- 항상 켜져있는 서버라는 호스트가 클라이언트라고 불리는 다른 호스트들로부터 서비스 요청을 처리한다.
- 서버는 고정된, 잘 알려진 주소(IP 주소)를 가지고 있으며, 클라이언트는 이 IP 주소를 통해 서버에 접근할 수 있다.
- 클라이언트와 서버의 프로세스는 네트워크 애플리케이션 통신이 종단 시스템 간의 애플리케이션 계층에서 일어난다는 것을 보여준다.
- 대부분의 대규모 클라이언트-서버 애플리케이션은 데이터 센터라고 불리는 **대규모 서버 farm**을 사용한다.
## Peer-to-Peer Architecture
- 항상 켜져있는 전용 서버에 최소한으로 의존하는 대신, 애플리케이션은 간헐적으로 연결된 호스트 쌍 간의 직접적인 통신을 활용한다.
- 직접적인 통신을 하는 호스트들을 peer라고 부른다.
- peer는 사용자의 개인 컴퓨터이며, 다양한 장소에서 제어되는 경우가 많다.
- peer 간의 직접 통신은 매우 비용 효율적이다.
- P2P 아키텍처의 **자가 확장성**: peer가 콘텐츠를 요구하는 동시에 다른 peer에게 콘텐츠를 제공하여 시스템 용량을 추가한다.
- P2P 아키텍처는 peer가 간헐적으로 연결되어 IP 주소가 변경될 수 있기 때문에 관리하기 복잡하다.
# 프로세스 통신
## 프로세스
- 네트워크 애플리케이션의 컨텍스트에서, 호스트에서 실행되는 프로그램을 프로세스라고 부른다.
- **네트워크 애플리케이션에서 실제로 통신하는 것은 프로세스**이며, 프로세스는 동일한 종단 시스템에서 실행될 수도 있고 다른 종단 시스템에서 실행될 수도 있다.
- 동일한 종단 시스템에서 두 프로세스가 통신하는 것은 운영체제에 의해 관리되며, 프로세스 간 통신 규칙을 통해 이뤄진다.
- 다른 종단 시스템에서 실행되는 프로세스 간의 통신은 메시지를 교환하여 이뤄진다.
- 송신 프로세스는 메시지를 **socket**으로 보내고, 수신 프로세스는 메시지를 socket으로부터 받는다.
## Socket
- 소켓은 네트워크에서 프로세스가 메시지를 보내거나 받는 소프트웨어 인터페이스다.
- **프로세스에서 네트워크로 비트를 전달하는 문과 같은 역할**을 한다.
- 애플리케이션 개발자는 소켓에 대한 완전한 통제권을 가지므로 소켓의 양 끝에서 애플리케이션이 어떻게 행동하는지 결정할 수 있다.
- 메시지가 소켓을 떠나 다른 호스트의 소켓으로 도착하기 전에 발생하는 네트워크 내부의 모든 과정(라우터, 링크 등)은 애플리케이션 개발자의 통제 밖에 있다.
- 애플리케이션 프로세스는 socket interface를 통해 네트워크로부터 제공되는 전송 계층에 접근한다.
![[socket_interface.png]]
- 소켓 인터페이스는 소켓이 데이터를 보내고 받는 방법에 대한 규칙 세트다.
- 인터넷 소켓 인터페이스는 발신 프로그램이 인터넷이 데이터를 수신 프로그램에 전달하기 위해 따라야 하는 규칙 세트를 지정한다.
- 인터넷은 애플리케이션에 여러 서비스를 제공하며, 인터넷 애플리케이션을 개발할때 애플리케이션에 대한 인터넷 서비스 중 하나를 선택해야 한다.
## 주소 지정
- 메시지를 수신하는 프로세스를 식별하기 위해, 수신 호스트의 **IP 주소**와 **Port 번호**가 필요하다.
- IP 주소는 32bit 값으로, 호스트를 고유하게 식별한다. 이 주소는 점선 십진법 표기법(예: 127.7.106.83)으로 표시된다.
- 목적지 호스트에서 프로세스를 식별하기 위해 포트 번호가 사용된다.
# 애플리케이션에서 사용할 수 있는 Transport 서비스
- 애플리케이션은 전송 계층 프로토콜을 사용하여 다른 종단 시스템에서 실행되는 애플리케이션 프로세스와 메시지를 교환한다.
- 전송 계층 프로토콜은 프로세스 간의 논리적 통신을 제공하며, 네트워크 게층 프로토콜은 호스트 간의 논리적 통신을 제공한다.
- 애플리케이션은 다양한 전송 계층 서비스를 사용할 수 있다.
## 전송 계층 프로토콜의 4가지 특성
### 신뢰적 데이터 전송
- 프로토콜이 송신 프로세스가 보낸 모든 데이터가 수신 프로세스로 오류 없이 도착하는 것을 보장하는지 여부다.
### 처리량
- 전송 계층 프로토콜이 애플리케이션에 제공할 수 있는 처리량과 이것이 가변적이거나 보장되는지 여부다.
- 처리량은 송신 프로세스가 수신 프로세스에 데이터를 전달할 수 있는 속도다.
- 멀티미디어 애플리케이션 같은 경우 특정 최소 처리량으로 데이터를 전송할 수 있는 보장된 처리량 서비스를 요구할 수 있다.
### 타이밍
- 데이터가 송신 프로세스에서 수신 프로세스로 전달되는데 걸리는 시간이다.
- 인터넷 전화 같은 애플리케이션은 엄격한 타이밍 보장을 요구하며, 데이터가 도착에 큰 지연이 발생하면 안된다.
### 보안
- 전송 계층 프로토콜이 애플리케이션에 제공할 수 있는 보안 기능이다.
- 데이터의 암호화, 데이터 무결성 및 종단점 인증 같은 서비스를 제공할 수 있다.
# 인터넷이 제공하는 Transport 서비스
## TCP (Transmission Control Protocol)
### 연결 지향형 서비스
- 애플리케이션 계층 메시지를 보내기 전에 TCP 클라이언트와 서버는 서로 handshaking을 한다.
- handshaking으로 클라이언트와 서버가 서로 준비되었다는 것을 알려주고, 매개변수를 교환한다.
- 통신이 끝날때 양쪽은 연결을 해제하기 위해 handshaking을 다시 수행한다.
### 신뢰적 데이터 전송 서비스
- 발신 프로세스가 보낸 바이트가 수신 프로세스에 오류 없이 순서대로 전달되도록 한다.
- 손실된 바이트를 재전송하고, 순서가 뒤바뀐 바이트를 재정렬하며, 중복 바이트를 폐기한다.
### 흐름 제어
- 송신자가 너무 많은 데이터를 너무 빨리 전송하여 수신자의 버퍼를 오버플로우시키는 것을 방지한다.
- TCP 혼잡 제어 메커니즘은 전송 프로세스(클라이언트 또는서버) 네트워크가 혼잡할 때 발신자와 수신자 간의 트래픽을 조절한다.
- TCP 혼잡 제어는 각 TCP 연결이 네트워크 대역폭을 공정하게 공유하도록 제한하려고 시도한다.
## UDP (User Datagram Protocol)
- 최소한의 서비스를 제공하는 간결하고 가벼운 전송 프로토콜이다.
- 신뢰성, 흐름 제어, 혼잡 제어를 제공하지 않는다.
- 인터넷 전화 같은 애플리케이션은 많은 방화벽들이 UDP 트래픽을 차단하기 때문에 UDP 통신이 실패 시 TCP를 사용하도록 한다.
### 비연결형 서비스
- handshaking이 없다.
### 비신뢰적 데이터 전송 서비스
- 수신 프로세스에 대한 데이터 전달을 보장하지 않으며, 데이터의 순서도 보장하지 않는다.

> [!tip]
>  ### TLS (Transport Layer Security)
    > - TLS 는 TCP, UDP와 같은 전송 계층에 해당하며, 암호화, 데이터 무결성, 종단 인증을 제공한다.
    > - 애플리케이션은 라이브러리 등에서 제공하는 TLS 코드로 TLS 서비스를 사용할 수 있다.
    > - TLS는 TCP socket API와 비슷한 socket API를 가진다.
    > 1. 송신 프로세스가 TLS socket으로 평문 데이터를 보내면 TLS는 데이터를 암호화하여 TCP socket에 전달한다.
    > 2. 암호화된 데이터는 인터넷을 지나 수신 프로세스의 TCP socket으로 향한다.
    > 3. 수신 socket은 암호화된 데이터를 TLS에 전달하여 복호화한다.
    > 4. TLS는 TLS socket을 통해 평문 데이터를 수신 프로세스에 전달한다.

## Application-Layer Protocols
- 애플리케이션 계층 프로토콜은 애플리케이션 프로세스들이 어떻게 서로 메시지를 전달하는지 정의한다.
- 애플리케이션 계층에서 정의하는 것:
	- 교환되는 메시지 타입: 요청 메시지인지 응답 메시지인지
	- 메시지 타입의 문법: 메시지의 필드와 필드를 어떻게 작성하는지
	- 필드의 문장: 필드의 정보가 무엇을 의미하는지
	- 프로세스가 언제, 어떻게 메시지를 주고 받을지 결정하는 규칙
- 다른 많은 애플리케이션 계층 프로토콜은 독점적이며 공개 도메인에서는 의도적으로 사용할 수 없다. 예를 들어, Skype는 독점적인 애플리케이션 계층 프로토콜을 사용한다.
- 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 조각이다.

# Web과 HTTP
- HTTP는 브라우저와 웹 서버 간에 교환되는 메시지의 형식과 순서를 정의한다.
- 웹 페이지는 객체(objects)로 구성된다.
- 객체는 단일 URL로 주소 지정이 가능한 파일을 의미하며, HTML파일, JPEG 이미지, JavaScript 파일, CSS 파일 또는 비디오 클립 등이 있다.
- 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조된 객체로 구성된다.
## URL 구성 요소
- 기본 HTML 파일은 해당 객체들의 URL을 통해 페이지 내 다른 객체들을 참조한다.
- **URL은 객체를 소유한 서버의 호스트 이름과 객체의 경로명으로 구성**된다.
	- 예를 들어, http://www.someSchool.edu/someDepartment/picture.gif라는 URL에서 www.someSchool.edu는 호스트 이름이고, /someDepartment/picture.gif는 경로명
- 웹 브라우저는 HTTP의 클라이언트 측을 구현한다.
- 웹 서버는 HTTP의 서버 측을 구현하며, URL로 주소 지정이 가능한 웹 객체들을 저장한다.
##

## DNS
- 로컬 DNS 서버는 서버의 계층 구조에 강하게 속하지 않지만 DNS 아키텍처의 중심이다.
- 각 ISP는 로컬 DNS 서버를 가지며, 이는 default name server 라고도 불린다.
- 호스트가 ISP에 연결되면, ISP는 호스트에게 로컬 DNS 서버들의 한 개 이상의 IP 주소들을 제공한다.
- 호스트의 로컬 DNS 서버는 보통 호스트와 물리적으로 가까운 곳에 있다.
- 호스트가 DNS 쿼리를 하면 프록시 역할을 하는 로컬 DNS 서버로 쿼리가 전송되며, 로컬 DNS 서버는 DNS 서버 계층 구조로 쿼리를 전달한다.
158p 끝에서 4번째 줄부터


프롬프트: 
```
다음 지침을 반드시 따르세요:

1. 아래에 나열된 각 chapter에 대해서, 해당 chapter 내용만 그대로 설명하세요.  
   - 요약하거나 간략화하지 마세요.  
   - 반드시 원문 흐름과 논리 전개를 최대한 충실하게 설명하세요.  
   - 단, 문장 구조나 표현은 독자가 이해하기 쉽도록 자연스럽게 풀어서 설명해도 됩니다.

2. 설명 시 반드시 다음 형식을 지켜 주세요:

   - 각 chapter마다 "**Chapter X.X.X**" 형태의 대제목(Heading)을 먼저 적으세요.
   - 그 chapter 내에 포함된 소제목(Section Title)과 하위 개념별로 "**소제목 이름**" 형태의 소제목 Heading을 만들어 구분하세요.
   - 하위 개념(절 또는 항목)마다 명확히 구분해서 서술하세요. 절대 내용을 한 덩어리로 합쳐서 설명하지 마세요.
   - 예시 형식:  

   ## Chapter 2.2.1  
   ### <Web Objects>  
   (내용)  
   ### <URL Components>  
   (내용)  
   ### <Round-Trip Time and Object Retrieval>
   (내용)

3. 설명 중에는 지정된 chapter 범위를 절대 넘기지 마세요.  
   - 예: "chapter 2.1.5"를 설명할 때 "chapter 2.1.6" 또는 "chapter 3.x.x" 내용 포함 금지.  
   - cross-reference (다른 chapter 내용 인용 및 설명) 금지.  
   - 단, 필요에 따라 관련성이 높은 다른 chapter를 언급할 수는 있지만, 그 경우에도 **그 chapter 번호만 짧게 언급**하고 절대 내용을 풀어서 설명하지 마세요.  
   - 예시: "이 내용과 관련된 추가 설명은 chapter 3.2.1에 있습니다."

4. 만약 해당 chapter에서 특정 Figure를 참고하거나 설명하고 있다면, 반드시 그 Figure 번호를 명시하세요.  
   - 예시: "이 내용은 Figure 1.18에 나와 있습니다."

5. 각 chapter의 설명이 끝날 때마다 반드시 다음 chapter의 설명으로 넘어가기 전에 **줄바꿈 및 제목 구분**을 명확히 하세요.

---

### 설명할 chapter들 목록:

- Chapter 2.2.3
- Chapter 2.2.4
- Chapter 2.2.5
- Chapter 2.2.6
```

