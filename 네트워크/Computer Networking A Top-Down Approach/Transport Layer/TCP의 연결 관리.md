TCP 연결 설정 과정은 웹 서핑 시 인지되는 지연에 상당한 영향을 줄 수 있다.
SYN 플러드 공격과 같은 많은 네트워크 공격이 TCP 연결 관리의 취약점을 이용한다.
# TCP 연결 설정: 3-way handshake
클라이언트의 TCP는 서버의 TCP와 연결을 설정하기 위해 다음 3단계 과정을 거친다.
이 세 단계가 완료되면 클라이언트와 서버 호스트는 데이터를 포함한 세그먼트를 서로 전송할 수 있다.
이 연결 과정은 **두 호스트 간에 패킷 3개가 전송**되기 때문에 3-way handshake라고 불린다.
![[TCP_3-way_handshake.png | 500]]
1. 클라이언트 측 TCP는 서버 측 TCP에게 **SYN 세그먼트**를 보낸다.
	- 이 세그먼트에는 애플리케이션 데이터가 없다.
	- 헤더의 플래그 비트 중 **SYN 비트가 1**로 설정된다.
	- 클라이언트는 임의의 초기 sequence number(`client_isn`)를 선택하여 sequence number 필드에 넣는다.
2. 서버가 SYN 세그먼트를 수신하면, 연결을 위한 TCP 버퍼와 변수들을 할당하고 클라이언트 TCP에게 **SYNACK 세그먼트(연결 승인 세그먼트)** 를 보낸다.
	- 이 세그먼트에는 애플리케이션 데이터가 없다.
	- 헤더의 SYN 비트가 1로 설정된다.
	- ACK 필드에 `client_isn+1`이 설정된다.
	- 서버는 자신만의 초기 sequence number(`server_isn`)를 선택하여 sequence number 필드에 넣는다.
3. 클라이언트가 SYNACK 세그먼트를 수신하면, 연결을 위한 TCP 버퍼와 변수들을 할당하고 서버에게 또 다른 세그먼트를 보내 서버의 연결 승인을 확인 응답한다.
	- ACK 필드에 `server_isn+1`값을 넣는다.
	- 연결이 설정되었으므로, 헤더의 SYN 비트가 0으로 설정된다.
	- 데이터를 페이로드에 실어 보낼 수 있다.
### 생각해볼거리
- 초기 시퀀스 번호가 필요한 이유는 무엇인가요?
- 2-way가 아닌 3-way handshake가 필요한 이유는 무엇인가요?
# TCP 연결 해제
클라이언트와 서버 둘 중 누구라도 연결을 종료할 수 있다. 연결이 종료되면 호스트의 자원(버퍼, 변수 등)이 해제된다.
![[TCP_closing.png | 500]]
1. 클라이언트 애플리케이션이 `close`명령을 내린다.
2. 클라이언트 TCP는 헤더의 플래그 비트인 **FIN 비트가 1**로 설정된 세그먼트를 서버로 보낸다.
3. 서버는 이 세그먼트를 수신하고, ACK 세그먼트를 클라이언트로 보낸다.
4. 서버는 자신도 FIN 비트가 1로 설정된 종료 세그먼트를 보낸다.
5. 클라이언트는 서버의 종료 세그먼트를 확인 응답한다. 이때 두 호스트의 모든 자원이 해제된다.
# TCP 상태 전이
TCP 연결이 지속되는 동안, 각 호스트의 TCP 프로토콜은 여러 TCP 상태를 거친다.
## 클라이언트 측 상태 전이
![[client_TCP_state.png | 600]]
`CLOSED` --SYN 전송--> `SYN_SENT` --SYNACK 수신--> `ESTABLISHED` --FIN 전송--> `FIN_WAIT_1` --ACK 수신--> `FIN_WAIT_2` --서버의 FIN 수신 후 ACK 전송--> `TIME_WAIT` --대기 시간 후--> `CLOSED`

- 클라이언트 TCP는 CLOSED 상태에서 시작한다.
- 클라이언트 애플리케이션이 TCP 연결을 시작하면 서버로 SYN을 전송한다.
- `TIME_WAIT`의 대기시간은 보통 30초, 1분, 2분이다.

## 서버 측 상태 전이
![[server_TCP_state.png | 600]]
위 그림은 클라이언트가 TCP 연결을 해제한다고 가정한다.

`CLOSED` --연결 대기--> `LISTEN` --SYN 수신 후 SYNACK 전송--> `SYN_RCVD` --ACK 수신--> `ESTABLISHED` --연결 성공 / 연결 해제: FIN 수신 후 ACK 전송--> `CLOSE_WAIT` --FIN 전송--> `LAST_ACK` --ACK 수신--> `CLOSED`

# 비정상적인 상황 처리
만약 한 호스트가 진행 중인 소켓과 일치하지 않는 포트 번호나 IP 주소를 가진 TCP 세그먼트를 수신하면, 그 호스트는 송신자에게 **RST 세그먼트(리셋 세그먼트)** 를 보낸다. 
RST 세그먼트는 **RST 플래그 비트가 1**로 설정되어 있으며, "해당 세그먼트에 대한 소켓이 없으니 재전송하지 말라"는 의미를 전달한다.
# SYN flood attack
TCP의 3-way handshake는 SYN flood attack이라는 서비스 거부(Denial-of-Service, DoS)공격에 취약하다.
## 공격 원리
1. 공격자는 서버에 다량의 TCP SYN 세그먼트를 보낸다. 
   이때 이 세그먼트들의 소스 IP 주소는 위조되어 실제로는 존재하지 않는다.
2. 서버는 각각의 SYN 세그먼트에 대해 연결 리소스(버퍼, 변수 등)를 할당한다.
   이는 3-way handshake의 1단계에 해당한다.
3. 서버는 각각의 SYN 세그먼트에 대한 응답으로 SYNACK 세그먼트를 위조된 소스 IP 주소로 보낸다.
4. 서버는 존재하지 않는 클라이언트로부터 ACK 세그먼트가 도착하기를 기다린다.
## 공격의 영향
공격자가 서버의 연결 리소스가 고갈될 만큼 충분한 수의 SYN 세그먼트를 보낸다면, 서버는 자원이 낭비되어 정상적인 클라이언트로부터 들어오는 새로운 연결 요청을 거부하게 된다. 이 상태가 되면 서버의 서비스는 사실상 중단된다.
## 대응책: SYN 쿠키
1. 서버가 SYN 세그먼트를 수신해도 연결 리소스를 할당하지 않는대신, 특별한 초기 TCP sequence number(`server_isn`)을 생성한다.
   이 sequence number가 바로 쿠키(cookie)로, hash하여 계산된다.
2. 서버는 이 쿠키를 포함한 SYNACK를 클라이언트에 보낸다.
   이때 서버는 이 쿠키를 포함한 **어떤 상태 정보도 저장하지 않아** SYN을 받은 적이 없는 것처럼 동작한다.
3. 정상적인 클라이언트는 SYNACK를 수신하고, ACK 필드에 `server_isn+1`값을 담아 서버로 보낸다.
4. 서버가 ACK를 받으면, ACK 값과 세그먼트의 소스/목적지 정보, 자신의 비밀 숫자(해시값 생성시 사용한)를 이용해 ACK -1 값이 이전에 생성된 쿠키와 일치하는지 검증한다.
	- 일치하면, 서버는 연결 리소스를 생성한다.
	- 일치하지 않거나 서버로부터 ACK가 오지 않으면 서버는 아무런 조치도 취하지 않는다.