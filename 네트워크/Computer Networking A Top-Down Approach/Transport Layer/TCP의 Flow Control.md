# Flow Control(흐름 제어)
- TCP 연결의 양 끝 호스트는 **수신 버퍼(receive buffer)** 를 가지며, 네트워크로부터 도착한 데이터 스트림을 여기에 저장한다.
- 수신측 애플리케이션이 버퍼에서 데이터를 읽는 속도가 송신측이 데이터를 보내는 속도보다 느리면 송신자는 수신자의 버퍼를 쉽게 오버플로우시킬 수 있다.
- 버퍼 오버플로우 방지를 위해 흐름 제어를 통해 데이터 송신 속도와 수신 애플리케이션의 데이터 읽기 속도를 맞춘다.
- 네트워크 혼잡 때문에 송신자를 조절하는 혼잡 제어와는 다른 개념이다.
# 흐름 제어 작동 방식
**수신 윈도우(receive window)**: 흐름 제어를 위해 송신자가 가지고 있는 변수다. **수신자의 수신 버퍼가 얼마나 남았는지 송신자에게 알려준다**. TCP는 전이중 통신이므로, 양끝 송신자는 각각 별개의 수신 윈도우를 가진다.

호스트 B가 호스트 A로부터 대용량 파일을 수신할때:
- 호스트 B는 이 연결을 위해 크기가 RcvBuffer인 수신 버퍼를 할당한다.
- LastByteRead: B의 애플리케이션이 버퍼에서 읽은 데이터 스트림의 마지막 바이트 번호
- LastByteRcvd: B의 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 번호
- 버퍼 오버플로우를 막으려면 $(LastByteRcvd - LastByteRead) \le RcvBuffer$ 조건을 항상 만족해야 한다.
- 수신 윈도우(rwnd)는 다음과 같이 버퍼의 여유 공간으로 설정된다.
  $rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]$
- rwnd의 초깃값은 RcvBuffer 값으로 설정되고, 당연하게도 rwnd 값은 시시각각 변한다.
- 호스트 B는 자신이 보내는 모든 **세그먼트의 수신 윈도우 필드에 현재 rwnd 값을 넣어** 호스트 A에게 버퍼의 여유 공간을 알려준다.
- LastByteSent: A가 전송한 마지막 바이트 번호
- LastByteAcked: A가 ACK를 받은 마지막 바이트 번호
- 호스트 A는 **ACK를 받지 못한(미확인) 데이터의 양을 rwnd보다 작게 유지**하여 호스트 B의 버퍼 오버플로우 방지를 보장한다.
  $(LastByteSent - LastByteAcked) \le rwnd$
# 수신 윈도우가 0일때
수신측에서 수신 윈도우 값이 0이라고 알린 후, 송신측에게 보낼 데이터가 더이상 없으면 세그먼트를 보내지 않는다. 그 뒤 수신 버퍼가 비워져도 보낼 데이터나 ACK가 없으므로 수신 윈도우 값을 포함한 세크먼트를 보내지 않는다.
결과적으로 송신측에서 수신측의 수신 버퍼 공간이 생겼다는 사실을 알 수 없어 더이상 데이터를 전송하지 못하고 차단된다.

TCP 명세는 송
