> [!NOTE]
    > 이 챕터에서는 단방향 데이터 전송만 고려한다.
# 서비스 모델과 구현
![[reliable_data_transfer_service_model_and_implementation.png]]
TCP는 상위 계층에 데이터 손상/손실 없이 전송된 순서대로 전달하는, 추상화된 서비스 모델을 제공한다.
TCP는 신뢰할 수 없는 IP 네트워크 계층 위에서 구현되며, 신뢰성있는 데이터 전송 프로토콜을 구현한다.
### 프로토콜 인터페이스
- 송신측에서는 `rdt_send()` 호출을 통해 상위 계층으로부터 데이터를 받는다.
- 수신측에서는 `rdt_rcv()`가 채널로부터 패킷이 도착했을 때 호출된다.
- `rdt` 프로토콜이 상위 계층으로 데이터를 전달하고자 할 때는 `deliver_data()`를 호출한다.
- `rdt`의 송신측과 수신측은 모두 `udt_send()` 호출을 통해 상대방에게 패킷을 보낸다. 여기서 `udt`는 신뢰할 수 없는 데이터 전송(unreliable data trasfer)을 의미한다.
- 송신측과 수신측은 확인응답(ACK)과 같은 제어 정보가 든 패킷을 양방향으로 전송하며 교환한다.
# 신뢰성 있는 데이터 전송 프로토콜 구축
신뢰성 있는 데이터 전송 프로토콜은 비트 오류와 패킷 손실이라는 두 가지 주요 문제를 해결해야 한다.
- **비트 오류**는 **체크섬**으로 감지하고, **ACK(긍정 확인응답)**, **NAK(부정 확인응답)**, **sequence number(순서 번호)** 를 통해 복구한다. 송신자는 NAK를 받거나 손상된 ACK/NAK를 받으면 패킷을 재전송한다.
- **패킷 손실**은 송신측의 **카운트다운 타이머**로 감지한다. 정해진 시간 내에 ACK가 도착하지 않으면, 송신자는 패킷이 손실된 것으로 간주하고 재전송한다.
- 이러한 기능을 결합하면 송신자가 패킷 하나를 보내고 ACK를 받을 때까지 기다리는 **정지-대기(stop-and-wait)** 방식의 신뢰성 있는 프로토콜이 된다.
## 1. 완벽하게 신뢰성 있는 채널
하위 채널이 완벽하게 신뢰성 있다고 가정한다. 송신측과 수신측은 유한 상태 머신(Finite-State Machine, FSM)이다.
### 송신측
1. 상위 계층으로부터 데이터를 받는다.
2. 데이터를 포함하는 패킷을 생성한다.
3. 채널로 패킷을 전송한다.
### 수신측
1. 하위 채널로부터 패킷을 받는다.
2. 패킷에서 데이터를 추출한다.
3. 상위 계층으로 패킷을 전달한다.

이 프로토콜에서는 데이터 단위와 패킷 간에 차이가 없다.
모든 패킷 흐름은 송신측에서 수신측으로만 향하고, 완벽하게 신뢰성 있는 채널이므로 수신측이 송신측에 피드백을 보낼 필요가 없다.
## 2. 비트 오류가 있는 채널
모든 전송된 패킷은 순서대로 수신되지만 비트가 손상될 수 있다고 가정한다. 
비트 오류를 처리하기 위해 **재전송**에 기반한 신뢰성 있는 데이터 전송 프로토콜을 자동 반복 요청(Automatic Repeat reQuest, ARQ) 프로토콜이라고 한다.
### ARQ 프로토콜의 기능
1. **오류 검출(Error Detection)**: 수신자가 비트 오류 발생을 감지하는 메커니즘이다. 이를 위해 송신자는 추가 비트(예: 체크섬)를 전송한다.
2. **수신자 피드백(Receiver Feedback)**: 수신자는 송신자에게 패킷이 올바르게 수신되었는지(긍정 확인응답, ACK) 또는 오류가 있었는지(부정 확인응답, NAK)를 알려준다.
3. **재전송(Retransmission)**: 수신자에게 오류로 수신된 패킷은 송신자에 의해 재전송된다.
### ACK, NAK만 사용하여 오류 검출하는 경우
- 송신측은 두 가지 상태를 가진다.
- 한 상태에서는 상위 계층으로부터 데이터를 기다리다가, 데이터를 받으면 패킷을 만들어 전송하고 다른 상태로 전환한다.
- 송신측의 다른 상태에서는 수신자로부터 ACK 또는 NAK를 기다린다. ACK를 받으면 첫 번째 상태로 돌아가고, NAK를 받으면 마지막 패킷을 재전송하고 다시 ACK/NAK를 기다린다.
- 이처럼 송신자가 현재 패킷이 올바르게 수신되었는지 확신할 때까지 새로운 데이터를 보내지 않는 방식을 **정지-대기(stop-and-wait)** 프로토콜이라고 한다.
- 수신측은 패킷이 도착하면 수신된 패킷의 손상 여부에 따라 ACK 또는 NAK로 응답한다.
### 패킷에 Sequence Number가 있을때
- ACK, NAK 패킷 자체가 손상되면 송신측은 수신측이 마지막 데이터를 올바르게 수신했는지 알 수 없다. 이를 해결하기 위해 송신자는 데이터 패킷에 Suquence Number 필드를 추가한다.
- 데이터 패킷에 **순서 번호(sequence number)** 필드를 추가하면 상태가 두 배로 늘어난다. 이는 현재 전송 중이거나 예상되는 패킷의 순서 번호가 0인지 1인지를 상태에 반영해야 하기 때문이다.
- 수신측은 순서 번호를 확인하여 수신된 패킷이 재전송된 것인지 새로운 것인지 구별할 수 있다. 정지-대기 프로토콜에서는 1비트 순서 번호로 충분하다.
### NAK을 사용하지 않을때
- 송신측이 동일한 패킷에 대해 두 개의 ACK를 받으면, 이는 수신측에서 해당 ACK 다음 패킷을 올바르게 수신하지 못했음을 의미한다.
- 수신측은 NAK 대신 마지막으로 올바르게 수신된 패킷에 대한 ACK를 재전송(중복 ACK)한다. 
## 3. 비트 오류와 패킷 손실이 있는 채널
- 비트 손상뿐만 아니라 패킷 손실도 발생할 수 있는 채널을 가정한다.
- 송신측은 패킷이 손실되었다고 확신할 만큼 기다린 후 패킷을 재전송할 수 있다.
- Sequence Number 메커니즘으로 중복 패킷 문제를 해결한다.
- **카운트다운 타이머**를 이용해 송신측은 패킷을 보낼 때마다 타이머를 시작하고, 타이머 인터럽트에 응답하며, 타이머를 중지할 수 있다.
- 패킷 Sequece Number가 0과 1을 번갈아 사용하기 때문에 **교체-비트 프로토콜**이라고도 한다.
### 신뢰성있는 데이터 전송 프로토콜 특징
- 비트 오류는 체크섬으로 감지하고, ACK, NAK, Sequence Number를 통해 복구한다. 송신측은 NAK을 받거나 손상된 ACK/NAK을 받으면 패킷을 재전송한다.
- 패킷 손실은 송신측의 카운트다운 타이머로 감지한다. 정해진 시간 내에 ACK가 도착하지 않으면, 송신측은 패킷이 손실된 것으로 간주하고 재전송한다.

패킷 손실 없을때:
![[img/rdt3a.png]]

패킷 손실 발생:
![[rdt3b.png]]

ACK 손실 발생:
![[rdt3c.png]]

타임아웃 발생:
![[rdt3d.png]]
# 파이프라이닝 기법
- 정지-대기 방식은 송신측이 확인응답을 기다리기 때문에 채널 이용률이 매우 낮아진다.
- 파이프라이닝 기법은 송신자가 **확인응답을 기다리지 않고 여러 패킷을 연속 전송**할 수 있도록 허용하는 기법이다.
- **순서 번호(sequence number) 범위 증가**: 전송 중인 여러 패킷 각각이 고유한 순서 번호를 가져야 하므로 순서 번호의 범위가 더 커져야 한다.
- **송수신 양단의 버퍼링**: 송신자는 전송되었지만 아직 확인응답을 받지 않은 패킷들을 버퍼에 저장해야 한다. 수신자 측에서도 올바르게 수신된 패킷을 버퍼링해야 할 수 있다.
- **오류 복구 방식**: 순서 번호의 범위와 버퍼링 요구 사항은 프로토콜이 패킷 손실, 손상, 지연에 어떻게 대응하는지에 따라 달라진다. 파이프라인 오류 복구에는 **Go-Back-N**과 **선택적 반복(selective repeat)** 이라는 두 가지 기본 접근 방식이 있다.
## Go-Back-N(GBN)
- 송신측은 확인응답(ACK)을 기다리지 않고 여러 패킷을 전송할 수 있다.
- 파이프라인 내에 미확인 패킷의 수가 최대 허용 수 `N`**(윈도우 크기, window size)** 을 초과할 수 없다.
- GBN 프로토콜은 **슬라이딩 윈도우 프로토콜(sliding-window protocol)** 이라고도 한다.
### GBN 송신측의 동작
![[GBN_sender.png]]
1. 상위 계층으로부터 데이터 수신(`rdt_send()`): rdt_send()`이 호출되면 송신측은 윈도우가 가득 찼는지 확인한다. 가득 차지 않았다면 패킷을 생성하여 보내고 변수를 업데이트한다. 가득 찼다면 데이터를 상위 계층으로 돌려보낸다.
2. ACK 수신: sequence number `n`을 가진 패킷에 대한 확인응답은 **누적 확인응답**으로 간주되며, 이는 `n`까지의 모든 패킷이 올바르게 수신되었음을 나타낸다.
3. 타임아웃: 타임아웃이 발생하면 송신측은 이전에 전송했지만 아직 확인응답을 받지 못한 모든 패킷을 재전송한다. 송신측은 가장 오래된 미전송 패킷에 대한 단일 타이머만 사용한다.
### GBN 수신자의 동작
- sequence number `n`을 가진 패킷을 정상적으로 받으면, 수신측은 패킷 `n`에 대한 ACK를 보내고 패킷의 데이터 부분을 상위 계층으로 전달한다.
- 패킷을 정상적으로 받지 못한 경우, 수신측은 패킷을 버리고 가장 최근에 순서에 맞게 수신된 패킷에 대한 ACK를 재전송한다.
- window size가 4인 GBN 프로토콜에서, 패킷 2가 손실되면 수신측은 순서가 맞지 않는 패킷 3, 4, 5를 버리고 송신자는 타임아웃 후 패킷 2부터 다시 전송한다. 이처럼 올바르게 수신된 패킷을 버려 비효율적일 수 있다.

## Selective Repeat(SR)
- 송신측이 수신측에게서 오류가 발생했다고 의심되는 패킷만 재전송한다.
- 이를 위해 수신측은 올바르게 수신된 패킷을 개별적으로 확인응답해야 한다.
- 파이프라인 내 미확인 패킷의 수를 제한하기 위해 GBN과 같이 window size가 사용된다.
### SR 송신측의 동작
1. 상위 계층으로부터 데이터 수신: sequence number가 윈도우 내에 있으면 데이터를 패킷화하여 전송한다.
2. 타임아웃: 각 패킷은 자체 논리적 타이머를 가지며, 타임아웃 시 해당 패킷 하나만 재전송된다.
3. ACK 수신: ACK가 수신되면 해당 패킷을 수신된 것으로 표시한다. 이 패킷의 sequence number가 윈도우의 시작(send_base)과 같다면, 윈도우를 가장 작은 sequence number를 가진 미확인 패킷으로 이동시킨다.
### SR 수신측의 동작
1. [rcv_base, rcv_base+N-1] 범위의 패킷 수신: 패킷이 윈도우 내에 있으면 ACK를 송신측에 보낸다. 이 패킷이 이전에 수신되지 않은 패킷이라면 버퍼에 저장한다. 이 패킷의 sequence number가 수신 윈도우의 rcv_base와 같다면, 이 패킷과 이전에 버퍼링된 연속적인 패킷들을 상위 계층으로 전달하고 윈도우를 이동시킨다.
2. [rcv_base-N, rcv_base-1] 범위의 패킷 수신: 이전에 이미 확인응답한 패킷이라도 ACK를 다시 생성해야 한다.
3. 그 외에는 패킷을 무시한다.

![[SR_operation.png]]
패킷 2가 손실되었을 때, 수신측은 패킷 3, 4, 5를 버퍼에 저장하고 있다가 패킷 2가 재전송되어 도착하면 한꺼번에 상위 계층으로 전달한다.
### 송신측과 수신측의 window 불일치 문제
- SR 프로토콜에서는 송신측과 수신측의 윈도우가 항상 일치하지 않을 수 있다.
- 유한한 sequence number 범위를 사용할때 패킷을 구별할 수 없는 상황이 발생할 수 있다.
  예를들어, sequence number가 0, 1, 2, 3이고 window size가 3일때 수신측은 첫번째 패킷과 다섯번째 패킷(sequence number가 0으로 같음)을 구별할 수 없다.
- SR 프로토콜에서는 **window size가 sequence number 범위 크기의 절반 이하 여야한다.**

# 신뢰성있는 데이터 전송 메커니즘과 사용법
![![네트워크/Computer Networking A Top-Down Approach/Transport Layer/#*Table2]]