> [!NOTE]
    > 이 챕터에서는 단방향 데이터 전송만 고려한다.
# 서비스 모델과 구현
![[reliable_data_transfer_service_model_and_implementation.png]]
TCP는 상위 계층에 데이터 손상/손실 없이 전송된 순서대로 전달하는, 추상화된 서비스 모델을 제공한다.
TCP는 신뢰할 수 없는 IP 네트워크 계층 위에서 구현되며, 신뢰성있는 데이터 전송 프로토콜을 구현한다.
### 프로토콜 인터페이스
- 송신측에서는 `rdt_send()` 호출을 통해 상위 계층으로부터 데이터를 받는다.
- 수신측에서는 `rdt_rcv()`가 채널로부터 패킷이 도착했을 때 호출된다.
- `rdt` 프로토콜이 상위 계층으로 데이터를 전달하고자 할 때는 `deliver_data()`를 호출한다.
- `rdt`의 송신측과 수신측은 모두 `udt_send()` 호출을 통해 상대방에게 패킷을 보낸다. 여기서 `udt`는 신뢰할 수 없는 데이터 전송(unreliable data trasfer)을 의미한다.
- 송신측과 수신측은 확인응답(ACK)과 같은 제어 정보가 든 패킷을 양방향으로 전송하며 교환한다.
# 신뢰성 있는 데이터 전송 프로토콜 구축
신뢰성 있는 데이터 전송 프로토콜은 비트 오류와 패킷 손실이라는 두 가지 주요 문제를 해결해야 한다.
- **비트 오류**는 **체크섬**으로 감지하고, **ACK(긍정 확인응답)**, **NAK(부정 확인응답)**, **sequence number(순서 번호)** 를 통해 복구한다. 송신자는 NAK를 받거나 손상된 ACK/NAK를 받으면 패킷을 재전송한다.
- **패킷 손실**은 송신측의 **카운트다운 타이머**로 감지한다. 정해진 시간 내에 ACK가 도착하지 않으면, 송신자는 패킷이 손실된 것으로 간주하고 재전송한다.
- 이러한 기능을 결합하면 송신자가 패킷 하나를 보내고 ACK를 받을 때까지 기다리는 **정지-대기(stop-and-wait)** 방식의 신뢰성 있는 프로토콜이 된다.
## 1. 완벽하게 신뢰성 있는 채널
하위 채널이 완벽하게 신뢰성 있다고 가정한다. 송신측과 수신측은 유한 상태 머신(Finite-State Machine, FSM)이다.
### 송신측
1. 상위 계층으로부터 데이터를 받는다.
2. 데이터를 포함하는 패킷을 생성한다.
3. 채널로 패킷을 전송한다.
### 수신측
1. 하위 채널로부터 패킷을 받는다.
2. 패킷에서 데이터를 추출한다.
3. 상위 계층으로 패킷을 전달한다.

이 프로토콜에서는 데이터 단위와 패킷 간에 차이가 없다.
모든 패킷 흐름은 송신측에서 수신측으로만 향하고, 완벽하게 신뢰성 있는 채널이므로 수신측이 송신측에 피드백을 보낼 필요가 없다.
## 2. 비트 오류가 있는 채널
모든 전송된 패킷은 순서대로 수신되지만 비트가 손상될 수 있다고 가정한다. 
비트 오류를 처리하기 위해 **재전송**에 기반한 신뢰성 있는 데이터 전송 프로토콜을 자동 반복 요청(Automatic Repeat reQuest, ARQ) 프로토콜이라고 한다.
### ARQ 프로토콜의 기능
1. **오류 검출(Error Detection)**: 수신자가 비트 오류 발생을 감지하는 메커니즘이다. 이를 위해 송신자는 추가 비트(예: 체크섬)를 전송한다.
2. **수신자 피드백(Receiver Feedback)**: 수신자는 송신자에게 패킷이 올바르게 수신되었는지(긍정 확인응답, ACK) 또는 오류가 있었는지(부정 확인응답, NAK)를 알려준다.
3. **재전송(Retransmission)**: 수신자에게 오류로 수신된 패킷은 송신자에 의해 재전송된다.
### ACK, NAK만 사용하여 오류 검출하는 경우
- 송신측은 두 가지 상태를 가진다.
- 한 상태에서는 상위 계층으로부터 데이터를 기다리다가, 데이터를 받으면 패킷을 만들어 전송하고 다른 상태로 전환한다.
- 송신측의 다른 상태에서는 수신자로부터 ACK 또는 NAK를 기다린다. ACK를 받으면 첫 번째 상태로 돌아가고, NAK를 받으면 마지막 패킷을 재전송하고 다시 ACK/NAK를 기다린다.
- 이처럼 송신자가 현재 패킷이 올바르게 수신되었는지 확신할 때까지 새로운 데이터를 보내지 않는 방식을 **정지-대기(stop-and-wait)** 프로토콜이라고 한다.
- 수신측은 패킷이 도착하면 수신된 패킷의 손상 여부에 따라 ACK 또는 NAK로 응답한다.
### 패킷에 Sequence Number가 있을때
- ACK, NAK 패킷 자체가 손상되면 송신측은 수신측이 마지막 데이터를 올바르게 수신했는지 알 수 없다. 이를 해결하기 위해 송신자는 데이터 패킷에 Suquence Number 필드를 추가한다.
- 데이터 패킷에 **순서 번호(sequence number)** 필드를 추가하면 상태가 두 배로 늘어난다. 이는 현재 전송 중이거나 예상되는 패킷의 순서 번호가 0인지 1인지를 상태에 반영해야 하기 때문이다.
- 수신측은 순서 번호를 확인하여 수신된 패킷이 재전송된 것인지 새로운 것인지 구별할 수 있다. 정지-대기 프로토콜에서는 1비트 순서 번호로 충분하다.
### NAK을 사용하지 않을때
- 송신측이 동일한 패킷에 대해 두 개의 ACK를 받으면, 이는 수신측에서 해당 ACK 다음 패킷을 올바르게 수신하지 못했음을 의미한다.
- 수신측은 NAK 대신 마지막으로 올바르게 수신된 패킷에 대한 ACK를 재전송(중복 ACK)한다. 
## 비트 오류와 패킷 손실이 있는 채널
- 비트 손상뿐만 아니라 패킷 손실도 발생할 수 있는 채널을 가정한다.
- 송신측은 패킷이 손실되었다고 확신할 만큼 기다린 후 패킷을 재전송할 수 있다.
- Sequence Number 매케니즘으로 중복 패킷 문제를 해결한다.
- **카운트다운 타이머**를 이용해 송신측은 패킷을 보낼 때마다 타이머를 시작하고, 타이머 인터럽트에 응답하며, 타이머를 중지할 수 있다.
- 패킷 Sequece Number가 0과 1을 번갈아 사용하기 때문에 **교체-비트 프로토콜**이라고도 한다.
### 신뢰성있는 데이터 전송 프로토콜 특징
- 비트 오류는 체크섬으로 감지하고, ACK, NAK, Sequence Number를 통해 복구한다. 송신측은 NAK을 받거나 손상된 ACK/NAK을 받으면 패킷을 재전송한다.
- 패킷 손실은 송신측의 카운트다운 타이머로 감지한다. 정해진 시간 내에 ACK가 도착하지 않으면, 송신측은 패킷이 손실된 것으로 간주하고 재전송한다.

패킷 손실 없을때:
![[img/rdt3a.png]]

패킷 손실 발생:
![[rdt3b.png]]

ACK 손실 발생:
![[rdt3c.png]]

타임아웃 발생:
![[rdt3d.png]]
# 파이프라이닝 기법
- 정지-대기 방식은 성능이 낮다.

Chapter 3.4.2
Chapter 3.4.3
Chapter 3.4.4