TCP는 발신지가 자신에게 트래픽을 보내는 속도를 제한하는 방식으로 혼잡을 제어한다.
# 전송 속도 제한 방식
- 발신지는 **혼잡 윈도우(congestion window, `cwnd`)** 값을 조절하여 전송 속도를 제한한다.
- 발신지에서 아직 ACK를 받지 않은 데이터의 양은 `cwnd`와 `rwnd`(수신 윈도우) 중 작은 값 이하여야 한다.
  $LastByteSent - LastByteAcked \leq min(cwnd, rwnd)$
  이 제약 조건은 발신지의 전송 속도를 간접적으로 `cwnd/RTT` bytes/sec로 제한한다.
# 혼잡 감지 방식
- 발신지는 **손실 이벤트(loss event)** 를 통해 혼잡을 감지한다.
	- 타임아웃
	- 3개의 중복된 ACK 수신
- 라우터의 버퍼가 오버플로우될때 발생한 패킷 손실은 발신지에서 손실 이벤트로 감지된다.
- 이전에 확인응답되지 않은 세그먼트의 ACK가 도착하면 네트워크가 혼잡하지 않다는 신호로 간주된다. TCP는 이를 이용해 `cwnd` 크기를 늘린다.
- ACK가 도착하는 속도에 따라 `cwnd` 증가 속도가 조절되므로, TCP는 **자체 클럭킹(self-clocking)** 특성을 갖는다.
# 혼잡 제어 알고리즘
TCP 혼잡 제어는 `cwnd`를 RTT마다 1 MSS씩 선형적으로 증가시키고(**부가적 증가, Additive-Increase**), 3개의 중복 ACK 이벤트 시 `cwnd`를 절반으로 줄이는(**승법적 감소, Multiplicative-Decrease**) 방식으로 동작한다. 이를 **AIMD** 혼잡 제어라고 한다.
## TCP의 전송 속도 결정 원칙
1. **손실된 세그먼트는 혼잡**을 의미: 세그먼트가 손실되면 TCP 발신지의 전송 속도는 감소해야 한다.
2. **확인응답된 세그먼트는 혼잡하지 않음**을 의미: ACK가 도착하면 발신지의 전송 속도는 증가할 수 있다.
3. **대역폭 탐색**: TCP는 손실 이벤트가 발생할 때까지 ACK에 응답하여 전송률을 높이다가, 손실이 발생하면 전송률을 낮춘다. 이후 다시 대역폭을 탐색하기 위해 전송률을 점진적으로 높인다.
## 혼잡 제어 알고리즘의 구성요소
### 느린 시작(Slow Start)
- TCP 연결이 시작될 때, `cwnd`는 1 MSS(Maximum Segment Size)로 초기화된다.
- 각 세그먼트가 **처음으로 확인응답될 때마다 `cwnd`는 1 MSS씩 증가**한다. 그러면 발신지는 늘어난 `cwnd` 값만큼 세그먼트들을 보낸다. 즉, 첫 확인응답된 세그먼트 개수만큼 `cwnd`가 증가한다. -> **매 RTT마다 전송률이 두 배로 증가**하는 지수적 증가
  ![[TCP_slow_start.png | 400]]
- 다음 중 하나가 발생하면 느린 시작 종료:
	1. 타임아웃이 발생하면 `cwnd`는 1로 재설정되고, `ssthresh`(느린 시작 임계값)는 혼잡 감지 시 `cwnd`의 절반 값으로 설정된다.
	2. `cwnd`값이 `ssthresh`에 도달하면 느린 시작이 끝나고 혼잡 회피 모드로 전환된다.
	3. 3개의 중복 ACK가 감지되면, 빠른 재전송을 수행하고 빠른 회복 상태로 들어간다.
### 혼잡 회피(Congestion Avoidance)
- 혼잡 회피 상태에 들어가면 TCP는 `cwnd`를 매 RTT마다 1MSS씩만 증가시킨다. -> **선형적인 증가**
- 타임아웃이 발생하면 `cwnd`는 1MSS로, `ssthresh`는 혼잡 발생 시 `cwnd`의 절반 값으로 설정된다.
- 3개의 중복 ACK를 받으면 TCP는 `cwnd`값을 절반으로 줄이고, `ssthresh`를 `cwnd`의 절반 값으로 기록한 후 빠른 회복 상태로 들어간다.
### 빠른 회복(Fast Recovery)
- 빠른 회복은 3개의 중복 ACK 수신 시 진입한다.
- 손실된 세그먼트에 대한 새로운 ACK가 도착하면 `cwnd`를 줄인 후 혼잡 회피 상태로 전환된다.
  이때 `cwnd`를 절반으로 줄이고, 3개의 중복 ACK를 측정하기 위해 +3MSS한다.
- 중복 ACK를 받을 때마다 `cwnd`를 1MSS씩 증가시킨다.
- 타임아웃이 발생하면 느린 시작 상태로 전환된다.
- Fast recovery는 TCP 구현에 권장되지만, 필수는 아니다.
## TCP Tahoe vs TCP Reno
- TCP Tahoe는 타임아웃이건 3개의 중복 ACK건, `cwnd`를 1로 설정하고 빠른 회복 없이 slow start로 진입한다.
- TCP Reno는 빠른 회복을 포함한다.
![[TCP_congestion_window_graph.png | 500]]
위 그래프에서 초기 `ssthresh`는 8MSS다.
처음 8번의 전송까지는 Tahoe와 Reno는 동일한 동작을 한다.
4번째 전송까지는 느린 전송 구간으로, `cwnd`가 지수적으로 증가한다.
8번째 전송까지는 선형적으로 증가하다가 3개의 중복 ACK를 받는 상황이다.
이때 `cwnd`는 12MSS다.
3개의 중복 ACK를 받으면, `ssthresh`는 `cwnd`의 절반인 6MSS가 된다.
- TCP Tahoe의 `cwnd`는 1MSS가 되고 `ssthresh`까지 지수적으로 증가한 후 `ssthresh`에 도달하면 선형적으로 증가한다.
- TCP Reno의 `cwnd`는 12의 절반인 6에다가 중복 ACK 측정을 위한 3을 더하여 9MSS가 되고 선형적으로 증가한다.
