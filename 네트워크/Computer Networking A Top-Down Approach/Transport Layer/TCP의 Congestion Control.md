패킷 손실은 전형적으로 네트워크가 혼잡해지면서 라우터 버퍼의 오버플로우로 인해 발생한다.
네트워크 혼잡의 원인을 해결하기 위해서는, 네트워크 혼잡 발생 시 발신자를 제한하는 메커니즘이 필요하다.
# 혼잡의 원인과 비용
## 시나리오1: 발신지 2개, 무한 버퍼를 가진 라우터 1개
### 환경
![[congestion_scenario1.png]]
- 두 호스트 A, B는 각각 평균 $\lambda_{in}$ byte/sec의 속도로 데이터를 전송한다.
- 이 데이터는 재전송하지 않은 원본 데이터다.
- 라우터는 용량이 R인 하나의 공유 출력 링크를 가지며, 버퍼 크기는 무한하다.
### 성능 분석
![[congestion_scenario1_graph.png]]
- 처리율(throughput): 각 연결의 전송률이 R/2 미만일 때는 수신 처리율이 전송률과 동일하다($\lambda_{out} == \lambda_{in}$). 그러나 전송률이 R/2를 초과하면 수신 처리율은 R/2로 제한된다. 왜냐하면 두 호스트가 하나의 링크 용량을 공유하기 때문이다.
- 지연: 전송률이 R/2에 가까워질수록 평균 큐잉 지연은 기하급수적으로 증가한다. 전송률이 R/2를 초과하면 라우터의 큐는 무한정 길어지고, 평균 지연 시간 역시 무한대가 된다.
### 혼잡 비용
**패킷 전송률($\lambda_{in}$)이 링크 용량에 가까워질때 발생하는 막대한 큐잉 지연**
## 시나리오2: 발신지 2개, 유한 버퍼를 가진 라우터 1개
### 환경
![[congestion_scenario2.png]]
- 라우터의 버퍼 크기가 유한하다. 따라서 라우터의 버퍼가 가득 찼을때 도착하는 패킷은 손실된다.
- 각 연결은 신뢰성을 보장하며, 손실된 패킷은 재전송된다.
- $\lambda_{in}$은 애플리케이션이 전송하는 원본 데이터의 속도다.
- $\lambda'_{in}$은 재전송 데이터를 포함한 전체 트래픽이다.
### 성능 분석
