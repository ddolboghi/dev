---
aliases:
---
UDP(User Datagram Protocol)는 IP에 최소한의 기능만 추가한, 간단하고 **'no-frills'** 스타일의 전송 프로토콜이다.
UDP는 애플리케이션 프로세스로부터 받은 메시지에 다중화/역다중화를 위한 출발지 및 목적지 포트 번호와 (목적지 IP 주소, 목적지 포트 번호) 필드를 추가한 뒤, 세그먼트를 네트워크 계층으로 바로 전달한다.

# UDP의 특징
UDP는 TCP와 달리 다음과 같은 특징을 가지며, 이로 인해 특정 애플리케이션에 더 적합할 수 있다.
- **비연결성 (Connectionless)**: 데이터를 전송하기 전에 TCP처럼 3-way handshake와 같은 연결 설정 과정을 거치지 않는다. 이 때문에 DNS처럼 빠른 응답이 중요한 애플리케이션에서 지연을 줄일 수 있어 선호된다.
- **애플리케이션 수준의 세밀한 제어**: 애플리케이션이 보내는 데이터와 전송 시점을 직접 제어할 수 있다. TCP의 경우 내장된 **혼잡 제어** 메커니즘이 네트워크 상황에 따라 전송 속도를 조절하지만, 실시간 애플리케이션은 약간의 데이터 손실을 감수하더라도 최소한의 전송률을 유지하는 것을 선호할 수 있다.
- **비신뢰성 (Unreliable)**: UDP는 데이터가 목적지에 제대로 도착했는지 보장하지 않으며, 오류 복구 기능이 없다. 하지만 신뢰성이 필수적이지 않은 스트리밍 미디어나 인터넷 전화 같은 실시간 애플리케이션에서 자주 사용된다. 신뢰성이 필요한 경우, **QUIC 프로토콜**처럼 애플리케이션 계층에서 직접 신뢰성을 구현할 수도 있다.
- **연결 상태 없음 (No Connection State)**: TCP와 달리 송수신 버퍼, 혼잡 제어 매개변수, 순서 번호와 같은 연결 상태 정보를 유지하지 않는다. 이로 인해 서버는 더 적은 리소스를 사용하므로 TCP를 사용하는 서버보다 훨씬 많은 클라이언트를 지원할 수 있다.
- **작은 헤더 오버헤드**: UDP 세그먼트 헤더는 **8바이트**에 불과해, 20바이트인 TCP 헤더보다 작다.
- UDP는 자체적인 혼잡 제어 기능이 없기 때문에, 제어 없이 높은 비트레이트의 데이터를 전송하면 네트워크 혼잡을 유발하고 TCP 트래픽을 몰아내는 등 부정적인 영향을 미칠 수 있다.
# UDP Segment Structure

UDP 세그먼트 구조는 RFC 768에 정의되어 있으며 다음과 같다.
![[udp_segment_structure.png]]
**데이터 필드**에는 애플리케이션 데이터가 들어간다. 예를 들어, DNS의 경우 데이터 필드에 쿼리나 응답 메시지가 포함되고, 스트리밍 오디오 애플리케이션의 경우 오디오 샘플이 포함된다.

UDP **헤더**는 각각 2바이트로 구성된 네 개의 필드만으로 이루어져 있다.
- **포트 번호** 필드들은 목적지 호스트가 애플리케이션 데이터를 올바른 프로세스로 전달할 수 있도록 하는 역다중화 기능을 수행한다.
- **길이 필드**는 헤더와 데이터를 포함한 UDP 세그먼트의 바이트 수를 명시한다. 데이터 필드의 크기가 세그먼트마다 다를 수 있기 때문에 명시적인 길이 값이 필요하다.
- **체크섬**은 수신 호스트가 세그먼트에 오류가 발생했는지 확인하는 데 사용된다.
# UDP Checksum
UDP 체크섬은 **오류 검출** 기능을 제공한다. 즉, 체크섬은 UDP 세그먼트 내의 비트들이 출발지에서 목적지로 이동하는 동안 (예: 링크의 잡음이나 라우터 저장 중) 변경되었는지 여부를 판단하는 데 사용된다.

송신 측의 UDP는 세그먼트 내 모든 16비트 워드들의 합에 대해 1의 보수를 취하고, 합산 중 발생하는 오버플로는 다시 더한다(wrapped around). 이 결과를 UDP 세그먼트의 체크섬 필드에 넣는다. 예를 들어, 세 개의 16비트 워드 `0110011001100000`, `0101010101010101`, `1000111100001100`가 있다고 가정하자.

1. 처음 두 워드를 더한다: `0110011001100000 + 0101010101010101 = 1011101110110101`
2. 위의 합에 세 번째 워드를 더한다. 이때 오버플로가 발생하면 다시 더해준다: `1011101110110101 + 1000111100001100 = 1 0100101011000001` -> `0100101011000010`
3. 이 합의 1의 보수(모든 0을 1로, 1을 0으로 변환)를 취하면 체크섬이 된다: `1011010100111101`

수신 측에서는 체크섬을 포함한 모든 16비트 워드를 더한다. 패킷에 오류가 없다면, 수신 측에서의 합은 `1111111111111111`이 된다. 만약 결과에 0이 하나라도 있다면, 오류가 발생했음을 알 수 있다.

UDP가 체크섬을 제공하는 이유는, 하위의 모든 링크 계층 프로토콜이 오류 검사를 보장하지 않기 때문이며, 라우터 메모리에 저장되는 동안 비트 오류가 발생할 수도 있기 때문이다. 이는 시스템 설계에서 **종단 간 원칙(end-to-end principle)** 의 한 예이다. 
UDP는 오류를 검출하기는 하지만 오류를 복구하기 위한 조치는 취하지 않는다. 일부 구현에서는 손상된 세그먼트를 폐기하고, 다른 구현에서는 경고와 함께 애플리케이션에 전달한다.