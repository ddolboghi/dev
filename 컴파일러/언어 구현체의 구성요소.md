# 1. 스캐닝 (scanning; lexing; lexical analysis)
- 스캐너 (lexer)는 소스 파일에서 문자의 선형 스트림(linear stream)을 받아 단어에 더 가까운 연속적인 청크(chunk, 덩이/뭉치)들로 묶는다.
- 이 청크를 토큰이라고 한다.
- 스캐너는 정의에 따라 주석을 무시하고, 공백 문자 같이 의미 없는 토큰을 버리고 일련의 의미 있는 토큰들로 정리한다.
# 2. 파싱 (parsing, 구문 분석)
- 파서는 플랫한 일련의 토큰을 받아 문법 특유의 중첩된 성질을 반영하는 트리 구조로 만든다.
- 이 트리는 소스 언어의 원시 구문 구조에 얼마나 가까운지에 따라 parse tree, AST (Abstract Syntax Tree)로 구분된다.
- 트리는 보통 syntax tree, AST, tree라고 부른다.
- 파서는 syntax error를 알려준다.
# 3. 정적 분석
- 대부분의 언어 구현체는 **binding** 또는 **resolution**이라고 하는 분석작업을 가장 먼저 수행한다.
- 바인딩은 식별자마다 이름이 정의된 곳을 찾아 연결 짓는 행위다.
- 이때 소스 코드의 **스코프**를 통해 어떤 이름으로 어떤 선언을 참조할지 결정한다.
- **정적 타입 언어**: 바인딩 단계에서 타입 체크를 한다. 문법에 맞지 않는 타입이 발견되면 type error를 발생시킨다.
- **동적 타입 언어**: 런타임에 타입 체크를 한다.
## 시맨틱 정보 저장
분석을 통해 알아낸 모든 시멘틱 정보는 보관해야 한다.
- 구문 트리 자체의 속성(attribute)에 저장: 속성은, 파싱 중 초기화되지 않지만 나중에 채워지는 노드의 추가 필드다.
- 심볼 테이블(symbol table)에 저장: lookup table이라고도 하며, 이 테이블의 키는 대부분 식별자(변수 및 선언의 이름)다. 키에 매핑된 값은 식별자가 참조하고 있는 값이다.
- Intermediate Representation: 시맨틱이 더욱 직접적으로 표현된 새로운 자료 구조로 구문 트리를 변환한다.
> [!TIP]
    > 컴파일러는 각 단계별 작업이 다음 단계를 구현하기 쉽게 만드는 방향으로 사용자 코드를 나타내는, 일종의 데이터를 구성하는 파이프라인이라고 볼 수 있다.
    > 이 파이프라인의 프런트엔드는 '분석' 단계까지며, 소스 언어에 따라 달라진다. 백엔드는 프로그램이 최종 실행될 타깃 아키텍처에 따라 달라진다.
# 4. 중간 표현 (IR, Intermediate Representation)
- 분석을 통해 알아낸 시멘틱 정보를 보관하는 형태로, 소스 언어와 타깃 아키텍처(프로그램이 최종 실행될) 둘 다에 독립적이다.
- 잘 만들어진 IR 스타일: control flow graph, static single assignment, continuation passing style, three address code
- IR이 없으면 소스 언어마다 타깃 아키텍처를 위한 컴파일러를 일일이 개발해야 한다.
	- 예를 들어, IR이 없으면 x86, ARM, SPARC 아키텍처에서 실행되는 파스칼, C, 포트란을 위한 컴파일러 9개를 모두 구현해야 한다.
- 소스 언어마다 IR을 만들어내는 프런트엔드를 구현한 다음, 타깃 아키텍처마다 백엔드를 구현하는 방식으로 작업을 줄일 수 있다.
- 프런트엔드는 주로 GIMPLE, RTL 등의 몇몇 IR 중 하나를 만들어내고, 백엔드는 이런 IR을 가져와 타깃 아키텍처를 위한 네이티브 코드를 생성한다.
# 5. 최적화
- 시맨틱은 유지하면서 코드를 더 효율적으로 바꾸는 작업이다.
- 예를 들어 상수 폴딩(constant folding)은 항상 같은 값으로 평가되는 표현식을 컴파일 타임에 미리 평가해서 표현식 코드를 그 결괏값으로 대체하는 기법이다.
	```
	# before
	area = 3.14159 * (0.75 / 2) * (0.75 / 2);
	
	# after
	area = 0.4417860938;
	```
- 최적화 기법들: constant propagation, common subexpression elimination, loop invariant code motion, global vlaue numbering, strength reduction, scalar replacement of aggregates, dead code elimination, loop unrolling
- 몇몇 언어들은 최적화를 거의하지 않는다. Lua, CPython은 최적화가 덜 된 코드를 생성해서 주로 런타임에 성능을 높이려고 한다.
# 6. 코드 생성 (code gen)
- 컴파일러의 백엔드 영역에서 수행되며, CPU가 실행하는 코드를 생성한다. 그러므로 인간이 읽을 수 없다.
## 실제 CPU 명령어(기계어; 네이티브 코드)생성
- OS가 칩에 직접 로드할 수 있는 실행 파일이 나온다.
- 이렇게 생성된 파일은 매우 빠르게 실행되지만, 이 파일을 만드는 작업량 또한 많다.
- 컴파일러가 특정 아키텍처에 종속되어 이식성이 떨어진다.
## 가상 CPU 명령어 생성
- 실제 칩 명령어가 아닌, 가상의 이상적인 머신용 코드를 생성한다.
- 이 코드는 명령어 하나당 1 byte 길이여서 **bytecode**라고 부른다.
- 합성 명렁어(synthetic instruction)라고도 한다.
- 바이트코드는 언어의 시맨틱에 좀 더 가까워서 이식성이 높다.
- 바이트코드는 언어의 저수준 연산을 조밀하게 바이너리로 인코드한 것이라 볼 수 있다.
# 7. 가상 머신(Virtual Machine)
- **런타임에 가상의 아키텍처를 지원하는 가상의 칩을 에뮬레이트하는 프로그램**이다.
- VM에서 바이트코드를 실행하면 명령어를 하나하나 실행할 때마다 런타임에서 시뮬레이션해야 하기 때문에, 미리 네티티브 코드로 컴파일된 파일을 실행하는 것보다 느리다.
- 단순성과 이식성이 높다. 예를 들어, C로 VM을 구현하면 C 컴파일러가 있는 모든 플랫폼에서 해당 언어를 실행할 수 있다.

> [!NOTE]
    > 가상 머신의 다른 의미로, 전체 하드웨어 플랫폼과 운영 체제를 소프트웨어로 에뮬레이트하는 것이 있다. 언어 구현체에서 사용되는 가상 머신은 이와 다른 언어 가상 머신 또는 프로세스 가상 머신이다.

> [!TIP]
    > 아키텍처에 종속적인 작업을 컴파일러 파이프라인의 뒷 단계로 밀어낼수록, 더 많은 이전 단계를 다양한 아키텍처에서 공유할 수 있다.
    > 레지스터 할당, 명령어 선택 등의 최적화는 특정 칩의 강점과 기능을 알고 있어야 잘 작동한다.
    > 컴파일러의 어느 부분을 공유할지, 어느 부분을 타깃 아키텍처(칩)마다 다른 방향으로 가야 할지 결정하는 것이 기술이다.

# 8. 런타임
- 기계어로 컴파일했다면 운영 체제가 실행 파일을 로드하여 프로그램을 실행하도록 한다.
- 바이트코드로 컴파일했다면 VM을 기동시켜 프로그램을 로드한다.
- 메모리를 자동으로 관리하는 언어라면, 미사용 메모리를 회수하는 가비지 컬렉터가 필요하다.
- 프로그램 실행 중에 객체 타입을 테스트하는 기능이 지원되는 언어라면, 실행 중에 각 객체의 타입을 추적하는 데 몇 가지 표현이 필요하다.
- 컴파일 언어에서 런타임을 구현한 코드는 결과 실행 파일에 직접 삽입된다. 예를 들어, 런타임 사본을 내부에 갖고 있거나 인터프리터나 VM 내부에서 실행되는 언어는 런타임도 이 내부에 상주한다.