- 컴파일러 또는 인터프리터의 첫 단계는 scanning이다.
- 스캐너는 원시 소스 코드를 일련의 문자로 입력받아 토큰이라는 여러 청크들로 묶는다.
	- 옛날에는 디스크에서 원시 소스 코드 문자를 읽어 메모리에 버퍼링하는 코드 조각을 스캐너라 하고, 그렇게 읽은 문자를 가져와 어떤 유용한 일을 하는 후속 단계를 lexing이라고 했지만 오늘날 컴파일러에서 두 단계를 구별할 필요는 없다.
- 청크는 언어의 문법을 구성하는, 유의미한 **단어**와 **문장 부호(punctuation)** 다.
- 스캐너의 핵심은 루프로, 소스 코드 끝부분(또는 라인 끝부분)에 이를 때까지 끊임없이 문자들을 읽으면서 가끔씩 토큰을 뱉어내는 것이다.
	1. 소스 코드의 첫 번째 문자부터 읽기 시작하여 그 문자가 어느 lexeme에 해당하는지 파악한다.
	2. 문자 및 lexeme의 일부에 해당하는 그다음 문자가 있으면 소비하고, lexeme 끝에 도달하면 토큰을 내보낸다.
	3. 루프 처음으로 돌아가 소스 코드의 그다음 문자부터 이를 반복한다.
# lexeme
- 렉시컬 분석은 문자열을 스캐닝해서 의미가 있는 가장 작은 시퀀스로 묶는다.
- 렉시컬 분석으로 묶어낸 시퀀스(문자 덩어리)를 lexeme(어휘소)이라고 한다.
```lox
var language = "lox";
```
- 이 코드에서 lexeme은 `var`, `language`, `=`, `"lox"`, `;`다.
- 렉심과 그 렉심의 종류를 나타내는 데이터를 묶으면 토큰이 된다.
### 숫자 리터럴
- 숫자 리터럴은 숫자로만 시작된다. `-123`은 숫자 리터럴이 아닌, 숫자 리터럴 `123`에 `-`를 적용한 표현식이다.
### 예약어와 식별자
- **maximal munch(최대한 잘라먹기)**: 스캐너가 읽어 들인 코드 청크와 두 렉시컬 문법이 모두 매치될 경우 '가장 많은 문자가 매치된 쪽이 승리'한다는 규칙이다.
- 식별자(identifier)는 사용자가 직접 이름을 지어 만든 것으로, 변수, 함수, 클래스, 모듈 등 사용자가 정의하는 모든 이름을 의미한다.
- 예약어(reserved word)는 언어 자신이 사용하겠다고 미리 예약한 식별자의 한 종류일 뿐이다.
- 예약어는 식별자의 lexeme이 예약어 중 하나인지 확인하는 식으로 처리한다.
# 토큰
- 문자열을 비교해서 원시 렉심에서 토큰을 분류하는 건 너무 느리다.
- 대신 렉심을 인식하는 시점에 그 렉심이 어떤 종류인지, 즉 토큰 타입을 기억한다.
- 스캐너는 리터럴의 각 문자를 탐색하며 정확하게 식별해야 하므로, 값의 텍스트 표현을 나중에 인터프리터가 사용할 라이브 런타임 객체로 변환할 수도 있다.
- 렉심마다 정규식을 정의하여 문자 시퀀스를 매치하면 어떤 종류의 렉심인지 쉽게 구별할 수 있다.
- **lexical grammar**: 어떤 언어에서 문자를 렉심으로 묶는 규칙
- 관련 이론: Chomsky hierarchy, finite-state machine
