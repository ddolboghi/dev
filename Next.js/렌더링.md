# 렌더링 환경
- 클라이언트: 애플리케이션 코드에 대한 요청을 서버로 보내는 사용자 디바이스의 **브라우저**를 말합니다. 그런 다음 서버의 응답을 사용자 인터페이스로 변환합니다.
- 서버: 애플리케이션 코드를 저장하는 데이터 센터의 컴퓨터를 의미하며, 백엔드가 아닌, **프론트엔드 자체의 서버**입니다. 클라이언트로부터의 요청을 받아 적절한 응답을 전송합니다.

> [!warning] `'use server'`와 함께 정의한 함수의 파라미터와 리턴값은 모두 직렬화 가능해야합니다.
# 네트워크 경계
- **클라이언트 모듈 그래프**와 **서버 모듈 그래프** 사이입니다.
	- 클라이언트 모듈 그래프에는 클라이언트에서 렌더링되는 모든 컴포넌트가 포함되고, 서버 모듈 그래프에는 서버에서 렌더링되는 모든 컴포넌트가 포함됩니다.
# 하이브리드 애플리케이션 구축하기
- 애플리케이션의 코드 흐름을 **단방향**으로 생각하는 것이 도움이 됩니다. 다시 말해, 응답 중에 애플리케이션 코드는 **서버 -> 클라이언트** 한 방향으로 흐릅니다
- 클라이언트에서 서버에 접근해야 할 경우, 동일한 요청을 재사용하는 대신 서버에 **새로운** 요청을 보냅니다. 이렇게 하면 컴포넌트를 어디에 렌더링할지와 네트워크 경계를 어디에 둘지를 이해하기 더 쉽습니다.
# 서버 컴포넌트
- nextjs는 기본적으로 서버 컴포넌트를 사용하기 때문에, 따로 설정할 필요없이 서버 렌더링이 자동으로 구현됩니다.
- 필요하다면 클라이언트 컴포넌트를 사용할 수 있습니다.
## 서버 렌더링의 장점
- 데이터 페칭: 서버 컴포넌트는 데이터 소스(DB)에 더 가깝게, 서버로 데이터 페칭을 이동할 수 있습니다. 이는 렌더링에 필요한 데이터를 가져오는 데 걸리는 시간과 클라이언트가 요청하는 횟수를 줄여 성능을 향상시킬 수 있습니다.
- 보안: 서버 컴포넌트는 토큰이나 API 키등 민감한 데이터나 로직을 서버에 두기 때문에 클라이언트에 노출 위험이 없습니다.
- 캐싱: 서버에서 렌더링된 결과는 캐시되고 후 요청과 전체 사용자에서 재용될 수 있습니다. 이는 각 요청에 대한 렌더링과 데이터 페칭의 양을 줄여 비용을 줄이고 성능을 향상시킵니다.
- 번들 사이즈: 서버 컴포넌트를 사용하면 이전에는 클라이언트 JavaScript 번들 크기에 영향을 미쳤던 대규모 dependency를 서버에서 유지할 수 있습니다. 이는 서버 컴포넌트용 javascript를 다운로드하고 파싱하고 실행하지 않도록해서 느린 인터넷이나 낮은 성능의 디바이스를 가진 사용자에게 좋습니다.
- 초기 페이지 로드와 [First Contentful Paint(FCP)](https://web.dev/articles/fcp?hl=ko): 서버에서 HTML을 생성할 수 있습니다.
- SEO 및 소셜 네트워크 공유가능성: 렌더링된 HTML은 검색 엔진 봇이 페이지를 인덱스하고 소셜 네트워크 봇이 페이지의 소셜 카드 미리보기를 생성하는데 사용될 수 있습니다.
- Streaming: 서버 컴포넌트는 렌더링 작업을 chunk로 나눠 준비되면 클라이언트로 스트리밍할 수 있습니다. 이는 사용자가 전체페이지가 서버에서 렌더링될때까지 기다리않고 페이지의 일부를 볼 수 있도록 합니다.
## 서버 컴포넌트 렌더링 원리
- nextjs는 리액트 API를 사용해 렌더링합니다.
- 렌더링은 라우트 세그먼트와 서스펜스 경계([[React 기초#`<Suspense>`]])에 의한 chunk들로 나눠집니다.
- 각 chunk는 다음 두 단계로 렌더링됩니다:
	1. 리액트는 react server component payload(RSC Payload)라 불리는 특별한 데이터 형태로 서버 컴포넌트를 렌더링합니다.
	2. nextjs는 RSC Payload와 클라이언트 컴포넌트의 js 명령어를 사용하여 서버에서 HTML을 렌더링합니다.
	
- 그러면 클라이언트에서는:
	1. HTML은 해당 라우트의 상호작용이 없는 페이지를 즉시 보여주는데 사용됩니다. 이는 초기 페이지 로드시에만 적용됩니다.
	2. React Server Component Payload는 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트하는데 사용됩니다.
	3. js 명령어는 클라이언트 컴포넌트를 hydrate하는데 사용되며, 이로인해 애플리케이션이 인터렉티브해집니다.

> [!info] React Server Component Payload (RSC Payload)
> - RSC Payload는 렌더링된 리액트 서버 컴포넌트 트리의 압축된 바이너리 표현입니다.
> - RSC Payload는 클라이언트에서 리액트가 브라우저의 DOM을 업데이트하는데 사용됩니다.
> - RSC Payload는 다음을 포함합니다:
> 	- 서버 컴포넌트의 렌더링 결과
> 	- 클라이언트 컴포넌트가 렌더링될 위치와 해당 자바스크립트 파일에 대한 참조를 위한 placeholder
> 	- 서버 컴포넌트에서 클라이언트 컴포넌트로 전달되는 모든 props
## nextjs의 서버 렌더링 전략 3가지
### 정적 렌더링(기본 전략)
- 정적 렌더링에서 라우트는 빌드 시 또는 데이터 재검증([[데이터 페치하기#데이터 재검증(revalidating)]])후 백그라운드에서 렌더링됩니다.
- 정적 렌더링된 결과는 캐시되고 [CDN](https://developer.mozilla.org/ko/docs/Glossary/CDN)에 넣어질 수 있습니다.
- 이로 인해 사용자와 서버 요청 사이에서 렌더링 결과를 공유할 수 있습니다.
- 라우트가 사용자 개인정보가 아니거나 빌드 시 알 수 있는 데이터(블로그 글, 상품 페이지)를 가질때 유용합니다.
### 동적 렌더링
- 각각의 사용자가 요청할때마다 라우트가 렌더링됩니다.
- 라우트가 사용자 개인정보 또는 요청 시에만 알 수 있는 데이터(쿠키, URL 파라미터)를 가질때 유용합니다.

> [!note] 캐시된 데이터와 동적 라우트
> 대부분의 웹사이트는 정적 렌더링과 동적 렌더링을 함께 사용합니다.
> nextjs에서 캐시된 데이터와 캐시되지 않은 데이터를 가진 동적으로 렌더링된 라우트를 만들 수 있습니다. 
> 이는 RSC Payload와 부분적으로 캐시된 데이터 덕분입니다. 
> 이로인해 모든 데이터를 가져오는 요청 시 성능 걱정 없이 동적 렌더링을 사용할 수 있습니다.
#### 동적 렌더링으로 자동 전환
- 렌더링 중 동적 함수나 캐시되지 않는 데이터 요청이 발견되면 nextjs는 전체 라우트를 동적으로 렌더링하도록 전환합니다.

| Dynamic Functions | Data       | Route  |
| ----------------- | ---------- | ------ |
| No                | Cached     | 정적 렌더링 |
| Yes               | Cached     | 동적 렌더링 |
| No                | Not Cached | 동적 렌더링 |
| Yes               | Not Cached | 동적 렌더링 |
- 정적 렌더링되기 위해서는 모든 데이터가 캐시되어야 하지만, 동적 렌더링은 캐시되거나 캐시되지 않는 데이터 페칭 둘 다 사용할 수 있습니다.
- nextjs가 자동으로 최적의 렌더링 방식을 선택하기 때문에 개발자가 렌더링 방식을 직접 선택하지 않아도 됩니다. 대신 **언제 데이터를 캐시할지, 또는 revalidate할지만 지정하면 됩니다.** 그리고 UI 일부를 stream하도록 지정할 수도 있습니다.
##### dynamic functions
- 동적 함수는 요청 시에만 알 수 있는 정보와 관계있습니다:
	- `cookies()`, `headers()`를 서버 컴포넌트에서 사용하면, 전체 라우트를 동적 렌더링합니다.
	- `searchParams`는 [`page`컴포넌트 의 prop](https://nextjs.org/docs/app/api-reference/file-conventions/page)이며, 사용 시 `page`를 동적 렌더링합니다.
### streaming
- 스트리밍은 서버로부터 UI를 점진적으로 렌더링합니다.
- UI를 chunk들로 나누고 준비되면 클라이언트로 스트리밍합니다.
- 스트리밍을 사용하면 사용자가 페이지의 전체 컨텐츠가 렌더링되기 전에 페이지의 일부를 볼 수 있습니다.
	![[redering-strategy-streaming.png]]
- 스트리밍은 기본적으로 App Router에 내장되어 있습니다. 이를 통해 초기 페이지 로딩 성능은 물론 느린 데이터 페칭 때문에 전체 경로의 렌더링을 차단하는 UI를 개선할 수 있습니다.(e.g. 제품 페이지의 리뷰)
- 스트리밍 라우트 세그먼트는 `loading.js`로 정의되며, UI 컴포넌트는 리액트의 `<Suspense>`([[React 기초#`<Suspense>`]])를 사용합니다.
# 클라이언트 컴포넌트
- 클라이언트 컴포넌트는 [서버에 미리 렌더링되고](https://github.com/reactwg/server-components/discussions/4), 브라우저에서 클라이언트 측 자바스크립트를 사용합니다.
- 클라이언트 컴포넌트는 `useState`, `useEffect`, 이벤트리스너를 사용해 사용자에게 즉각적인 피드백을 제공하고 UI를 업데이트할 수 있습니다.
- 클라이언트 컴포넌트는 브라우저API에 접근할 수 있습니다.(위치정보, 로컬스토리지)
- nextjs에서 파일 최상단에 `'use client'`를 작성하여 클라이언트 컴포넌트로 사용합니다.
- `'use client'`는 서버와 클라이언트 컴포넌트 모듈간 경계를 지정하기 위해 사용됩니다.
- **`'use client'`를 작성한 파일에 import한 다른 모듈, children들은 모두 클라이언트 번들의 일부로 간주됩니다.**
## 전체 페이지 로드의 일부일때
- 첫 페이지 로드를 최적화하기 위해, nextjs는 리액트API를 사용하여 클라이언트와 서버 컴포넌트 둘다 서버에서 정적 HTML을 렌더링합니다.
- 서버에서:
	1. 리액트는 React Server Component Payload라는 데이터 형태로 서버 컴포넌트를 렌더링합니다. 이때 서버 컴포넌트는 클라이언트 컴포넌트를 참조합니다.
	2. nextjs는 RSC Payload와 클라이언트 컴포넌트의 js 명령어를 이용해 라우트에 따라 HTML을 렌더링합니다. 
- 클라이언트에서:
	1. 라우트의 상호작용할 수 없는 HTML 페이지를 즉시 보여줍니다.
	2. RSC Payload는 클라이언트와 서버 컴포넌트 트리를 조정하고 DOM을 업데이트하는데 사용됩니다.
	3. js 명령어는 클라이언트 컴포넌트를 hydrate합니다.
## subsequent navigation
