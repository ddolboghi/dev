# 컴파일러 종류
- JIT 컴파일러와 AOT(Ahead-of-Time)컴파일러 (java 9부터)는 **JVM**에 포함되어 있습니다.
- .java 파일을 바이트 코드(.class)로 컴파일하는 javac 컴파일러는 **JDK**에 포함되어 있습니다.
- .java 파일은 javac 컴파일러를 통해 바이트 코드(.class)로 변환됩니다.
- JIT 컴파일러를 통해 바이트 코드가 기계어로 변환됩니다.
- AOT 컴파일러는 프로그램 실행 전에 바이트 코드를 기계어로 변환합니다.
# JVM의 동작 방식
운영체제 측면에서, JVM 자체는 운영체제의 일반 프로세스로 실행됩니다.
- JVM이 사용하는 힙, 메서드 영역, 스택 등은 운영체제로부터 할당받은 메모리 영역에 배치됩니다.
- 다이렉트 메모리의 경우 종종 JVM 힙을 거치지 않고 운영체제의 메모리를 직접 사용하기도 합니다.
- JVM 내부의 스레드는 대부분 운영체제의 네이티브 스레드에 1:1로 매핑됩니다.
- 실제 스레드 스케줄링은 대부분 운영체제의 스케줄러에 의해 관리됩니다.
- JVM이 네이티브 메서드를 실행할때는 운영체제의 라이브러리나 기능을 직접 호출합니다.
# 1. 바이트 코드 컴파일(.java -> .class)
- .java 파일이 javac 같은 프런트엔드 컴파일러에 의해 처리됩니다.
- javac 컴파일러는 어휘분석, 구문분석을 거쳐 추상 구문 트리(AST)를 생성한 다음, 바이트 코드 명령어 스트림을 생성합니다.
- javac 컴파일러는 문법 검사를 수행하여 generic, auto-boxing/unboxing 같은 문법을 원래의 기본적인 문법 구조로 되돌립니다.
- javac 컴파일 결과물은 플랫폼에 독립적인 바이트코드이며, [[class 파일]] 형태로 저장됩니다.
- javac 컴파일 과정에는 Linking 단계가 없습니다. JVM이 .class 파일을 로드할때 Dynamic Linking이 발생합니다.
# 2. 바이트 코드 실행(by JVM)
- 컴파일된 .class 파일은 JVM 위에서 실행됩니다.
- JVM은 .class 파일을 실행하기 위해 클래스 로딩 서브시스템, 런타임 데이터 영역, 실행 엔진 등을 사용합니다.
## 클래스 로딩
- JVM이 특정 클래스가 필요할 때, 클래스 로더 서브시스템이 .class 파일을 메모리로 로드합니다.
- 클래스 로딩은 로딩(loading), 검증(verification), 준비(preparation), 파싱/해석(resolution), 초기화(initialization)의 단계를 거칩니다.
	- 검증: 클래스 파일의 바이트코드가 유효하고 안전한지 확인하는 매우 중요한 단계이며, 시스템 보안에 필수적입니다.
	- 준비: 클래스 변수(static field)에 메모리를 할당하고 기본값을 설정합니다.
	- 해석: .class 파일의 상수 풀에 있는 심볼릭 참조를 메모리상의 직접 참조로 변환합니다.(dynamic linking)
	- 초기화: 클래스의 클래스 변수 초기화 코드와 static 블록을 실행합니다. 이는 new 키워로 인스턴스 생성, static 멤버 접근 등의 조건에 의해 트리거됩니다.
- 일반적으로 부모 위임 모델(Parent Delegation Model)을 사용하여 클래스 로더 간의 우선순위를 정하고, java.lang.Object와 같은 핵심 클래스가 중복 로딩되지 않도록 보장합니다.
- JDK 9부터는 **Java 모듈 시스템(JPMS)** 이 도입되어 클래스 로딩 아키텍처가 변경되었으며, **모듈 기반의 캡슐화/격리 메커니즘**이 지원됩니다.
## JVM 런타임 데이터 영역
JVM이 프로그램을 실행하면서 관리하는 메모리 영역들입니다.
### 프로그램 카운터(PC; Program Counter)
스레드마다 독립적인 작은 메모리 공간으로, 현재 스레드가 실행할 **바이트코드 명령어의 주소**를 가리킵니다. 스레드 전환 후 올바른 위치로 돌아오는 데 사용됩니다. OutOfMemoryError가 발생하지 않는 유일한 영역입니다.
### Java 가상 머신 스택(Java Virtual Machine Stack)
스레드마다 독립적이며, **스택 프레임(Stack Frame)** 을 저장합니다. 메서드가 호출될 때마다 스택 프레임이 스택에 쌓이고, 메서드 실행이 끝나면 스택에서 제거됩니다. 스택 프레임은 메서드의 지역 변수 테이블, 오퍼랜드 스택, 동적 연결 정보, 메서드 반환 주소 등을 포함합니다.
### 네이티브 메서드 스택(Native Method Stack)
Java 메서드가 아닌 네이티브 메서드 실행을 위해 사용되는 스택입니다.
### Java 힙(Java Heap)
모든 스레드가 공유하는 메모리 영역으로, 대부분의 객체 인스턴스가 생성되는 공간입니다. **가비지 컬렉션(GC)** 의 주요 대상입니다.
### 메서드 영역
모든 스레드가 공유하는 메모리 영역으로, **클래스 정보**(클래스 구조, 상수 풀, 필드 및 메서드 정보 등)를 저장합니다. GC 대상이 될 수 있지만, 힙에 비해 효율이 낮습니다.
JDK 8부터 영구 세대(PermGen)가 메타스페이스(Metaspace)로 대체되었습니다..
### 런타임 상수 풀(Runtime Constant Pool)
메서드 영역의 일부이며, 클래스 파일의 상수 풀이 런타임에 로드되어 저장됩니다. 메서드/필드의 심볼릭 참조 등이 여기에 있으며, 동적 연결 시 해석됩니다.
### 다이렉트 메모리(Direct Memory)
JVM 명세에 정의된 런타임 데이터 영역은 아니지만, NIO 사용 시 OS 메모리를 직접 할당하여 사용하며 OutOfMemoryError를 발생시킬 수 있습니다.
## 실행 엔진
- 런타임 데이터 영역에 배치된 바이트코드 명령어를 실행하는 역할을 합니다20.
- 일반적으로 **인터프리터(Interpreter)** 와 **JIT(Just-In-Time) 컴파일러**를 **혼합**하여 사용합니다.
- 인터프리터는 바이트코드 명령어를 하나씩 읽어서 실행합니다. 개념적으로 스택 기반 명령어 집합으로 동작합니다.
- JIT 컴파일러는 **Hot Spot(빈번하게 실행되는 코드)** 을 탐지하여, 해당 바이트코드를 실시간으로 네이티브 머신 코드로 컴파일합니다. JIT 컴파일은 백그라운드 스레드에서 진행됩니다.
- JIT 컴파일된 네이티브 코드는 특정 운영체제 및 하드웨어에 최적화되며, 가상 메서드 인라인(Virtual Method Inlining)을 위한 CHA(Class Hierarchy Analysis), 스택 할당 및 동기화 제거를 위한 Escape Analysis 등 다양한 최적화 기법이 적용될 수 있습니다.
- 코드가 JIT 컴파일되면, JVM은 인터프리터 실행 대신 네이티브 코드를 실행하여 성능을 향상시킵니다.
### AOT(Ahead-of-Time) 컴파일러
- AOT 컴파일러는 애플리케이션의 시작 시간을 단축시키고, 런타임 성능을 개선합니다.
- AOT 컴파일은 실행 시점의 컴파일 지연을 없애고, 메모리 사용량을 줄입니다.
- GraalVM은 Java뿐만 아니라 다양한 언어를 지원하는 고성능 Polyglot 런타임으로, AOT 컴파일을 포함한 다양한 최적화 기술을 제공하여 애플리케이션의 실행 속도와 메모리 사용량을 크게 개선합니다.
- GraalVM의 Substrate VM은 더 나아가 JVM 없이 실행되는 네이티브 실행 파일을 생성하는 데 중점을 둡니다.