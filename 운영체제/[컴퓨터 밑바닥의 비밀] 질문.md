---
Created: 2024-11-07
---
### 41-74p
- JVM안에 컴파일러가 포함되있는 것인가?
> JIT 컴파일러와 AOT(Ahead-of-Time)컴파일러 (java 9부터)가 포함되어 있습니다.
> AOT 컴파일러는 명시적으로 설정할때만 사용되며, spring native나 GraalVM Native Image를 빌드할때 사용됩니다.
- .java 파일은 어떻게 컴파일되고 JVM을 통해 실행되나?
> .java 파일은 javac 컴파일러를 통해 바이트 코드(.class)로 변환됩니다. javac 컴파일러는 JVM에 포함되어있지 않고, JDK의 일부입니다. JVM 안에 JIT 컴파일러를 통해 바이트 코드가 기계 명령어로 변환됩니다.
### 65-66p
- 링커의 symbol resolution(해석)단계에서, 어떻게 여러 object file(대상 파일)들에서 동일한 유형의 영역끼리 합칠 수 있는가?
- 링커의 symbol resolution(해석)단계에서, 각 유형의 영역이 모두 결합되면 어떻게 모든 기계 명령어와 전역 변수의 런타임 메모리 주소를 결정할 수 있는가?
> 프로그램의 프로세스가 가상 메모리에 적재되어 실행되기 때문입니다. 가상 메모리는 표준화되어있기 때문에 링커가 런타임 메모리 주소를 미리 알 수 있습니다.
- 링커는 어떻게 가상 메모리 주소를 결정하는가? 가상 메모리 구조를 따라 임의로 지정하는가? 아니면 가이드라인 같은 걸 참고하는가?
### 153-159p
- Node.js는 싱글 스레드인데 어떻게 비동기 호출이 가능한가?
> [!NOTE]
> Node.js는 싱글 스레드(Event Loop)로 동작하지만, 실제로는 내부적으로 다음과 같은 구성요소들이 함께 작동합니다:
> - Event Loop (메인 스레드)
> - Worker Threads Pool (libuv 라이브러리)
> - Thread Pool (백그라운드 작업용)
>
 >비동기 작업이 처리되는 과정:
> ```
 >파일 읽기 요청 → Event Loop가 요청 수신 
>→ Worker Thread에 작업 위임 
>→ Event Loop는 다른 작업 처리 
>→ 파일 읽기 완료 시 Callback 실행`
>```
 >- Event Loop가 Non-blocking I/O 작업들을 Worker Threads에 분배
 >- CPU 집약적 작업은 Thread Pool을 활용
 >- libuv 라이브러리가 운영체제 수준의 비동기 작업 처리 
