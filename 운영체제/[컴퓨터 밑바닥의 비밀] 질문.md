---
Created: 2024-11-07
---
# JVM안에 컴파일러가 포함되있는 것인가?
JIT 컴파일러와 AOT(Ahead-of-Time)컴파일러 (java 9부터)가 포함되어 있습니다.
AOT 컴파일러는 명시적으로 설정할때만 사용되며, spring native나 GraalVM Native Image를 빌드할때 사용됩니다.
# .java 파일은 어떻게 컴파일되고 JVM을 통해 실행되나?
운영체제 측면에서, JVM 자체는 운영체제의 일반 프로세스로 실행됩니다.
JVM이 사용하는 힙, 메서드 영역, 스택 등은 운영체제로부터 할당받은 메모리 영역에 배치됩니다.
다이렉트 메모리의 경우 종종 JVM 힙을 거치지 않고 운영체제의 메모리를 직접 사용하기도 합니다.
JVM 내부의 스레드는 대부분 운영체제의 네이티브 스레드에 1:1로 매핑됩니다.
실제 스레드 스케줄링은 대부분 운영체제의 스케줄러에 의해 관리됩니다.
JVM이 네이티브 메서드를 실행할때는 운영체제의 라이브러리나 기능을 직접 호출합니다.

.java 파일은 javac 컴파일러를 통해 바이트 코드(.class)로 변환됩니다. javac 컴파일러는 JVM에 포함되어있지 않고, JDK의 일부입니다. JVM 안에 JIT 컴파일러를 통해 바이트 코드가 기계 명령어로 변환됩니다.
1. 컴파일 단계(.java -> .class)
	- .java 파일이 Javac 같은 프런트엔드 컴파일러에 의해 처리됩니다.
	- Javac 컴파일러는 어휘분석, 구문분석을 거쳐 추상 구문 트리(AST)를 생성한 다음, 바이트 코드 명령어 스트림을 생성합니다.
	- Javac 컴파일러는 문법 검사를 수행하여 generic, auto-boxing/unboxing 같은 문법을 원래의 기본적인 문법 구조로 되돌립니다.
	- Javac 컴파일 결과물은 플랫폼에 독립적인 바이트코드이며, [[class 파일]] 형태로 저장됩니다.
	- Javac 컴파일 과정에는 Linking 단계가 없습니다. JVM이 .class 파일을 로드할때 Dynamic Linking이 발생합니다.
2. 실행 단계(.class by JVM)
	- 컴파일된 .class 파일은 JVM 위에서 실행됩니다.
	- JVM은 .class 파일을 실행하기 위해 클래스 로딩 서브시스템, 런타임 데이터 영역, 실행 엔진 등의구성 요소를 사용합니다.
	- 클래스 로딩
		- JVM이 특정 클래스가 필요할 때, 클래스 로더 서브시스템이 .class 파일을 메모리로 로드합니다.
		- 클래스 로딩은 로딩(loading), 검증(verification), 준비(preparation), 파싱/해석(resolution), 초기화(initialization)의 단계를 거칩니다.
			- 검증: 클래스 파일의 바이트코드가 유효하고 안전한지 확인하는 매우 중요한 단계이며, 시스템 보안에 필수적입니다.
			- 준비: 클래스 변수(static field)에 메모리를 할당하고 기본값을 설정합니다.
			- 해석: .class 파일의 상수 풀에 있는 심볼릭 참조를 메모리상의 직접 참조로 변환합니다.(dynamic linking)
			- 초기화: 클래스의 클래스 변수 초기화 코드와 static 블록을 실행합니다. 이는 new 키워로 인스턴스 생성, static 멤버 접근 등의 조건에 의해 트리거됩니다.
		- 일반적으로 부모 위임 모델(Parent Delegation Model)을 사용하여 클래스 로더 간의 우선순위를 정하고, java.lang.Object와 같은 핵심 클래스가 중복 로딩되지 않도록 보장합니다.
		- JDK 9부터는 **Java 모듈 시스템(JPMS)** 이 도입되어 클래스 로딩 아키텍처가 변경되었으며, **모듈 기반의 캡슐화/격리 메커니즘**이 지원됩니다.
	- JVM 런타임 데이터 영역 (JVM Runtime Data Areas)
		- JVM이 프로그램을 실행하면서 관리하는 메모리 영역들입니다.
		- 프로그램 카운터(Program Counter - PC): 스레드마다 독립적인 작은 메모리 공간으로, 현재 스레드가 실행할 바이트코드 명령어의 주소를 가리킵니다. 스레드 전환 후 올바른 위치로 돌아오는 데 사용됩니다. OutOfMemoryError가 발생하지 않는 유일한 영역입니다.
		- Java 가상 머신 스택(Java Virtual Machine Stack): 스레드마다 독립적이며, **스택 프레임(Stack Frame)** 을 저장합니다. 메서드가 호출될 때마다 스택 프레임이 스택에 쌓이고, 메서드 실행이 끝나면 스택에서 제거됩니다. 스택 프레임은 메서드의 지역 변수 테이블, 오퍼랜드 스택, 동적 연결 정보, 메서드 반환 주소 등을 포함합니다.
		- 네이티브 메서드 스택(Native Method Stack): Java 메서드가 아닌 네이티브 메서드 실행을 위해 사용되는 스택입니다.
		- Java 힙(Java Heap): 모든 스레드가 공유하는 메모리 영역으로, 대부분의 객체 인스턴스가 생성되는 공간입니다. **가비지 컬렉션(GC)** 의 주요 대상입니다.
		- 메서드 영역(Method Area): 모든 스레드가 공유하는 메모리 영역으로, **클래스 정보(클래스 구조, 상수 풀, 필드 및 메서드 정보 등)** 를 저장합니다. GC 대상이 될 수 있지만, 힙에 비해 효율이 낮습니다. (JDK 8부터 영구 세대(PermGen)가 메타스페이스(Metaspace)로 대체되었습니다)
		- 런타임 상수 풀(Runtime Constant Pool): 메서드 영역의 일부이며, 클래스 파일의 상수 풀이 런타임에 로드되어 저장됩니다. 메서드/필드의 심볼릭 참조 등이 여기에 있으며, 동적 연결 시 해석됩니다.
		- 다이렉트 메모리(Direct Memory): JVM 명세에 정의된 런타임 데이터 영역은 아니지만, NIO 사용 시 OS 메모리를 직접 할당하여 사용하며 OutOfMemoryError를 발생시킬 수 있습니다.
	- 실행 엔진 (Execution Engine)
		- 런타임 데이터 영역에 배치된 바이트코드 명령어를 실행하는 역할을 합니다20.
		- 일반적으로 **인터프리터(Interpreter)** 와 JIT(Just-In-Time) 컴파일러를 혼합하여 사용합니다.
		- 인터프리터는 바이트코드 명령어를 하나씩 읽어서 실행합니다. 개념적으로 스택 기반 명령어 집합으로 동작합니다.
		- JIT 컴파일러는 **Hot Spot(빈번하게 실행되는 코드)** 을 탐지하여, 해당 바이트코드를 실시간으로 네이티브 머신 코드로 컴파일합니다. JIT 컴파일은 백그라운드 스레드에서 진행됩니다.
		- JIT 컴파일된 네이티브 코드는 특정 운영체제 및 하드웨어에 최적화되며, 가상 메서드 인라인(Virtual Method Inlining)을 위한 CHA(Class Hierarchy Analysis), 스택 할당 및 동기화 제거를 위한 Escape Analysis 등 다양한 최적화 기법이 적용될 수 있습니다.
		- 일단 코드가 JIT 컴파일되면, JVM은 인터프리터 실행 대신 네이티브 코드를 실행하여 성능을 향상시킵니다.
		- 최근에는 AOT(Ahead-of-Time) 컴파일 방식도 주목받고 있습니다. Jaotc와 같은 도구는 프로그램 실행 전에 바이트코드를 네이티브 라이브러리로 미리 컴파일하여 시작 시간 단축 및 준비 시간 감소를 목표로 합니다. Graal VM의 Substrate VM은 더 나아가 JVM 없이 실행되는 네이티브 실행 파일을 생성하는 데 중점을 둡니다.

# 링커의 symbol resolution(해석)단계에서, 어떻게 여러 object file(대상 파일)들에서 동일한 유형의 영역끼리 합칠 수 있는가?
링커가 여러 object file에서 동일한 유형의 영역을 합치는 과정:
1. object file 구조 이해
	- 텍스트 세그먼트 (Text segment): 기계어 코드를 포함합니다. 다른 파일에 대한 미해결 참조 때문에 실행 불가능할 수 있습니다.
	- 데이터 세그먼트 (Data segment): 프로그램의 데이터(예: 전역 변수)의 이진 표현을 포함합니다. 이 데이터 또한 다른 파일에 대한 미해결 참조 때문에 불완전할 수 있습니다.
	- 재배치 정보 (Relocation information): 프로그램이 메모리에 로드될 때 변경되어야 하는 절대 주소에 의존하는 명령어 및 데이터 단어를 식별합니다. 어셈블러는 각 파일을 독립적으로 어셈블하므로, 최종 메모리 위치를 알지 못하기 때문에 이 정보가 필요합니다.
	- 심볼 테이블 (Symbol table): 해당 파일에 정의된 레이블의 이름과 주소를 연결하고, 미해결 참조(다른 파일에 정의된 외부 레이블) 목록을 포함합니다.

2. 메모리 배치 계획 (Symbolically place code and data modules)
	- 링커는 먼저 입력받은 모든 오브젝트 파일과 라이브러리에서 코드와 데이터를 가져와 실행 파일에서 차지할 메모리 레이아웃을 계획합니다.
	- 링커가 각 모듈이 차지할 메모리 위치를 결정하고, 실행 파일에 코드와 데이터를 복사하는 과정을 통해 논리적으로 모든 오브젝트 파일의 텍스트 세그먼트를 모아서 실행 파일의 텍스트 세그먼트 영역에 배치하고, 데이터 세그먼트를 모아서 실행 파일의 데이터 세그먼트 영역에 배치함을 유추할 수 있습니다. MIPS 시스템의 소프트웨어 규칙에 따른 메모리 배치(코드 영역, 데이터 영역 등)가 예시입니다.
3. 주소 결정 (Determine the addresses of data and instruction labels)
	- 링커는 계획된 메모리 레이아웃에 따라 프로그램 전체에서 모든 레이블(코드 레이블, 데이터 레이블)의 최종 절대 메모리 주소를 결정합니다.
	- 여기에는 오브젝트 파일 내에서 정의된 지역 레이블뿐만 아니라 다른 파일에서 참조된 외부 레이블의 실제 주소도 포함됩니다.
4. 참조 수정 (Patch references)
	- 심볼 테이블과 재배치 정보를 사용하여, 링커는 각 오브젝트 파일의 코드와 데이터 내에서 **미해결된 참조(주소)** 를 찾습니다. 그리고 3단계에서 결정된 최종 주소를 사용하여 해당 참조를 수정합니다. 예를 들어:
		- 다른 프로시저를 호출하는 jal 명령어의 주소 필드는 호출될 프로시저의 최종 주소로 업데이트됩니다.
		- 전역 변수를 로드(lw)하거나 저장(sw)하는 명령어의 주소 필드(오프셋)는 해당 변수의 최종 메모리 위치(예: 전역 포인터 레지스터($gp) 기준 오프셋)로 업데이트됩니다.

이러한 과정을 통해 링커는 여러 오브젝트 파일의 코드와 데이터를 결합하고, 파일 간의 참조를 해결하여 완전한 실행 파일을 생성합니다. 생성된 실행 파일은 미해결 참조나 (일반적으로) 재배치 정보가 포함되지 않은 형태로 로더에 의해 메모리에 로드되어 실행 준비가 됩니다.
# 링커의 symbol resolution(해석)단계에서, 각 유형의 영역이 모두 결합되면 어떻게 모든 기계 명령어와 전역 변수의 런타임 메모리 주소를 결정할 수 있는가?
링커가 계획된 메모리 레이아웃에 따라 프로그램 전체에서 모든 레이블의 최종 절대 메모리 주소를 결정하기 때문입니다.
# 적절한 스레드 수를 판단하기 위한 테스트에서 어떤 요인들을 판단 기준으로 삼아야 하는가?


# Node.js는 싱글 스레드인데 어떻게 비동기 호출이 가능한가?
Node.js는 싱글 스레드(Event Loop)로 동작하지만, 실제로는 내부적으로 다음과 같은 구성요소들이 함께 작동합니다:
- Event Loop (메인 스레드)
- Worker Threads Pool (libuv 라이브러리)
- Thread Pool (백그라운드 작업용)
비동기 작업이 처리되는 과정:
```
파일 읽기 요청 → Event Loop가 요청 수신 
→ Worker Thread에 작업 위임 
→ Event Loop는 다른 작업 처리 
→ 파일 읽기 완료 시 Callback 실행
```
 - Event Loop가 Non-blocking I/O 작업들을 Worker Threads에 분배
 - CPU 집약적 작업은 Thread Pool을 활용
 - libuv 라이브러리가 운영체제 수준의 비동기 작업 처리 
# 182p
- handler함수를 코루틴에서 실행하면 handler안에 있는 블로킹 함수 호출시, 코루틴이 일시 중지되고, worker thread는 준비 상태인 다른 코루틴을 실행하기 위해 전환된다. 일시 중지되었던 코루틴에 할당된 사용자 서비스가 응답한 후 그 처리 결과를 반환하면 이 코루틴은 준비 상태가 되어 스케줄링 차례가 돌아오길 기다린다. 이 과정에서, handler함수를 호출한 스레드는 블로킹되지 않는다. 왜냐하면 코루틴으로 인해 cpu 제어권을 반환하기 때문이다. 코루틴으로 실행된 함수가 응답하면, 호출 스레드는 해당 스레드의 호출 진입점으로가서 다시 작업을 실행한다. -> 이해가 맞는지?
# 코루틴이 일시중지되어도 worker 스레드가 블로킹되지 않는 이유는?
이벤트 루프가 대기 중인 다른 코루틴을 worker 스레드에 할당하기 때문에 코루틴이 일시중지되어도 worker 스레드는 다른 작업을 처리할 수 있어 블로킹되지 않는다.
코루틴이 일시중지되더라도 비동기작업(I/O)을 이미 요청해 놓은 상태이기 때문에 비동기 작업은 코루틴이 일시중지되어도 중단되지 않는다. 애초에 이런 비동기 작업은 os나 스레드풀에서 실행되는 것이기 때문이다.
- 이런 비동기 작업의 완료 여부는 os가 이벤트 루프에 이벤트를 발생시켜서 알린다. 이벤트 루프는 개발자가 구현해야 한다.

### 188p
- 클로저는 코드와 데이터를 한데 묶어 변수로 사용하는 것이다.
- 클로저는 함수가 자신이 생성된 환경을 기억하는 것이다. 함수 반환여부와 관계없이, 내부 함수가 외부 함수의 변수를 참조(또는 캡처)하면 클로저다?


### 227p
- 함수의 매개변수, 지역변수가 레지스터 수보다 많으면 일부 매개변수가 스택 프레임에 저장된다. 이때 매개변수가 너무 많아 스택 프레임에 저장되지 못한다는 정보는 어떻게 아는 건지?
- 스택 영역의 증가와 감소는 구체적으로 어떻게 구현되는지?, 구현하는 책임은 누구에게 있는지?
### 239p
- 힙 영역에서 메모리 조각의 헤더 크기는 4byte인가?
- 힙 영역세어 메모리 조각의 헤더에는 어떤 정보가 들어가는가?
### 240p
- 사용되지 않는 메모리 조각에 발생하는 내부 단편화(fragmentation)가 무엇인가?
### 249p
- user mode 프로그램이 kenel mode 프로그램(운영체제)를 파괴하는 오류가 segmentation fault인가?
### 256p
- 운영체제는 어떻게 물리 메모리를 관리하는가?
### 264p
- 스레드 전용 저장소에 메모리 풀을 넣는 경우, 스레드A의 실행이 완료된 후에도 스레드B에서 해당 메모리를 계속 사용한다면 스레드B에서 스레드A의 메모리를 해제해야하는데, 이를 어떻게 해결하는가?
### 265p
- 매개변수를 이용해 함수 내에서 계산한 값이 할당된 변수도 지역변수라면, 이 변수를 반환하는 함수 호출이 끝났을때 해당 변수도 무효화되나?
> javascript는 원시타입(number, string, boolean 등)에 대해 값을 복사하여 전달하는 방식으로 동작한다. 그러므로 반환값은 함수 외부로 복사되어 전달되며, 외부 변수는 새로운 메모리 공간에 값을 할당한다.

```ts
const getSum = (a: number, b: number) => {
	const result = a + b; // result는 지역변수
	return result; // result 값이 복사되어 반환됨
}
const sum = getSum(1, 2); // sum은 3이라는 값을 받음
// 이 시점에서 getSum 함수의 result 변수는 이미 무효화됨
```

> java는 원시 타입(int, double, boolean 등)은 값을 복사하고, 객체 타입은 참조(reference)를 복사한다. 함수가 객체를 반환해도 해당 객체는 힙 메모리에 저장되있기 때문에 함수 호출이 끝나고  지역 변수가 무효화되어도 객체는 힙메모리에 존재하므로 함수 외부 변수에 할당할 수 있다.

```java
public class Example {
    public Person createPerson() {
        Person person = new Person("John"); // 힙 메모리에 객체 생성
        return person; // 객체의 참조를 반환
    }

    public static void main(String[] args) {
        Example ex = new Example();
        Person result = ex.createPerson(); // result는 여전히 유효한 Person 객체를 참조
        System.out.println(result.getName()); // 정상 작동
    }
}
```

### 288p
- 메모리 셀에 비트를 저장하려면 전원이 켜져있는 한, 계속해서 단자에 비트를 입력해야하는가?
### 296p
- 프로세스 대기열에는 항상 System Idle Process가 준비 완료 상태로 있기 때문에 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾을 수 있는 것인가?

### 306p
- 8이상의 숫자를 2진법과 2의 보수를 사용해서 어떻게 덧셈하는가?

### 320p
- 코어가 많을수록 코어 하나에 할당할 수 있는 스레드가 적어지니까 성능이 향상되는 것인가?

### 344p
- 스택 레지스터가 뭔지? 스택 포인터와 어떤 관련이 있는지?

### 345p
- 여러 프로그램들이 실행 중이면 PC 레지스터에는 어떻게 프로그램의 기계 명령어 주소가 저장되는지?

### 350p
- 프로그램이 실행되면 사용자 상태 스레드가 생성될때마다 자동으로 커널 상태 스택을 갖고 생성되는가?

### 351p
- 사용자 상태 스레드의 컨텍스트(실행 상황) 정보가 어떤 방법으로 커널 상태 스택에 저장되는가?

### 352p
- 동시에 여러 작업을 해야할때, CPU는 어떻게 사용자 상태와 커널 상태를 동시에 수행할 수 있는가?
- 상태(mode)는 코어에 적용되는 건가?

### 357p
- 스레드가 전환될때 스레드의 상황정보를 저장하고 복원하는 주체는 커널 상태에서 커널 안의 타이머 인터럽트 처리 프로그램인가?
- 타이머 인터럽트 처리 프로그램은 스레드가 생성될때 내장되는 건가?

### 358p
- CPU 시간 조각이 모두 사용됐는데 어떻게 스레드가 사용자 상태로 돌아가서 실행될 수 있는가?

### 366p
- CPU 코어는 캐시(L1, L2, L3)에 어떻게 접근하는가?
- 운영체제가 캐시에 접근하는 기계 명령어를 제공해주는 건가?

### 387p
- 언어 별로 배열을 저장할때 행 우선 방식인지, 열 우선 방식인지 알아두기
- 언어 설정에서 배열 저장 방식을 바꿀 수 있는지 알아두기

### 408 - 412p
- 메모리 장벽 이해 안됌

### 426p
- CPU는 메모리 주소 공간만 가지고 메모리에서 데이터를 읽어오는가?
- 장치 레지스터는 얼마나 많은 데이터를 저장할 수 있는가?

### 427p
- 장치 레지스터에 할당된 주소 공간의 특정 주소에 담긴 데이터가 장치 레지스터에 적재되는 것인지, 단순히 매핑되는 건지?
	- 장치 레지스터는 장치의 데이터를 저장하고, 메모리의 주소공간의 특정 주소가 장치 레지스터에 매핑된다.

### 433p
- 장치는 어떻게 CPU에게 인터럽트 신호를 보내는가?

### 442P
- 장치 버퍼는 무엇인가? 메모리에도 버퍼가 있나?

### 445p
-  DMA(direct memory access)는 어떻게 장치 입출력을 처리하는 별도의 스레드를 만드는가?
- 디스크 스레드는 CPU 스레드에 자신의 작업이 끝났다는 것을 어떻게 알리는가?

### 451p
- 운영체제는 어떻게 준비 완료 대기열에 프로세스를 넣는가?
- 운영체제는 준비 완료 대기열에서 프로세스를 어떻게 꺼내어 CPU에 할당하는가?
