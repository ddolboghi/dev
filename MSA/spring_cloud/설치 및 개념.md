- reactive-gateway는 springboot  <= 3.1에서만 호환
- gateway는 springboot >= 3.2 부터 호환
- gateway에 보안 장치 걸어둘 수 있음(토큰 유효성 검사)

# MSA 사용하는 이유
- 사용자에게 서비스의 중단 없이 제공
- 기능별 서비스를 사용자에게 통일성있게 제공
- 트래픽을 분산 처리하기 위해 사용
# MSA 구조
![[msa_structure.png]]
- gateway: 사용자가 어떤 서비스로 가야하는지 분기 처리
- 로드밸런싱
	- 애플리케이션을 지원하는 리소스 풀 전체에 네트워크 트래픽을 균등하게 배포
	- 사용자와 서버 그룹 사이에 위치
- 오토 스케일링
	- 같은 기능을하는 서버 수를 늘리거나 줄여 컴퓨팅 리소스 측면에서 시스템이 자동으로 규모를 조절(scale)하는 기능
	- 서버들의 묶음 단위인 오토스케일링 그룹(Auto-Scaling Group)에 연결하여 서비스가 유휴 상태일 때는 서버의 개수를 최소로 유지하고 부하가 발생하면 최대로 늘려 안정적이고 유연한 서비스를 구현
- 각각의 서버 인스턴스가 서로다른 DB를 보고있어야함 -> 데이터 분산 처리 -> DB들을 동기화하기 위해 DB 로드밸런싱해야함 -> EDA 활용(kafka 등)
# spring cloud 세팅 및 도커 실행
[참고](https://wrtn.ai/chat/u/65d591e80c06023ae70af73a/c/6634cc01d6b92cf36737f8d1?type=u)
## 서비스 디스커버리
- 서비스 디스커버리로 eureka를 사용한다.
### 설정
build.gradle
```gradle
plugins {  
    id 'java'  
    id 'org.springframework.boot' version '3.1.11'  
    id 'io.spring.dependency-management' version '1.1.4'  
}  
  
group = 'com.cheonma'  
version = '0.0.1-SNAPSHOT'  
  
java {  
    sourceCompatibility = '17'  
}  
  
repositories {  
    mavenCentral()  
}  
  
ext {  
    set('springCloudVersion', "2022.0.5")  
}  
  
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-actuator'  
    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server'  
    implementation 'org.springframework.cloud:spring-cloud-starter-loadbalancer'  
    testImplementation 'org.springframework.boot:spring-boot-starter-test'  
}  
  
dependencyManagement {  
    imports {  
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}"  
    }  
}  
  
tasks.named('bootBuildImage') {  
    builder = 'paketobuildpacks/builder-jammy-base:latest'  
}  
  
tasks.named('test') {  
    useJUnitPlatform()  
}
```

application.yml
```yml
spring:  
  application:  
    name: eureka
```
### Dockerfile 작성하기
Dockerfile
```Dockerfile
FROM openjdk:17-slim  
CMD ["./gradlew", "clean", "build"]  
VOLUME /tmp  
ARG JAR_FILE=build/libs/*.jar  
COPY ${JAR_FILE} app.jar  
EXPOSE 8080  
ENTRYPOINT ["java","-jar","/app.jar"]
```
- Dockerfile은 프로젝트 루트에 위치(build.gradle과 같은 위치)
### 도커 컨테이너 이미지 생성하기
```bash
docker bulid -t [컨테이너 이미지 이름] .
```
- 마지막에 반드시 한 칸 띄우고  `.`을 붙여야한다.
### 도커 컨테이너 실행하기
```bash
docker run -d --name [컨테이너 이름] -p [호스트의 포트]:[컨테이너의 포트] [실행할 이미지 이름]
```
- 백그라운드로 컨테이너를 실행한다.
- 명령어 실행시 오류가 