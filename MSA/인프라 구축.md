- 쿠버네티스는 개념 이해 필요
- 설정 화면 캡처해놓기
- ec2 docker로 실행하기
- kafka
- 컨테이너 많음
- ec2 설정
	- t3 large
	- 우분투
	- 메모리: 32gb (스토리지 구성에서 설정), swap 메모리 설정하기
	- cpu: gp2
- 요금 청구: aws 청구서, 주민등록등본(뒷자리 가리기), 통장사본, 상한선 30
- 인수인계서 만들어 놓기
---
#  MSA 사용하는 이유
> [!tip] MSA로 해결하려는 목표는 기술적인 것이 아니다.
- 거대한 조직의 개발 생산성을 유지하거나 작은 조직들이 독립적이고 빠르게 나아가 하기 위해
# MSA 조건
> [!tip] 아키텍처 스타일은 시스템의 상황과 목표에 맞게 최적화되어야 하는 것이지 아키텍처 스타일을 그대로 반영하는 것이 아니다. 결국 중요한 것은 시스템의 목표를 어떻게 달성하는가이다.
- 각 서비스는 비즈니스 기능단위로 나누어야함
- 각 서비스 간에 임의적인 접근이 불가능하도록 격리해야함
- 데이터베이스를 분리하여 서로 조인하지 못하게 차단해야함
- 외부에 영향을 주는 서비스에서 변경이 있을때, 기존 API가 하위 호환성을 가질 수 있도록 해야하며 더 신중하고 점진적인 배포 방식 고려
- CD(continuous delivery) 같은 최신 소프트웨어 배포 방식을 이해해야함
# MSA와 직접적인 관련이 없는 것들
- REST API  -> API는 MSA를 차별화하는 특징이 아님
- 재사용 관점에서 MSA를 바라보는 것 -> 재사용만을 위해서 시스템을 서비스로 분리할 필요 없음
- 클라우드 네이티브 애플리케이션 -> 작은 모놀리식 시스템도 클라우드 인프라를 사용한다면 이를 잘 활용할 수 있는 구조를 갖춰야 함
# MSA에 대한 사실과 오해
## 서비스 간 통신이 많으면 속도가 느리다.
- 클라이언트에서 여러 서비스의 데이터가 필요할때 병렬로 REST API를 호출하면 느리지 않음
- 서비스간 통신에서 N+1 문제를 방지하려면 일괄 API 요청
```java
//[GET] /api/v1/users/101,102,103,...,120

@GetMapping("/{usersIds}")
public ResponseEntity<?> getUsers(@Param("usersIds") List<Ling> ids) {
	....
}
```
- 스프링 controller에서 URI에 콤마로 구분하여 값을 전달하면 이 값들을 리스트나 배열에 담을 수 있음
- 잘 변하지 않는 공통 데이터는 로컬 캐시를 활용해 조회 속도 개선하기
- 로컬 캐시는 요청이 급격히 몰리는 경우에 서비스 부하를 낮추기 위함임
## 자동으로 롤백되지 않는다.
- 여러 서비스에 걸친 트랜잭션이 중간에 실패하면 다른 서비스에서 발생한 트랜잭션을 취소하는 보상 트랜잭션을 실행해야함
	- 보상 트랜잭션이 불가능한 경우에는 보상 트랜잭션이 발생하지 않도록 순서를 변경 또는 실패 이후 재시도할 수 있도록 처리해야 함
- 사실 모놀리식 시스템이 네트워크로 통신할 때도 항상 해오던 일임
- 실제로 보상 트랜잭션이 필요한 경우는 생각보다 적음
	- 각 서비스는 응집도를 높게 구성하기 때문에 서비스 간 참조가 많지 않음
	- 트랜잭션의 중요도가 높은 경우 해당 트랜잭션이 발생하는 업무를 하나의 서비스에 배치기
## 동시성 이슈

