---
sticker: emoji//1f4a1
Created: 2023-10-05
---
#### 여러 개의 개념을 한번에 묶지 말고 개념을 쪼개서 하나씩 나눠서 이해하자

[GitHub에서 PR로 코드리뷰 하는 법](https://joyful-development.tistory.com/m/14)
# 클래스 내부 선언 순서 컨벤션
1. Static Variable : `public -> protected -> private`
2. Member Variable : `public -> protected -> private`
3. Constructor
4. Static Method
5. Other Method : 기능 및 역할별로 분류하여 기능을 구현하는 그룹별로 작성
6. Standard Method : toString, equals, hashcode 와 같은 메소드
7. Getter / Setter : 클래스의 가장 하단 부분에 위치

# intellij 단축키
| 기능                        | 단축키                                       |
| :------------------------ | :---------------------------------------- |
| 줄 복사                      | ctrl + D                                  |
| 전체 파일에서 찾기                | ctrl + shift + F                          |
| 현재 파일에서 바꾸기               | ctrl + R                                  |
| 전체 파일에서 바꾸기               | ctrl + shift + R                          |
| 빌드 도구(maven, gradle) 새로고침 | ctrl + shift + o                          |
| 자동으로 테스트 클래스 생성           | 클래스 이름에 커서 위치 > alt + Enter > Create Test |
| `System.out.println();`   | `sout` + ctrl + space                     |
| `System.out.printf();`    | `so` + ctrl + space                       |
| 안쓰는 `import` 정리           | ctrl + alt + o                            |

# QA(quality assurance)란?
= 품질 보증
품질을 보증하기 위해 수행하는 여러 테스트, 성능 진단, 검증 등의 프로세스
[참고](https://support.kmong.com/hc/ko/articles/14656446751129-QA%EC%9D%98-%EB%AA%A8%EB%93%A0-%EA%B2%83-%EC%9C%A0%ED%98%95-%ED%8A%B9%EC%A7%95-%EC%97%AD%ED%95%A0-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)

# CI/CD
## Continuous Integration(지속적인 통합)
* 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트되어 저장소에 통합
## Continuous Delivery(지속적인 배포)
* 변경된 코드가 **실제 프로덕션 환경에 반영**되는 것
# 디렉터리 계층도 얻는 법
1. CMD창을 연다
2. 파일 트리를 만들 위치로 이동한다. (예: C:\repository\TEST_PROJECT\src\views)
3. `tree /F | clip` 명령어를 입력한다.
4. 필요한 곳에 붙여넣기

# 인증(authentication)과 인가(authorization)
authentication: 사용자가 사이트에 로그인할때 누구인지 확인하는 과정
authorization: 사이트의 특정 부분에 접근할 수 있는지에 권한을 확인하는 과정

# URI vs URL
![[Pasted image 20240124003719.png]]
- URI = 식별자 (e.g. naver.com)
- URL = 식별자 + 위치 (e.g. https://www.naver.com)
- URL은 프로토콜과 결합한 형태
- URI는 그 자체로 이름이 될 수 있음

![[Pasted image 20240124004204.png]]
- Scheme: 리소스에 접근하는데 사용할 프로토콜
- Host: 접근할 서버의 호스트 명
- Path: 접근할 서버의 경로에 대한 상세 정보
- URL은 특정 서버에 있는 웹문서를 가리킴
- URN은 웹 문서의 물리적인 위치와 상관없이 웹 문서 자체를 나타냄
- 개별 자원에 식별자를 부여하면 해당 정보에 대한 URN은 일정하게 유지되며 리소스 위치, 프로토콜, 호스트와 관계없이 위치 파악 가능

# 성장하는 조직의 기술 부채는 언제 갚을까?

빠르게 성장하는 작은 회사에서 속도에 초점을 맞추고 주니어 중심으로 개발을 하면 당연히 기술 부채가 쌓인다. 워낙 숨 가쁜 일정으로 돌아가다 보니 유닛 테스트를 만드는 건 꿈도 꿀 수 없고 최종 QA(Quality Assurance)도 대충 하고 프로덕션에서 실제 고객들이 테스트 아닌 테스트를 하는 일도 다반사다. 자잘한 버그가 자주 보고되는 것은 물론 가끔 사고도 터지며, 이런 기술 부채로 인해 생긴 누더기 같은 코드로 인해 새로운 기능 개발도 지연되기 시작한다.

그렇다고 내일도 살아있을지 아무도 모르는 작은 회사에서 항상 깔끔하고 완벽하게 테스트된 코드만 지향하거나 무모하게 새로운 프레임워크를 사용해 볼 수도 없는 노릇이다. 시작하는 단계의 스타트업이 빠른 속도와 무결점 중 꼭 하나만 선택해야 한다면 속도를 선택하는 편이 유리하다는 게 내 생각이다. 그 대신 아래의 내용을 참고하면 돈이 더 생기고 더 경험 있는 사람을 뽑기 전까지 리스크를 최소화할 수 있을 것이다. 어느 시점부터는 슬슬 사고의 빈도가 늘며 정도도 심해지기 시작할 때 그 때부터는 아래를 고민해보는 것이 좋은 듯 하다.

1. 서비스 모니터링 프로세스를 만든다. **서비스에 문제가 생기면 빨리 인지하고 해결하는데 초점**을 맞추는 것이다. 이 것도 상당한 노력과 시간을 필요로 할 수 있는데 기술 부채를 많이 안고 가는 상황에서 모니터링에 대한 노력을 먼저 기울이는 것이 맞다고 본다. 어떤 지표를 바탕으로 서비스의 안정성을 측정할 것인지 그리고 서비스에 문제가 생겼을 경우 어떻게 escalate하고 문제해결을 할지 점진적으로 개선해가며 프로세스를 만드는 것이다. 또한 사고의 심각성에 따라 재발을 막을 방법을 찾아봐야 하는데 이건 뒤 문단에서 이어서 더 이야기해보겠다.
    
2. 매주 엔지니어링 미팅 등에서 지난 한 주간의 **버그와 사고를 리뷰하고 이유를 파악**한다. 유닛 테스트 코드를 붙이지는 못하고 QA를 충분히 하지 못하더라도, 이미 발견된 버그와 사고가 재발하는 것을 방지하기 위한 테스트는 붙이는 것이 필요하다고 본다. 서비스 모니터링 프로세스가 어느 정도 자리잡혀있다면 사고 리뷰는 상대적으로는 쉬워진다. 만일 버그와 사고의 빈도가 점점 높아진다면 새로운 기능 개발뿐 아니라 기존 코드의 리팩토링에도 시간을 써야 한다. 유데미 시절 데이터 엔지니어링 팀은 이슈가 늘어나면서 그러다가 대형 사고를 한번 겪고 난 뒤 최대 40%의 시간을 리팩토링에 할애했다.  
    
3. 훌륭한 개발자는 자신이 만든 결과물이 실제 **사용자들에 의해 어떻게 사용되는지 관심이 많고 실제 사용자의 피드백에 귀를 기울이는 사람**이다**.** ‘개발 다 했으니 내 업무는 끝!’이 아니라 어떻게 쓰이는지 보고 개선하려는 의지가 있다는 말이다. 인정받는 개발자 혹은 좋은 개발 팀의 매니저가 되고 싶다면, CS/CX 팀과의 협업 채널을 만들고 주기적인 미팅을 통해 고객의 소리를 들어보고 사람이 되자. SDD(Support Driven Development)라는 말을 들어봤는가? Y Combinator 스타트업 스쿨에서 강조하는 원칙 중의 하나이다.   
    
4. 몇 가지 상대적으로 쉽게 붙여볼 수 있는 중요한 성능 모니터링이 있는데 첫 번째는 백엔드 데이터베이스의 **오래 걸리는 쿼리를 모니터링하고 문제 되는 부분을 찾아 미리 최적화**하는 것이고 두 번째는 **서비스 홈페이지나 중요 API의 실행시간 (latency) 모니터링을 해보는 것**이다. 이를 기술 부채를 해결하기 위해 단기적 관점에서 해볼 수 있는 일이다. 

물론 위와 같은 방법을 동원해도 사고는 터진다. 그중 몇 건은 대형 사고일지도 모른다. 그럴 때 중요한 것은 사고를 바라보는 경영진의 관점인데, 특정인이나 팀을 향해 손가락질하기보다는 사고 경위서를 작성해서 사고의 원인을 이해하고 재발 방지 대책을 세운 뒤 사내에 공유하는 과정에 집중해야 한다. 여기서 포인트는 경위서 작성 자체가 아니라, 밝혀진 문제의 재발을 막기 위한 조치들이 경위서의 내용에 포함되고 이런 조치들이 실제로 구현되어야 한다는 점이다. 

온라인 서비스에서 사고는 언제 일어나느냐의 문제지 피해갈 수는 없다. 회사가 망할 정도의 사고만 아니라면 조직 구성원 모두가 기술 부채 등의 다양한 이슈를 체감하고 이를 줄이기 위해 노력할 수 있는 기회가 된다는 사실을 잊지 말자. 모든 위기는 기회가 될 수 있다.

# 2024년 자바 개발자 면접 가이드

**Topic 1: 프로젝트 플로우와 아키텍처**
프로젝트의 기능, 흐름 및 아키텍처에 대해 문의합니다. 또한 기술 스택과 운영 환경에 어떻게 배포되는지, 지원자가 기여한 부분에 대해서도 질문합니다.

**[질문]**
- 진행한 프로젝트와 아키텍처에 대해서 알려주세요.
- 그림으로 아키텍처, 프레임워크, 사용한 기술에 대해 설명해주세요.

프로젝트에 대해 아는 모든 것을 어딘가에 적어두세요. 당신만이 프로젝트에 대해 모든 것을 알고 있다는 것을 기억하고, 자신감을 가지세요.

**Topic 2: 코어 자바**
코어 자바는 방대한 주제이며 면접관은 이러한 주제를 반드시 물어봅니다.

코어 자바는 자바 개발자에게 기본적인 것으로 여겨지므로 이 부분에 대해 철저한 답을 공부하세요. 특정한 프레임워크를 모르는 것이 문제가 되지는 않지만, 코어 자바에 대한 지식이 부족하면 문제가 될 수 있습니다.

**[토픽]**
- String/Hashcode-Equal 메소드
- Immutability
- OOPS 개념
- Serialization
- Collection Framework/concurrent collection
- 예외 처리
- 멀티스레드/스레드풀
- 자바 메모리(메모리 각 영역에 객체, 메소드 및 변수를 저장하는 법)
- 가비지 컬렉션(가비지가 객체를 수집하는 방법, 사용하는 알고리즘)
    
**[질문]**
- ThreadPoolExecutor는 어떻게 동작하나요?
- 커스텀 불변 클래스를 어떻게 만드나요? 자바에서 불변 클래스의 예는 무엇인가요?
- hasCode()와 equals()가 무엇인가요? map에서 객체를 키로 사용하면 어떻게 되나요? 올바르게 사용하는 방법은 무엇인가요?
- 깊은 복사와 얕은 복사가 무엇인가요?
- CompletableFuture가 무엇인가요?
- 최신 자바 메모리 모델이 무엇인가요?
- concurrent collection이 무엇인가요?
- HashMap, ArrayList 및 LinkedList의 시간/공간 복잡도를 말해주세요
- Arrays.sort()와 Collections.sort()에서 사용되는 알고리즘은 무엇인가요?
- 자바에서 커스텀 어노테이션을 어떻게 만드나요?
- HashMap과 HashSet은 내부적으로 어떻게 작동되나요?
- String의 join() 메소드의 용도는 무엇인가요?

**Topic 3: 자바 8/자바 11/자바 17**

새로 추가된 자바 API와 관련된 기능들을 알아야 합니다.

**[토픽]**
- 자바8 기능
- default/static 메소드
- 람다 표현식
- functional interface 
- optional API
- stream API
- 패턴 매칭
- text block
- 모듈

**[질문]**
- 자바 8/자바11/자바17의 새로운 기능은 무엇인가요?
- 자바에서 병렬 스트림이란 무엇이며 어떻게 작동하나요?
- 자바 메모리 모델의 새로운 개선점이 무엇인가요? 자바8 hashmap의 개선점은 무엇인가요?

**Topic 4: 스프링 프레임워크, 스프링 부트, 마이크로서비스, REST API**
기본적인 반복 질문을 공부해야 합니다.
이 주제에 대해 면접관을 만족시키지 못하면 탈락할 수 있습니다.

**[토픽]**
- 의존성 주입/IOC, 스프링 MVC
- configuration, 어노테이션, CRUD 
- Bean, Scope, Profiles, Bean 라이프사이클
- App context/Bean context
- AOP, Exception Handler, Control Advice
- Security(JWT, Oauth)
- Actuators
- 웹플럭스와 Mono Framework
- HTTP method
- Microservice 개념
- Spring Cloud
- JPA

**[질문]**
- 이 어노테이션의 용도는 무엇인가요? - @RequestMapping @RestController @Service @Repository @Entity
- Actuator가 무엇이고 어디에 쓰이나요?
- 애플리케이션의 복원력을 높이는 방법은 무엇인가요?
- distributed tracing이 무엇인가요? traceId와 spanId는 무엇인가요?
- 스프링 부트에서 WebFlux 및 Mono Framework란 무엇인가요?
- 스프링이 주기적으로 의존하는 것은 무엇이며, 어떻게 예방하나요?
- REST API를 보호하는 방법은?
- 스프링 부트에서 auto-configuration을 비활성화하는 방법은 무엇인가요?
# 함수명 작성 팁
- 함수 내부 로직을 의미하는 함수명은 재사용성과 확장성이 낮고, 어떻게 사용하는 건지 알기 어려움
- **함수가 어떻게 사용되는지에 초점을 맞춰서 이름 지을 것**

# Edge 런타임이란?
[공식 문서](https://edge-runtime.vercel.app/)
- vercel에서 제공하는 자바스크립트 런타임
- 엣지 런타임은 프레임워크 작성자가 엣지 컴퓨팅을 채택하고 웹 표준에 기반한 오픈 소스 툴을 제공할 수 있도록 설계되었습니다. 
- 애플리케이션 코드에 사용하기 위한 것이 아니라 프레임워크(예: Next.js)에 통합되도록 설계되었습니다. 
- 보안과 속도를 위해 의도적으로 최소한으로 설계되었습니다.
- 프레임워크가 엣지 런타임에 빌드되면 Node.js가 실행되는 모든 곳에서 실행됩니다. 
- Vercel과 같은 인프라에 배포하면 Next.js와 같은 프레임워크가 자동으로 최적의 인프라를 프로비저닝할 수 있습니다.
- 엣지 런타임은 표준 웹 API의 하위 집합으로, 가장 많은 환경과의 호환성 및 상호 운용성을 제공합니다. 
- Vercel, Cloudflare, Deno, Shopify 등의 커뮤니티 그룹인 WinterCG에서 개발한 표준을 준수하도록 설계되었습니다. 
- 'Edge'라는 용어는 특정 위치가 아닌 인스턴트 서버리스 컴퓨팅 환경을 지향하는 것을 의미합니다.
# C10K 문제
- 동시에 클라이언트 연결 **1만개**를 처리하는 네트워크 소켓 최적화 문제