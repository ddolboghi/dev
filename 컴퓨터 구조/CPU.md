> [!info] CPU가 메모리에 접근하는 것보다 레지스터에 접근하는게 훨씬 빠름

[ALU](#ALU)
[제어장치](#제어장치)
[레지스터](#레지스터)
# ALU
![ALU 구조](./ALU-structure.png)
- CPU에서 계산 담당
- ALU 내부에는 여러 계산을 위한 회로들이 있음(가산기, 보수기, 시프터, 오버플로우 검출기 등)
- 레지스터를 통해 피연산자(operand)를 받아들이고 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들임
- 연산의 결과값을 레지스터에 보냄
- flag를 플래그 레지스터에 보냄
- flag: 연산 결과에 대한 추가적인 상태 정보
- overflow: 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

|  |  |
| ---- | ---- |
| 부호 플래그 | 부호 플래그가 1이면 연산 결과는 음수, 0이면 양수 |
| 제로 플래그 | 제로 플래그가 1이면 연산 결과는 0, 0이면 0이 아님 |
| 캐리 플래그 | 캐리 플래그가 1이면 올림수나 빌림수가 발생했음을 의미, 0이면 발생하지 않음 |
| 오버플로우 플래그 | 오버플로우 플래그가 1이면 오버플로우 발생, 0이면 아님 |
| 인터럽트 플래그 | 인터럽트 플래그가 1이면 인터럽드가 가능함을 의미, 0이면 불가능 |
| 슈퍼바이저 플래그 | 슈퍼바이저 플래그가 1이면 커널 모드로 실행중임을 의미, 0이면 사용자 모드로 실행 중임을 의미 |
# 제어장치
- CPU 제조사마다 제어장치의 구현 방식이나 명령어 해석 방식, 받고 내보내는 정보가 다름
## 제어장치가 받아들이는 정보
- **클럭 신호**: 컴퓨터의 모든 부품은 클럭 신호에 맞춰 동작함
- **해석해야할 명령어**: 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줌
- **플래그 값**: 플래그 레지스터에 저장된 플래그 값을 받아들임
- **제어 버스로 전달된 제어 신호**: CPU가 아닌 외부로부터 발생된 제어 신호를 받아들임
## 제어장치가 내보내는 정보
- CPU 외부에 전달하는 제어 신호: 제어버스로 제어 신호를 내보냄(to 메모리, 입출력 장치)
- CPU 내부에 전달하는 제어 신호(to 레지스터, ALU)
# 레지스터
- 레지스터는 CPU 내부에 위치함
- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됨
- 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름 파악 가능
## 대부분의 CPU가 공통으로 가진 레지스터
- **프로그램 카운터(명령어 포인터)**: 메모리에서 읽을 명령어의 주소 저장, 저장된 주소 값이 지속적으로 증가하기 때문에 CPU가 메모리에 저장된 프로그램을 순차적으로 읽고 실행할 수 있음
	- 순차적인 실행 흐름이 끊기는 경우: 특정 메모리 주소로 이동하는 명령어가 실행되거나 인터럽트가 발생했을때
- **명령어 레지스터**: 명령어 저장
- **메모리 주소 레지스터**: 메모리 주소 저장, CPU가 읽을 주소 값을 주소 버스로 보낼때 거치는 곳
- **메모리 버퍼 레지스터(메모리 데이터 레지스터)**: 메모리와 주고받을 값 저장, 데이터 버스로 주고받을 값이 거치는 곳
- **범용 레지스터**: 자유롭게 사용할 수 있는 레지스터, 데이터와 주소 모두 저장 가능
- **플래그 레지스터**: ALU 연산 결과나 CPU 상태에 따른 플래그 저장
- **스택 포인터**: 메모리 내부 스택 영역의 peek를 가리키는 레지스터, 스택 주소 지정 방식에 사용됨
- **베이스 레지스터**: 변위 주소 지정 방식에 사용됨
## ARM 레지스터
- 13개의 범용 레지스터: R0 ~ R12
- 스택 포인터: SP (R13), ARM 상태에서 범용 레지스터로 사용될 수 있음
- 링크 레지스터: LR (R14) 함수 호출 등의 서브루틴에서 되돌아갈 주소 저장, 범용 레지스터로서 사용될 수도 있음
- 프로그램 카운터: PC (R15)
- 프로그램 상태 레지스터(≈플래그 레지스터): CPSR 
- ARM 상태(ARM state): ARM에서는 명령어를 실행할 때 ARM 상태로 실행할 수 있고, Thumb 상태로 실행할 수 있는데, 전자는 32비트 명령어를 실행하는 모드이고 후자는 16비트 명령어를 실행하는 모드다. 그렇기에 Thumb 상태에서는 ARM 상태로 명령어를 실행할 때에 비해 적은 명령어를 사용한다. 
	- Thumb 모드에서는 R0~R7(범용 레지스터 8개), R13(SP), R14(LR), R15(PC) 레지스터를 사용한다.
	- ARM mode는 이보다 많은 R0~R12까지 모두 사용할 수 있다.
- ARM은 실행 모드에 따라 사용되는 레지스터 종류가 달라짐
	- User mode: 사용자 모드로 실행할때의 동작 모드
	- FIQ(Fast Interrupt Request) mode: 빠르게 처리해야하는 인터럽트를 처리하기 위한 동작 모드
	- IRQ(Interrupt Request) mode: 일반적인 인터럽트를 처리하기 위한 동작 모드
	- SVC(Supervisor) mode: 자원에 접근할 수 있는 동작 모드
	- Abort mode: 예기치 못한 오류가 발생했을때 동작 모드
	- Undefined: 정의되지 않은 명령어를 수행하려 할때 동작 모드
	- System mode: 사용자 모드에서 추가적인 권한을 더 부여한 실행 모드
## x86(x86-64) 레지스터
16비트로 사용될때
- AX(Accumulator register): 산술 연산에 사용
- CX (Counter register): 시프트/회전 연산과 루프에서 사용
- DX (Data register): 산술 연산과 I/O 명령에서 사용
- BX (Base register): 데이터의 주소를 가리키는 포인터로 사용
- SP (Stack Pointer register): 스택의 최상단을 가리키는 포인터로 사용
- BP (Stack Base Pointer register): 스택의 베이스(최하단)를 가리키는 포인터로 사용
- SI (Source Index register): 스트림 명령에서 소스를 가리키는 포인터로 사용
- DI (Destination Index register): 스트림 명령에서 도착점을 가리키는 포인터로 사용
- IP (Instruction Pointer): 명령어 포인터
- EFLAGS: 플래그 레지스터
32비트로 사용될때는 레지스터 이름 앞에 'E' 붙임
64비트로 사용될때는 'R' 붙임
- 세그먼트 레지스터: 주소 지정에서 사용되는 레지스터
	- Stack Segment (SS): 스택을 가리킴
	- Code Segment (CS): 코드를 가리킴
	- Data Segment (DS): 데이터를 가리킴
	- Extra Segment (ES): 추가적인 데이터를 가리킴
	- F Segment (FS): 많은 추가적인 데이터를 가리킴
	- G Segment (GS): 더 많은 추가적인 데이터를 가리킴

# 명령어 사이클
- CPU가 하나의 명령어를 처리할때 명령어가 일정한 **주기**를 반복하며 실행됨
- 하나의 명령어가 처리되는 **주기**를 명령어 사이클이라고 함
1. 인출 사이클(fetch cycle): 메모리에 있는 명령어를 CPU로 가져옴
2. 실행 사이클(execution cycle): CPU로 가져온 명령어 실행
3. 간접 사이클(indirect cycle): 메모리 접근이 더 필요한 경우(e.g. 간접 주소 지정 방식)
- CPU는 명령어를 가져오고 실행하고를 반복함(1, 2를 반복하거나 1,3,2를 반복함)
![명령어 사이클](instruction-cycle)
# 인터럽트(interrupt)
- CPU의 정상적인 작업을 방해하는 신호
- 인터럽트의 종류를 구분하는 통일된 기준 없음(아래는 인텔 공식 문서 참조한 기준임)
## 동기 인터럽트(== exception)
- CPU에 의해 발생하는 인터럽트로, 명령어들을 수행하다가 예외적인 상황에 마주 쳤을때 발생
- **fault**: 예외 처리 직후 예외가 발생한 명령어부터 실행하는 예외
- **trap**: 예외 처리 직후 예외가 발생한 명령어의 다음 명령어부터 실행하는 예외(e.g. 디버깅)
- **abort(중단)**: CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을때 발생하는 예외
- **소프트웨어 인터럽트**: 시스템 호출이 발생했을때 나타나는 예외
## 비동기 인터럽트
- 주로 입출력장치에 의해 발생하는 인터럽트
- 일반적으로 인터럽트라고 부름
- 입출력장치에 의한 비동기 인터럽트는 '알림' 역할을 함
- CPU는 효율적인 작업을 위해 비동기 인터럽트를 사용함
	- e.g. 프린터 출력 명령 후 프린트가 끝날때까지 주기적으로 완료 여부를 확인하는 대신, 프린트로부터 완료 인터럽트를 받아 효율적인 작업 가능
- **인터럽트 플래그**: 플래그 레지스터에 있는 인터럽트 비트, 활성화(가능)되있어야 인터럽트 요청 신호를 받아들임. 비활성화되있으면 인터럽트 요청 신호 무시
- 막을 수 없는 인터럽트(Maskable Interrupt): 우선순위가 가장 높은, 무시할 수 없는 인터럽트
- 막을 수 있는 인터럽트(Non Maskable Interrupt)
- **인터럽트 서비스 루틴**(인터럽트 핸들러): 인터럽트를 처리하기 위한 **프로그램**
- **인터럽트 벡터**: 인터럽트 서비스 루틴의 시작 주소를 알려줌
	- CPU는 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받음
- CPU는 인터럽트 서비스 루틴을 실행하기 전에 지금까지의 작업 내역들을 메모리의 스택 영역에 백업함
### CPU의 비동기 인터럽트 처리 순서
1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 인터럽트 벡터를 참조해 인터럽트 서비스 루틴 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해둔 작업을 복구해 실행 재개
# CPU 성능 향상 기법