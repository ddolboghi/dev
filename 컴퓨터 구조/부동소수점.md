# 부동소수점이란?
부동(浮動)이란 뜰 부(浮)에 움직일 동(動)을 써서 '떠서 움직인다'는 뜻이다. 즉, 소수점이 떠 다닌다는 의미다. floating point와 같은 의미다.
# 부동소수점의 10진수 표현
123.75라는 실수를 고정 소수점으로 표현하면 123은 정수부고, 45는 소수부다.

부동소수점은 유효숫자를 사용한 곱셈 형태로 표현한다.
$\pm (가수) \times (밑수)^{(지수)}$

$12.375 \times 10^{1}$
밑수와 지수를 표현하기 위해 소수점 한 칸을 앞으로 올린다. 지수 값을 변경하면 소수점이 이동한다.
# 정규화
부동소수점의 정규화란, 가수부의 첫번째 자리수를 밑수보다 작은 수로 바꾸는 것이다. 다음은 위 부동소수점 표현을 정규화한 것이다.
$1.2375 \times 10^{2}$
가수는 1.2375로 밑수 10보다 작아지고, 지수는 2로 증가했다.
정규화는 주로 최적화를 위해 사용한다. 10진수의 정규화로는 알기 어려웠던 부분이 2진수에서 정규화했을 때 더 잘 드러난다.
## 부동소수점의 2진수 표현
12.375를 2진수로 표현하려면, 정수부와 소수부를 따로 변환해야 한다.
- 정수부는 더이상 나누어지지 않을 때까지 2로 나눈 뒤 나머지 값을 역순으로 읽으면 된다.
- 실수부는 2를 곱한뒤, 정수부를 읽고 남은 소수부만 다시 2를 곱하여 0이 될때까지 반복하면 된다.
	![[소수부_이진수_변환.png | 400]]
따라서 12.375를 이진수로 변환하면, $1100.011_{(2)}$이다.
이를 부동소수점으로 변환하여 정규화하려면 $1.xyz... \times 2^{n}$의 형태로 만들어야 한다.

1. 2진수에서 소수점을 맨 앞의 1 바로 뒤로 이동시킨다. 만약 2진수가 0으로 시작한다면, 소수점의 오른쪽에서 가장 가까운 1 바로 뒤로 이동시킨다.
2. 소수점이 왼쪽으로 이동한 칸 수만큼이 지수가 된다.

따라서 $1.100011_{(2)} \times 2^{3}$이다.

가수부가 언제나 1로 시작하기 때문에 가수부의 첫 번째 자리는 생략 가능하다. 또한 가수부와 지수부로 표현하기 때문에 더 많은 수를 표현할 수 있다.
# IEEE 754
IEEE에서 컴퓨터에서 부동소수점을 표현하는 법에 대한 표준은 다음과 같다.

| 타입                     | 부호  | 지수부 | 가수부 | 총 비트수 |
| ---------------------- | --- | --- | --- | ----- |
| half precision         | 1   | 5   | 10  | 16    |
| single precision       | 1   | 8   | 23  | 32    |
| double precision       | 1   | 11  | 52  | 64    |
| x86 extended precision | 1   | 15  | 64  | 80    |
| quad precision         | 1   | 15  | 112 | 128   |
많은 프로그래밍 언어에서 32비트 부동소수점은 float 또는 single 타입으로 표현된다.
64비트의 경우에는 double이라고 표현하는데 그 이유는, 위의 표에서 보듯이 64비트 부동 소수점 타입을 double precision으로 정의했기 때문이다.
single precision은 한국어로 단정밀도라 부르고, double precision은 단정밀도보다 정밀도가 2배 높아 배정밀도라고 부른다.

중요한 점은, **가수부 값이 클 수록 원래의 값을 더 많이 유지하여 정밀도가 높아진다**는 것이다.
예를 들어, 예를 들어, 123456.7890이라는 실수가 있고 표현할 수 가수부의 자릿수가 5라고 했을 때, 정규화를 거치게 되면 $1.234567890 \times 10^{5}$이다. 이때 표현 가능한 자리수는 5밖에 안되기 때문에 결국 가수부는 1.2345까지만 남을 수 있다. 실제로는 가수부를 조정하는 방법에 따라 반올림되면 $1.2346 \times 10^5$가 되고, 원래 값과의 차이인 6.7890만큼의 **정밀도 손실**이 발생한다.

## 부동소수점의 반올림 모드
IEEE 754-2008에서는 잘려나가는 뒷부분을 처리하는 5가지 방법을 정의했다. 이 표준은 **2진수 기반으로 반올림**한다.
- 짝수로 반올림(Round to nearest, ties to even)
	- 버려지는 비트들이 정확히 중간값일 때, 결과의 마지막 비트(LSB)가 0(짝수)이 되도록 반올림한다.
- 큰 절대값으로 반올림(Round to nearest, ties away from zero)
	- 반올림하려는 수의 소수부분이 정확히 0.5일 경우, 소수부분의 앞 자리 숫자에 관계없이 가장 가까운 정수 쪽으로 반올림된다. 즉, 0.5는 언제나 그보다 큰 정수 쪽으로 반올림된다.
- 올림(Always round up)
	- 반올림하려는 수가 양의 무한대에 가까워지는 경우에는 해당 양의 무한대 값을 반올림 결과로 사용한다.
- 내림(Always round down)
	- 반올림하려는 수가 음의 무한대에 가까워지는 경우에는 해당 음의 무한대 값을 반올림 결과로 사용한다.
- 절삭(Truncate)
	- 양수의 경우, 반올림하려는 수의 소수 부분을 무시하고, 가장 가까운 작은 정수로 반올림된다. 즉, 소수 부분이 있더라도 그 값을 무시하고 정수 부분만을 고려한다.
### GRS 비트를 이용한 반올림
가수부가 표현할 수 있는 길이를 넘어 잘려나가는 부분의 상위 3개 비트들이 각각 G, R, S 비트가 된다.

| 비트    | 이름         | 역할                                                                                                    |
| ----- | ---------- | ----------------------------------------------------------------------------------------------------- |
| **G** | Guard bit  | 잘려나가는 부분의 **첫 번째 비트**. 가장 중요한 비트로, 버려지는 값이 1/2 이상인지 아닌지를 판단하는 기준이다.                                   |
| **R** | Round bit  | 잘려나가는 부분의 **두 번째 비트**. 버려지는 값이 정확히 1/2인지, 1/2보다 큰지를 구분하는 데 사용된다.                                      |
| **S** | Sticky bit | 라운드 비트(R) **이후의 모든 비트들** 중 `1`이 하나라도 있으면 `1`이 된다. (즉, 모든 비트의 논리합 OR 연산). 버려지는 값이 0이 아닌 값을 가졌는지를 알려준다. |
- G=0 → 무조건 버림
    - 버려지는 부분이 0.5보다 **작다**는 의미다. (`.0...` 형태)
- G=1 and (R=1 or S=1) → 무조건 올림
    - 버려지는 부분이 0.5보다 **크다**는 의미다. (`.11...` 또는 `.10...01...` 형태)
- G=1 and R=0 and S=0 → 정확히 중간값(Tie)이므로 LSB를 확인해야 한다.
    - 버려지는 부분이 정확히 0.5라는 의미다. (`.1000...` 형태)
    - **저장될 부분의 LSB가 1 (홀수)이면 → 올림 (Round up)** 해서 짝수로 만든다.
    - **저장될 부분의 LSB가 0 (짝수)이면 → 버림 (Round down)** 해서 짝수를 유지한다.

가수부를 4비트만 저장할 수 있다고 가정해보자.
가수부 $1.1011100_{(2)}$:
1. 비트 할당
    - 저장될 부분: 1.101**1** → **LSB = 1**
    - 잘리는 부분: `100`
        - G = 1 (첫 번째 비트)
        - R = 0 (두 번째 비트)
        - S = 0 (세 번째 이후 비트가 모두 0이므로)
2. 논리 적용
    - `G=1`, `R=0`, `S=0` 이므로 정확한 중간값(Tie) 상황이다.
    - 저장될 부분의 LSB가 `1` (홀수)이므로, 결과를 짝수로 만들기 위해 **올림(Round up)**을 수행합니다.
        
    - `1.1011` + `0.0001` = `1.1100`
        
- **최종 결과**
    
    - 저장되는 가수부는 `1100`이 됩니다.




## 2진수 고정소수점과 부동소수점 비교
32비트 부동소수점을 예시로 비교한다.
### 고정소수점
![[32bit_고정소수점.png]]
정수부에는 2진수로 12가 실수부에는 0.375가 들어가 있다. 위의 구성으로 표현할 경우 정수부는 8비트만 사용할 수 있기 때문에 255이상의 값은 사용할 수 없다. 64비트 배정밀도를 사용한다고 해도 2047 이상은 사용할 수 없어, 너무 좁은 범위의 수만 표현 가능하다는 단점이 있다.
### 부동소수점
![[32bit_부동소수점.png]]
$1.100011_{(2)} \times 2^{3}$를 부동소수점으로 표현한 것이다. 2진수의 경우 정규화를 거치먼 가수부는 밑수인 2보다 항상 작은 수인 1로 시작하므로 생략이 가능하여 가수 비트 한 자리를 아낄 수 있게 되므로 더 많은 수를 표현할 수 있다.
지수부가 $10000010_{(2)}$으로 10진수로 변환하면 130이 된다. 3이어야 할 지수가 130인 이유는 부동소수점의 지수 표현은 편향된 지수(biased exponent) 방식을 사용하기 때문이다.
## 편향 지수(Biased Exponent)
IEEE 754 표준에서는 부동소수점 숫자를 효율적으로 표현하고 비교하기 위해 편향 지수 방식을 사용한다. 이 방식은 실제 지수 값에 **편향(bias)** 이라고 부르는 고정된 값을 더하여 저장하는 기법이다.
이는 **지수의 부호(양수/음수)를 별도의 부호 비트 없이 표현**하고, **부동소수점 값들의 크기 비교를 단순화**하기 위함이다.

만약 지수부에 일반적인 2의 보수 방식을 사용하면, 음수 지수는 최상위 비트(MSB)가 1이 된다 (e.g. -1은 `11111111`). 이 경우, 실제 값이 더 큰 양수 지수를 가진 숫자(e.g. +1, `00000001`)가 비트 패턴상으로는 더 작아 보이는 문제가 발생하여, 단순한 정수 비교 로직을 사용할 수 없게 된다.

편향 지수 방식을 사용하면, 아주 작은 수(음수 지수)부터 아주 큰 수(양수 지수)까지 모두 양수 형태의 지수로 변환되어 저장된다. 이로 인해 **비트 패턴의 대소 관계와 실제 값의 대소 관계가 일치**하게 되어, 하드웨어가 부동소수점 숫자를 비교하는 과정이 훨씬 간단하고 빨라진다.

### 32비트 부동소수점에서의 계산
32비트 단정밀도 부동소수점은 편향 값으로 127을 사용한다.

편향 지수 = 실제 지수 + 편향

$1.100011_{(2)} \times 2^{3}$의 경우:
- 실제 지수: 3
- 저장되는 편향 지수: 3 + 127 = 130
- 8비트 지수부에 저장되는 값: $10000010_{(2)}$

0.25의 경우:
- 2진수 부동소수점 정규화 표현: $1.0 \times 2^{-2}$
- 저장되는 편향 지수: -2 + 127 = 125
- 8비트 지수부에 저장되는 값: $01111101_{(2)}$

## 정밀도 vs 표현 범위
부동소수점에서 정밀도는 유효숫자고, 표현 범위는 실제 숫자의 자릿수(크기)다.

예시로 -13.75를 32비트 부동소수점으로 표현해보자.

1. 음수이므로 부호 비트는 1이다.
2. 13.75를 정수부와 소수부로 나누어 2진수로 변환하면 $1101.11_{(2)}$이다.
3. 정규화하면 $1.10111_{(2)} \times 2^3$이고, 편향 값 127을 더하면 지수부는 130이된다.
4. 32비트 형식에 맞춰 값을 채우면 1 | 10000010 | 10111 000000000000000000 이다. (가수부 23비트는 정수 부분인 `1.`을 제외한 소수 부분을 왼쪽부터 채우고 나머지는 모두 0으로 채운다.)

- **정밀도 (Precision)는 가수부가 결정한다.**
    - 가수부 `10111000000000000000000`는 이 숫자의 실제 유효 숫자인 `1.10111`을 담고 있다.
    - 이 공간은 **23비트로 고정**되어 있다. 만약 변환하려는 숫자의 유효 숫자가 23비트가 표현할 수 있는 것보다 길다면(e.g. 1.2345678923456789), 뒷부분은 잘려나가거나 반올림되어 **정밀도 손실**이 발생한다. 이것이 바로 **숫자를 얼마나 세밀하게 표현할 수 있는지(Precision)** 를 결정하는 이유다.

- **표현 범위 (Range)는 지수부가 결정한다.**
    - 지수부 10000010은 원래 2진수 `1101.11`의 소수점을 **3칸** 옮겼다는 정보를 담고 있다.
    - 이 8비트 지수부는 매우 큰 값(최대 127)이나 매우 작은 값(최소 -126)을 가질 수 있어서, 소수점을 아주 많이 왼쪽이나 오른쪽으로 이동시킬 수 있다. 이것이 바로 **숫자를 얼마나 크거나 작게 표현할 수 있는지(Range)** 를 결정하는 이유다.