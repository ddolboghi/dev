---
sticker: emoji//1f4d6
---
> [!NOTE]
> <객체지향 사고 프로세스 - 맷 와이스펠드> 요약 정리
# 1장 : 객체지향 개념소개
- 클래스는 속성과 메서드를 가지며 속성은 데이터, 메서드는 행위다.
- 클래스는 객체를 만드는 템플릿이다.
- A객체가 B객체에 메시지를 보낸다는 말은 A객체가 B객체의 메서드를 호출한다는 의미다.
- 객체지향 설계에서 객체는 다른 객체와 상호 작용하는 데 필요한 인터페이스(public메서드)만 나타내고 객체 사용과 관련 없는 세부사항은 숨겨야한다.
- 모든 속성을 pirvate로 선언해야 데이터 은닉을 지킬 수 있다. 따라서 속성은 인터페이스의 일부가 아니다.
- 상속은 is-a관계다.
- 다형성은 슈퍼클래스를 상속하는 서브클래스들의 공통 인터페이스마다 반환값이 달라지는 것이다. 즉, 비슷한 객체가 다른 방식으로 동일한 메시지에 응답할 수 있다.
- 합성은 어떤 객체를 그 밖의 객체들을 사용해 구축하거나 합성하는 것이다.
  (e.g. 엔진을 따로 만들어두면 다양한 자동차에 해당 엔진을 사용할 수 있다.)
- 합성은 has-a관계다. (e.g. 자동차 has a 엔진)
# 2장 : 객체라는 관점에서 생각하는 방법
- 클래스에 대한 인터페이스에는 사용자가 알아야할 내용만 포함해야 한다.
- 클래스 설계 시 가장 중요한 고려사항은 클래스 사용자를 식별하는 것이다.
- 구현부를 변경해도 사용자는 자신의 코드를 변경하지 않아도 되게 해야 한다.
- 기본 인터페이스를 변경하면 사용자는 행위를 변경해야 한다.
- 인터페이스 설계 시 재사용성이 높도록 추상적으로 생각해라
- 클래스 설계 시 최소한의 인터페이스로 시작해라
- 사용자가 실제로 필요로 할 때 인터페이스를 추가해라
- 공개 인터페이스를 지정해 사용자가 접근할 수 있는 대상을 정의한다.
- 사용자의 관점에서 클래스를 설계해라
- 누가 사용자인지 결정하고 클래스를 설계해라. 이때 사용자도 객체다.
- 객체의 목적과 행위를 모든 사용자의 관점에서 보고 최종 공개 인터페이스를 선발해라
- 컴퓨터 하드웨어가 객체의 행위에 제약을 가할 수 있다.
- 공개 인터페이스 식별: 각 인터페이스에 대해 인터페이스가 객체를 다루는 일에 기여하는지 여부를 결정해야한다.
- 구현부 식별: 비공개 메서드도 구현부의 일부다.
- 객체지향적 사고를 설명하는 자신만의 방식을 세워라
# 3장 : 그밖의 객체지향 개념들
## 생성자
```java
public int Cabbie() {}
```
- 위 처럼 클래스를 정의한 코드 그대로일때 이 클래스를 부류체(class)라고 부른다면, 이 부류체는 생성자에 의해서 구성체(construct)가 되고, 이 구성체는 사례체(instance)가 되어 활용된다.
- 붕어빵 틀 설계도 = class, 붕어빵 틀 = construct, 붕어빵 = instance
- 객체의 instance는 클래스의 constructor로 구성한 construct들 중 한 가지 사례(an instance)다.
- 상황에 관계없이 클래스에 항상 생성자를 한 개 이상 두는게 좋다.
- **클래스에 속성이 있으면 항상 초기화해라**
- 생성자를 작성하면 기본 생성자는 제공되지 않는다.
- Java, C#은 반환 타입이 다르면 메서드오버로딩 X 
- 생성자는 애플리케이션이 안전한 상태인지 확인하는데 사용된다.
- 생성자에서 클래스의 모든 속성을 안정한 상태로 초기화해야한다.
## 오류처리
- 문제를 무시하지 말고, 문제를 발견하면 복구해라
- 예외를 발생시키면 처리 비용이 늘어날 수 있으므로 다양한 오류처리 기술을 섞어써라
	- 오류에 대비해 클래스를 설계하는 방법 등
- bulletproof code : 프로그램을 가능한 한 사용자에게서 강력히 보호하는 게 좋다.
## 다중 상속
- 인터페이스는 행위 상속이고 추상 클래스는 구현부 상속이다.
- 다중 상속은 연산자 오버로딩과 비슷한 상황이다.
- 다중 상속을 이용하면 문제를 쉽게 해결할 수 있지만 시스템의 복잡도가 증가한다.
## 객체 복사 및 비교
- deep copy : 모든 참조를 따르고 참조된 모든 객체에 대해 새 사본 작성
- shallow copy : 단순히 참조만 복사
- 클래스 설계 시 비교 메서드를 만들어 두는 것을 고려해라
# 4장 : 클래스 해부하기
- 클래스가 얼마나 유용한지, 클래스들끼리의 상호작용을 하는 방식이 무엇인지
- 클래스 초기 설계 시에 인터페이스에 초점을 맞춰야한다.
- 클래스 이름만으로 해당 클래스가 어떤 것인지 어느 정도 알 수 있어야 한다.
- 객체에 대한 정보를 저장하는 속성은 객체의 상태를 나타낸다.
- 가능한 한 많은 속성을 숨겨서 인터페이스 최소 주의 원칙을 준수한다.
- 접근자 메서드(getter/setter)를 사용하는 이유는 데이터 무결성과 효율적인 디버깅 때문이다.
- 비공개 메서드는 구현부의 일부며, 외부에서 접근 불가하다.
# 5장 : 클래스 설계 지침
- 객체의 실제 행위를 나타내는 방식으로 클래스를 설계해야한다.
- 공개 인터페이스를 최소한으로 유지해라
- 올바르게 설계되면 기존 클래스를 활용하는 확장 인터페이스가 되도록 새 클래스를 만들 수 있기 때문에 상속으로 행위를 추가하기보다 인터페이스를 사용해 행위를 추가해야한다.
- 사용자에게 정보를 제공하되 상세한 사항을 숨겨라
- 구현부를 변경해도 사용자의 애플리케이션 코드를 변경할 필요가 없어야 한다.
- 소멸자를 포함하는 언어에서는 소멸자에서 객체가 획득한 메모리를 해제해야 한다.
- 생성자 주입 : 서비스 클래스를 객체를 생성할때 생성자에 주입한다.
- 메모리 누수 : 객체의 수명주기 동안 획득한 메모리가 객체에서 올바르게 해제되지 않을시 해당 메모리가 전체 운영체제의 메모리를 소모한다.
- 애플리케이션이 중단되지 않도록 잠재적 오류를 무시하지 마라
- 설계 과정을 간단 명료하게 문서화해라
- 클래스를 설계할때 다른 객체가 클래스와 상호작용하는 방식을 알고 있어야 한다.
- 정적 클래스를 사용하는 경우는 도우미 클래스나 부작용을 일으키지 않는 확장 메서드를 사용할때다.
- 한 가지 명명 규칙을 선택해 그 규칙을 지켜라
- 변수의 사용 방식을 알 수 있게 이름을 짓되, 변수의 형식을 알게하는 부호를 넣지 마라
- 이식하기 어려운 코드(네이티브 코드)를 클래스에서 뽑아내어 추상화(자체 클래스나 오버라이딩 가능한 자체 메서드로 분리)해라
- 시스템 종속 코드를 기본 클래스에 넣지 마라 -> 래퍼 클래스를 만들어라
- 클래스가 예상대로 작동하는지 확인하기 위해 객체를 복사하고 비교하는 방법을 설계해라
- 변수의 범위를 최대한 작게 유지해라
```java
public class Math {
	int temp = 0; //클래스 변수
	
	public int swap(int a, int b) {
		temp = a;
		a = b;
		b = temp;
		return temp; //temp가 swap()범위 안에서만 필요하므로 클래스 변수일 필요가 없다.
	}
}
```
- 유지보수성을 높이려면 클래스 간 의존성을 낮춰야 한다.
- 코드 크기를 작게 작성해서 각 단계별로 코드를 빌드하고 테스트해라
- 인터페이스 설계에 문제가 있으면 만족할때까지 설계를 변경해라
- 객체 지속성을 위해 저장 장치에 객체를 영구적으로 저장할 수 있다.
	- XML, JSON으로 객체를 직렬화해 저장(구식)
	- 미들웨어를 사용해 객체를 관계형 모델로 변환해 RDBMS에 저장
	- 객체를 NoSQL 데이터베이스에 저장
- 객체 직렬화(serialization) : 객체의 구성을 해체해 평평하게 만들어 전송하고 전송 받는 곳에서 객체를 역직렬화(deserialization)하는 것
	- 직렬화와 역직렬화는 동일한 규격을 따라야 한다.(Java의 `Serializable`인터페이스)
- 객체 마샬링(marshaling) : 통신선을 통해 객체를 보내는 행위
