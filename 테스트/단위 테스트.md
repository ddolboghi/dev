---
sticker: emoji//1f9ea
---
SUT(system under test) : 테스트 대상 시스템, 테스트할 대상을 지칭함
# 테스트는 코드의 단위를 검증해서는 안 된다.
- **테스트는 동작의 단위, 즉 문제 영역에 의미가 있는 것, 이상적으로는 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야한다.**
- 동작 단위를 구현하는데 클래스가 얼마나 필요한지는 상관없다.
- 단위는 여러 클래스에 걸쳐있거나 한 클래스에만 있을 수 있고, 아주 작은 메서드가 될 수도 있다.
- **단위 테스트는 외부 요인을 모두 배제하도록 코드를 작성해야 한다.**
# 단위 테스트하는 이유
- 에러를 고치는데 드는 비용이 감소한다.
- 시스템이 무엇을 하는지 이해하기 쉽다.
# 단위 테스트의 정의
- ==작은 코드 단위를 검증하고, 빠르게 수행하고, 격리된 방식으로 처리==하는 자동화된 테스트다.
- 작은 코드 단위는 단일 클래스거나 해당 클래스 내의 메서드다.
- 격리 문제에 대해 고전파와 런던파 두 가지 견해가 있다.
## 런던파
- 테스트 대상 객체를 협력자에게서 격리하기 위해 ==테스트 대상 객체의 모든 의존성==(하나의 클래스가 다른 클래스 또는 여러 클래스에 의존)==을 테스트 대역으로 대체한다.==
- 주로 테스트 대역 중 하나인 mock으로 교체한다.
- 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중한다.
- 테스트가 실패하면 테스트 대상 시스템이 고장난 것을 확실히 알 수 있다. 
- 의존성을 테스트 대역으로 대체하기 때문에 객체 그래프가 아무리 커도 분할할 수 있다.
- 테스트 대상 클래스를 의존성에서 분리하면 단순한 테스트 스위트 구조(프로덕션 코드의 각 클래스에 대해 테스트 클래스가 하나씩 있는 구조)를 확립할 수 있다.
- 테스트가 세밀해서 한번에 한 클래스만 확인하므로 입자성(granularity)이 좋다.
- 클래스를 단위로 간주한다.
- 하향식 TDD로 단위 테스트하며, 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작한다.
- 테스트가 구현 세부 사항에 자주 결합된다.(과도한 명세(over-specification) 문제)
## 고전파
- 코드를 격리하지는 않지만 단위 테스트는 서로 격리해서 실행한다.
- 여러 클래스가 모두 메모리에 상주하고 공유 상태(static또는 데이터베이스, 파일 시스템등 프로세스 외부 의존성)가 아니면 여러 클래스를 한 번에 테스트해도 된다.
- 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있다.
- 고전파의 단위 테스트 정의: ==단일 동작 단위를 검증하고, 빠르게 수행하고, 다른 테스트와 별도로 처리한다.

> [!공유 의존성 vs 비공개 의존성 vs 프로세스 외부 의존성]
> 공유 의존성
> - 테스트 간에 공유되고 서로의 결과에 영향을 미치는 의존성(e.g. 정적 가변 필드 등)
> - 모든 공유 의존성은 변경 가능하다.
> - 싱글턴, 클래스의 정적 필드
> 
> 비공개 의존성
> - 공유하지 않는 의존성
> - 변경 가능하거나 불변일 수 있다.
> - 불변인 경우 값 객체라고 부른다.
> 
> 프로세스 외부 의존성
> - 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
> - 아직 메모리에 없는 데이터에 대한 프록시(proxy)다.
> - 프로세스 외부 의존성은 대부분 공유 의존성이지만 그렇지 않은 경우도 있다.
> e.g. 테스트 실행 전에 도커 컨테이너로 시작한 데이터베이스는 테스트가 데이터를 변경할 수 없으므로 각 테스트 결과가 서로 영향을 주지 않는다.
> - 프로세스 외부 의존성의 공유는 의존성 내부상태를 수정해 단위 테스트간 통신하는 것이다.
> - 프로세스 외부의 불변 의존성은 의존성 내부 상태를 수정할 수 없으므로 공유 의존성이 될 수 없다.
- 단위 테스트를 격리하는 것은 테스트 대상 클래스에서 공유 의존성만 격리하는 것이다.
- 공유 의존성은 테스트 대상 클래스 간이 아니라 단위 테스트 간에 공유한다.
- 변경 가능한 의존성을 공유하려면 여러 테스트에서 재사용되야한다.
- 협력자는 공유하거나 변경 가능한 의존성이다.
- 실제 프로젝트에서 프로세스 외부가 아닌 공유 의존성은 거의 없다.
## 런던파와 고전파의 차이

|        | 격리주체    | 단위의 크기                  | 테스트 대역 사용 대상      |
| ------ | ----------- | ---------------------------- | -------------------------- |
| 런던파 | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성                           |

# 단위 테스트 명명법
- 안좋은 관습 : `[테스트 대상 메서드]_[시나리오]_[예상결과]` -> 동작 대신 구현 세부사항에 집중하도록 부추긴다.
- 간단하고 쉬운 영어 구문이 고객이나 도메인 전문가들이 이해하기 쉽다.
- 엄격한 명명 규칙은 필요없다.
- 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름 짓는다.
- 단어를 밑줄(\_) 표시로 구분해 긴 이름의 가독성을 향상시킨다.
- 테스트 이름에 테스트 대상 객체의 메서드명을 포함하지 않는다.
	- 메서드명을 포함하면 해당 코드의 구현 세부사항과 테스트 간의 결합도가 높아져 테스트 스위트의 유지 보수를 힘들게 한다.
	- 단, 유틸리티 코드는 비즈니스 로직이 없고 단순 보조 기능 뿐이므로 비개발자에게 의미 없어 메서드 이름을 사용해도 괜찮다.
- 단, 테스트 클래스의 이름에는 밑줄 표시를 사용하지 않는다.
- `[클래스명]Tests`는 동작 단위로 검증할 수 있는 진입점 또는 API로 여긴다.
- 사실을 서술해야하므로 소망이나 욕구가 들어가면 안 된다.
# Tip
- 테스트의 가장 마지막에 assert문을 작성해라
- 테스트 코드가 정상적으로 동작하는지 증명하기위해 의도적으로 테스트에 실패해라
- 단위 테스트를 작성할때는 전체적인 시각에서 시작해야한다.
- 개별 메서드를 테스트하는 것이 아니라 클래스의 종합적인 동작을 테스트해야한다.
- 테스트 클래스에 static필드 사용을 피해야한다.
  static필드가 있다면 테스트마다 새로운 인스턴스를 생성해도 상태가 공유되기때문
- 검증문 라이브러리로 테스트 가독성을 향상시킬 수 있다.

# JUnit
## JUnit의 hamcrest
- hamcrest assert가 실패하면 `assertTrue()`보다 더 많은 정보가 든 오류 메시지 출력
## `assertThat()`
- 명확한 값을 비교
- 첫 번째 인자는 실제 표현식, 검증하고자하는 값
- 두 번째 인자는 matcher로 실제 값과 표현식의 결과 비교
## JUnit hamcrest matcher
- 객체 타입 검사
- 두 객체의 참조가 같은 인스턴스인지 검사
- 다수의 매처를 결합하여 둘다 혹은 둘 중에 어떤 것이든 성공하는지 검사
- 어떤 컬렉션이 요소를 포함하거나 조건에 부합하는지 검사
- 어떤 컬렉션이 아이템 몇개를 모두 포함하는지 검사
- 어떤 컬렉션에 있는 모든 요소가 매처를 준수하는지 검사
- 사용자 정의 매처 생성 가능 [참고](https://code.google.com/p/hamcrest/wiki/Tutorial)
	`org.hamcrest.TypeSafeMatcher`를 상속해 매칭할 타입 지정

# 단위 테스트 스타일
## 출력 기반 테스트(output-based testing)
- 테스트 대상 시스템에 입력을 넣고 생성되는 출력 검증
- 상태를 변경하지 않는 코드에만 적용됨
- 함수형 스타일임
## 상태 기반 테스트(state-based testing)
- 작업이 완료된 후 시스템 상태 확인
- 상태라는 뜻은 프로세스 외부 의존성의 상태도 내포함
## 통신 기반 테스트(communication-based testing)
- mock을 사용해 테스트 대상 시스템과 협력자 간의 통신 검증
# AAA패턴
- arrange(준비), act(실행), assert(검증) 패턴으로  given-when-then패턴과 같음
- arrange : SUT와 해당 의존성을 원하는 상태로 만듬
- act : SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 출력이 있으면 출력값을 캡처함
- assert : 반환 값 또는 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 검증
- TDD는 제품 코드전에 테스트 코드를 작성하기 때문에 assert부터 시작할 수 있다.
- 테스트 전에 제품 코드를 작성한다면 테스트를 작성할 시점에 이미 실행 결과를 예상하고 있으므로 arrange부터 시작하는게 좋다.
- 단위 테스트에 여러 개의 act, assert를 두지 마라
- 테스트는 분기가 없어야하므로 if문을 사용하지마라
- arrange구절은 매우 클수도 있다.
- act구절은 보통 한 줄이고, 두 줄 이상이면 프로덕션 코드에 문제가 있을 수 있다.
	- 단일 작업을 수행하는데 두 개의 메서드가 호출된다면 캡슐화 위반일 수 있다.
	- 프로덕션 코드에서 데이터의 불변 위반이 발생하지 않도록 해야한다.
	- 유틸리티나 인프라 코드는 act구절이 두 줄 이상일 수 있다.
- assert구절은 여러 줄일 수 있지만 너무 커지지 않아야 한다.
	- 단일 동작 단위는 여러 결과를 낼 수 있고, 하나의 테스트로 모든 결과를 평가하는 것이 좋다.
- AAA패턴을 따르고 각 구절 사이에 빈 줄을 추가하거나 구절 주석을 작성해라.
# 테스트간 테스트 픽스처 재사용
- 테스트 픽스처 : 테스트 실행 대상 객체. 각 테스트 실행 전에 알려진 고정 상태를 유지하므로 동일한 결과를 생성한다.
- 주로 테스트 생성자에서 객체를 초기화해 재사용한다.
- 테스트에 공유 객체를 사용하면 테스트간 결합도가 높아지고 테스트 가독성이 떨어질 수 있다.
- private factory method(비공개 팩토리 메서드)를 사용해 객체를 재사용해라.
```java
class SomethigTest {
	private Store createStoreWithInventory(Product product, int quantity) {
		Store store = new Store();
		store.AddInventory(product, quantity);
		return store;
	}

	private static Customer createCustomer() {
		return new Customer;
	}

	//테스트 코드 작성
}
```
- 단, 객체가 거의 대부분의 테스트에 사용되면 생성자로 초기화할 수 있다.
	- 주로 데이터베이스와 작동하는 통합 테스트

# 매개변수화된 테스트
- JUnit의 `@ValueSource`, `@ParameterizedTest`
- 동작이 너무 복잡하면 매개변수화된 테스트를 사용하지 마라.
- 매개변수만으로 테스트 케이스를 판단할 수 있다면 긍정적인 테스트 케이스와 부정적인 테스트 케이스 모두 하나의 메서드로 두는 것이 좋다. 그렇지 않으면 긍정 케이스를 분리시켜라.
- 테스트 이름을 포괄적으로 만들수록 테스트 이름을 읽기 어렵게 한다.
# Mock vs Stub
- 테스트 대역 유형은 mock와 stub이 있다.
- mock은 외부로 나가는 상호작용을 모방하고 검사한다. 이러한 상호작용은 SUT가 상태를 변경하기 위한 의존성을 호출하는 것에 해당한다.
- stub은 내부로 들어오는 상호작용을 모방만 한다. 이러한 상호작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.
- 도구로서의 목은 목과 스텁 두 가지 유형의 테스트 대역을 생성할 수 있다.

|mock|설명|
|----|----|
|mock|목 프레임워크의 목|
|spy|수동으로 작성한 목|

| stub  | 설명                                                                                 |
| ----- | ------------------------------------------------------------------------------------ |
| stub  | 시나리오마다 다른 값을 반환하게끔 구성할 수 있도록 필요한 것을 다 갖춘 완전한 의존성 |
| dummy | null, 가짜 문자열 등 단순하고 하드코딩된 값                                          |
| fake  | 대다수의 목적에 부합하는 스텁과 같으나 아직 존재하지 않는 의존성을 대체한다는 차이점이 있음                                                                                     |
## stub으로 상호작용을 검증하지 마라
- stub은 SUT가 최종 결과를 산출하기 위한 입력 제공 수단일 뿐이다.
- 명령을 대체하는 테스트 대역은 mock이다.
	- 명령은 void메서드로, 부작용을 일으키고 반환 값이 없다.
- 조회를 대체하는 테스트 대역은 stub이다.
	- 조회는 부작용 없이 값을 반환한다.


## Mock 사용 시 주의사항
- mock이 프로덕션 코드의 동작을 올바르게 묘사하고 있는가?
- 프로덕션 코드는 생각하지 못한 다른 형식으로 반환하는가?
- 프로덕션 코드는 예외를 던지는가? null을 반환하는가?
- 이들 각 조건에 대해 다른 테스트가 필요할 수 있다.
- 테스트가 진짜로 mock으로 사용하는지 확인하려면 프로덕션 코드에서 런타임 예외를 던져봐라
- mock은 프로덕션 코드를 직접 테스트하는게 아니므로 테스트 커버리지에 빈틈이 생긴다.
- mock은 단위 테스트 커버리지의 구멍을 만드므로 통합 테스트를 해야한다.
# 테스트 코드 리팩토링
- 테스트 코드에서 try-catch문을 사용하지 않는게 좋다. JUnit이 예외를 알아서 잡아준다.
- 테스트 코드에서 필요하지 않은 경우 null여부를 검사하지 않는다. 테스트 프레임워크가 알아서 잡아준다.
- 단일 개념을 구현하는 2줄 이상의 코드가 있다면 이를 1줄로 줄이기를 시도해라
- 테스트 코드에서도 매직 넘버 대신 `static final`로 상수를 사용해라
- 쓸데없이 분리된 생성 구문을 줄여라
	```java
	//생성구문이 분리되있음
	byte[] bytes = inputValue.getBytes();
	ByteArrayInputStream stream = new ByteArrayInputStream(bytes);

	//생성구문 줄이기
	private InputStream input(String inputValue) {
		return new ByteArrayInputStream(pageContent.getBytes());
	}
	```
- 하나의 테스트에는 하나의 assert문만 있어야 한다.
- 테스트와 무관한 세부 사항들은 `@Before..`, `@After..`에 둔다.
- assert문이 준비단계로부터 기대하는 이유가 분명해야한다.
- 명시적인 테스트 데이터를 사용해라
- 다른 사람들이 테스트를 이해하기 쉽도록 작성해라
- 깔끔한 설계는 최적화를 위한 최선의 준비다.(성능이 매우 중요하지 않은 이상 메서드 분리로 반복문이 늘어나는 것을 염려하지 마라)
