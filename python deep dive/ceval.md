# CPython `Python/ceval.c` 분석 보고서

## 1. 개요

`ceval.c` 파일은 CPython 인터프리터의 심장부로, Python 바이트코드를 실행하는 핵심 로직인 **평가 루프(Evaluation Loop)**를 포함하고 있습니다. Python 코드가 실행될 때, 컴파일된 바이트코드는 이 평가 루프에 의해 한 명령어(opcode)씩 해석되고 실행됩니다. 이 파일의 성능은 Python의 전체 실행 속도에 직접적인 영향을 미칩니다.

## 2. 주요 구성 요소 및 개념

`ceval.c`의 동작을 이해하기 위한 핵심 요소는 다음과 같습니다.

### 가. 평가 루프 (`_PyEval_EvalFrameDefault`)

이 파일의 가장 중요한 함수는 `_PyEval_EvalFrameDefault` 입니다. 이 함수는 프레임(frame)을 받아 해당 프레임의 바이트코드를 순차적으로 실행하는 거대한 루프를 포함합니다. CPython 3.13에서는 성능 최적화를 위해 전통적인 `switch-case` 문 대신 **컴퓨티드 goto(Computed Gotos)** (`opcode_targets.h`를 통해 구현)를 사용하여 각 옵코드에 해당하는 핸들러로 직접 점프합니다.

### 나. 실행 프레임 (`_PyInterpreterFrame`)

프레임은 코드 실행의 컨텍스트를 담는 자료구조입니다. 각 함수 호출은 자신만의 프레임을 가집니다. 프레임에는 다음 정보가 포함됩니다.

- **코드 객체 (`f_code`):** 현재 실행 중인 함수나 모듈의 컴파일된 바이트코드, 상수, 지역 변수 이름 등의 정보를 담고 있습니다.
- **값 스택 (Value Stack):** 옵코드 실행에 필요한 피연산자(operand)를 임시로 저장하고, 연산 결과를 푸시(push)하는 작업 공간입니다.
- **명령어 포인터 (Instruction Pointer):** 현재 실행해야 할 바이트코드 명령어의 위치를 가리킵니다.
- **지역 변수 및 전역 변수, 내장 함수 등에 대한 참조.**

### 다. 바이트코드와 옵코드 (Bytecode & Opcodes)

Python 소스 코드는 실행 전에 더 낮은 수준의 명령어 집합인 **바이트코드**로 컴파일됩니다. 각 바이트코드 명령어는 **옵코드(opcode)**와 필요한 경우 **인자(oparg)**로 구성됩니다. 예를 들어, `LOAD_CONST` 옵코드는 상수 풀에서 특정 상수를 값 스택에 푸시하는 역할을 합니다. 평가 루프는 이 옵코드들을 하나씩 처리하며 프로그램을 실행합니다.

## 3. 실행 흐름

`_PyEval_EvalFrameDefault` 함수의 실행 흐름은 대략 다음과 같습니다.

1.  실행할 프레임을 인자로 받습니다.
2.  무한 루프에 진입하여 프레임의 바이트코드를 실행합니다.
3.  **명령어 포인터**가 가리키는 위치에서 **옵코드**와 **인자**를 가져옵니다.
4.  컴퓨티드 goto를 사용해 해당 옵코드를 처리하는 코드로 점프합니다.
5.  옵코드 핸들러는 **값 스택**에서 피연산자를 팝(pop)하여 연산을 수행하고, 결과를 다시 스택에 푸시합니다.
6.  함수 호출(`CALL` 등), 예외 처리, 반복문 등의 제어 흐름을 관리합니다.
7.  함수가 반환(`RETURN_VALUE`)되거나 예외가 발생하여 프레임 실행이 종료되면 루프를 빠져나와 결과 값을 반환합니다.

## 4. CPython 3.13의 주요 특징 및 최적화

`ceval.c`는 CPython의 발전에 따라 지속적으로 개선되어 왔습니다. CPython 3.13 버전에서 관찰되는 주요 특징은 다음과 같습니다.

### 가. 티어드 인터프리터 (Tiered Interpreter)

-   **Tier 1 (일반 인터프리터):** `_PyEval_EvalFrameDefault`가 바로 Tier 1 인터프리터의 구현체입니다. 모든 바이트코드를 실행할 수 있는 범용 실행 엔진입니다.
-   **Tier 2 (최적화 인터프리터):** 코드 실행 중 "뜨거운(hot)" 코드 블록이 식별되면, 해당 코드는 더 빠르고 특화된 명령어(uops)로 구성된 **트레이스(trace)**로 변환됩니다. 이 트레이스는 `_PyTier2Interpreter` (또는 JIT 컴파일러)에 의해 훨씬 빠르게 실행됩니다. 이는 반복적인 코드의 실행 속도를 크게 향상시키는 **전문화 적응형 인터프리터(Specializing Adaptive Interpreter)**의 핵심입니다.

### 나. 인라인 캐싱 (Inline Caching)

속성(attribute) 로드, 전역 변수 접근 등 자주 발생하는 작업의 결과를 캐싱하여 다음 호출 시 더 빠르게 처리합니다. 바이트코드 명령어 자체를 실행 시점에 더 효율적인 버전으로 바꾸는 **적응형 옵코드(adaptive opcode)** 메커니즘을 통해 구현됩니다.

## 5. 결론

`ceval.c`는 Python 코드를 바이트코드 수준에서 실제로 생명을 불어넣는 CPython의 핵심 엔진입니다. 평가 루프, 프레임 관리, 값 스택 연산을 통해 프로그램의 흐름을 제어하며, CPython 3.13에서는 티어드 인터프리터와 같은 고급 최적화 기법을 도입하여 지속적으로 성능을 개선하고 있습니다. 이 파일의 구조와 동작 방식을 이해하는 것은 Python의 내부 동작 원리를 파악하는 데 매우 중요합니다.
