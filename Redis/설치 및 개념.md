# 설치
```bash
docker pull redis:6.2
```
# in-memory 데이터베이스 특징
- 밀리세컨드 단위의 빠른 응답 속도와 높은 처리량 -> 대용량 트래픽 서비스의 캐시 서버로 활용
- RAM 활용 -> 휘발성 데이터 -> 가용성 고려해야함
- 다양한 데이터 타입 및 자료구조 지원: string, hashtable, b-tree
# Remote Dictionary Server(Redis)
- in-memory 데이터베이스
- key-value 형식의 데이터 저장
- 메모리에 있는 데이터를 디스크에 저장할 수 있음
	- RDB: 특정 시점에 스냅샷을 찍어 전체 DB를 디스크에 저장, 메모리 사용률이 급증할 수 있어 모니터링해야함
	- AOF(Append Only File): 데이터 쓰기 명령어 적재, 복구 용이, 용량 커짐, 디스크에 쓰기 많이 해서 성능 영향
- 기본적으로 RDB, AOF 둘 중 하나나 둘다 또는 저장 없이 캐시 용도로만 사용할 수도 있음
- Strings, Lists, Sets, Hashes, Sorted sets 등 다양한 데이터 타입 저장 가능
- 클라이언트로부터 전달 받은 명령을 **싱글 스레드**로 처리

> [!NOTE] 싱글 스레드? 
> - 동시에 여러 명령어를 처리하지 않고 들어온 요청 순서대로 한번에 하나의 명령어 처리
> - 싱글 스레드 구조는 내부적으로 lock을 사용하지 않아도 원자적 실행 가능하고, 이를 통해 데이터 일관성 보장
> - 병렬 처리보다 단순함
> - 앞의 명령어를 처리하는데 오랜 시간이 걸리면 뒤 명령어들이 대기하면서 응답 속도 지연이 발생해 서비스 장애 발생 가능

- redis 공식문서에서 명령어들마다 big-O 알려주며, O(n)은 주의해야함
- redis v6.0 부터 멀티 스레드 i/o 도입: 명령 처리 부분과 i/o사이에 지연이 일어나지 않도록 i/o 부분에 별도의 스레드 지정 가능, 네트워크 in/out, 병렬 처리 가능
## redis 활용 사례
- 캐시 서버, 세션 스토어
- Pub/Sub: 메세지 발행(publish), 메세지 구독(subscribe)으로 서버간 메세지 주고 받음, 웹 어플리케이션은 비동기 처리, 실시간 채팅 가능
- Message queue: 메세지를 redis에 저장하고 해당 메세지를 필요로하는 서버에서 메세지를 요청하면 요청한 순서대로 메세지를 가져감 
# redis 실행 방법(docker)
도커 이미지 실행 방법과 같음
```bash
# -d 붙이면 백그라운드 실행
docker run --rm -it -d [IMAGE:VERSION]
docker run --rm -it redis:6.2
```

실행중인 컨테이너 확인하기
```bash
docker ps
```

도커 컨테이너를 외부 네트워크와 연결하는 방법
```bash
docker run --rm -it -d -p [PORT: PORT] [IMAGE:VERSION]
```

컨테이너 종료
```bash
docker kill [Container ID]
```
# Redis CLI
redis CLI 실행
```bash
docker exec -it [Container ID] redis-cli
```

redis로 전달된 명령이 적절한 명령어로 수행되는지 모니터링하기
```bash
docker exec -it [Container ID] redis-cli monitor
```

10ms 이상 소요된 명령어들 확인
```cli
slowlog get

1) ID
2) 실행시간
3) 수행시간(ms)
4) 명령
5) client ip/port
6) client name
```

설정 정보
```cli
info
```

메모리 사용률, 클라이언트 접속 수 블락된 수, 요청 수 등 redis 리소스 확인
```bash
docker exec -it [Container ID] redis-cli --stat
```

성능 테스트
1. 컨테이너로 접속
```bash
docker exec -it [container id] /bin/bash
```

2. 성능테스트 명령어 실행
```cli
redis-benchmark
```

숫자로 데이터베이스 구분, 다른 데이터베이스의 데이터 조회 못함
```cli
:6379> SELECT 0
:6379> SELECT 1
:6379[1]> SELECT 2
```

redisinsight: redis GUI 
# Redis 명령어
- `SET`: 데이터 저장
- key에 구분자를 넣어서 지정 가능
```cli
SET users:1:email siwoli@gmail.com 
```
users 중에 id가 1번인 key에 email 값이라는 의미

- `SETNX`: (SET IF NOT EXIST)데이터가 없을 경우

- `GET`: 하나의 데이터 조회

- `MGET`: 여러 데이터 조회
```cli
mget users:1:email gender name age
```
users중 id가 1번인 것의 email, gender, name, age 조회
> [!tip] 여러 key들의 value가 필요할때 `MGET`으로 한번에 가져오는게 성능 더 좋음

- `INC [key]`: value 1 증가
- `DEC [key]`: value 1 감소
- `INCRBY [key] [increment]`: value가 `increment`값만큼 증가
> [!tip] 원자적으로 숫자를 늘릴 수 있는 이유는 애플리케이션이 `GET`, `SET`만으로 숫자를 증가시킨다면 redis 싱글 스레드에서 1이 두번 설정되고 조회되어 결국 2가 아닌 1이 저장되기 때문

## key 주요 명령어
`EXPIRE [KEY] [SECOND]`: 모든 키의 삭제 시간 설정, `SET` 명령과 함께 사용 가능

`TTL [KEY]`: 키의 남은 시간 확인. 시간이 지난 키를 확인하면 음수로 출력됨

`DEL [KEY]`: 키가 동기적으로 삭제됨(데이터를 모두 삭제한 뒤에 키 삭제)

`UNLINK [KEY]`: 키를 비동기적으로 삭제(List, Set, Sorted Set, Hash 등 내부적으로 지워야할 요소가 많을때 동기적 삭제는 시간이 오래 걸려 뒤 명령어들이 지연) , 별도의 스레드에서 삭제 진행

`MEMORY USAGE [KEY]`: 해당 키의 메모리 사용량 확인
# 데이터 타입
## Lists
- 연결 리스트 구조(ex. Java ArrayList)
- 스택, 큐 구현에 사용 
- `LPUSH`, `RPUSH`, `LPOP`, `RPOP`, `LLEN` //O(1), `LRANGE`
- `LRANGE`로 최근 작성 게시물 조회
- `LRANGE 0 -1`: 처음부터 마지막 값까지 조회
## Sets
- 정렬되지 않은 집합(ex. Java Set)
- `SADD`: 값 추가. 이미 동일한 값이 있다면 추가되지 않고 0 반환
- `SREM`: 값 삭제
- `SISMEMBER`: 특정 값이 sets에 포함되있는지 여부
- `SMEMBERS`: sets의 전체 데이터 조회, $O(n)$
- `SINTER`: 2개 이상의 sets의 교집합, $O(m \times n)$
- `SCARD`: sets에 든 데이터 개수
## Sorted Sets
- 정렬된 집합(ex. Java SortedSet)
- 점수 기반 순위를 보여주는 기능, 특정 시간동안 요청이 일정 값 이상이면 차단
- `ZADD`: 값 추가 $O(logn)$
- `ZREM`: 값 삭제 $O(logn)$
- `ZRANGE`: 전체 데이터를 오름차순 조회. v6.2부터 `REV`(내림차순), `BYSCORE`(순위), `BYLEX`, `LIMIT` 가능
```cli
zrange game:scores 0 +inf byscore limit 0 3 withscores
```
scores를 기준으로 0부터 무한대까지 오름차순으로 상위 3개 키를 scores값과 함께 조회

```cli
zrange game:scores +inf 0 byscore rev limit 0 3 withscores
```
scores를 기준으로 무한대부터 0까지 내림차순으로 상위 3개 키를 scores값과 함께 조회

- `ZCARD`: 집합의 개수 조회
- `ZRANK` / `ZREVRANK`: 오름차순/내림차순에서 요청한 키값의 순위 조회
- `ZINCRBY`: 값을 원자적으로 증가시킴
## Hashes
- field-value 쌍(ex. Java Map)을 redis에서 하나의 key로 관리
- `HSET`: $O(1)$
```cli
hset [key] [field1] [value1] [field2] [value2] ...
```
- `HGET`, `HMGET`: $O(1)$
- `HGETALL`: hashes의 전체 field와 value 조회
- `HDEL`: $O(1)$
- `HINCRBY`: 특정 필드의 숫자값을 원자적으로 증가시킴, $O(1)$
## Geospatial
- 위도, 경도 저장
- `GEOADD`: $O(logn)$ 
- `GEOSEARCH`$O(n + logn)$
- `GEODIST`: 저장된 위치간 거리 조회
- `GEOPOS`: 키에 대해서 위/경도 조회
- `BYRADIUS`: 거리 기반으로 조회
## Bitmap
- 0 또는 1의 값으로 이루어진 비트열
- 매우 적은 메모리 사용 -> 대량 데이터 저장
- Sets으로 저장하던 데이터가 점점 많아져 메모리 부담되면 Bitmap 고려
- `SETBIT`
- `GETBIT`
- `BITCOUNT`: 1 개수 조회